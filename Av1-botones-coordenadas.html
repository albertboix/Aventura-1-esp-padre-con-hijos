<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Av1-botones-coordenadas-(hijo2)</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/mZEZxi5FrLdGShZ3Y="
          crossorigin=""/>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- Scripts -->
    <script type="module">
        'use strict';
        
        // Importar módulos necesarios (deben estar al nivel superior del módulo)
        import { 
            TIPOS_MENSAJE as TIPOS_MENSAJE_IMPORTADOS, 
            enviarMensaje, 
            registrarControlador, 
            inicializarMensajeria,
            ERROR_TYPES,
            ERROR_SEVERITY,
            ERROR_CODES,
            manejadorErrores as errorHandler
        } from './js/mensajeria.js';
        
        // Alias para consistencia
        const TIPOS_MENSAJE = TIPOS_MENSAJE_IMPORTADOS;
        
        // Alias para mensajes de navegación
        const NAV_MSG = TIPOS_MENSAJE.NAVEGACION;
        const SISTEMA_MSG = TIPOS_MENSAJE.SISTEMA;
        
        // Esquemas de validación para mensajes
        const ESQUEMAS_VALIDACION = {
            // Mensajes de navegación
            [NAV_MSG.INICIAR]: {
                required: ['destino', 'modo'],
                properties: {
                    destino: { type: 'object', required: ['lat', 'lng'] },
                    modo: { type: 'string', enum: ['caminando', 'enBicicleta', 'accesible'] },
                    ruta: { type: 'object', optional: true }
                }
            },
            [NAV_MSG.DETENER]: {
                required: ['motivo'],
                properties: {
                    motivo: { type: 'string' },
                    forzado: { type: 'boolean', optional: true }
                }
            },
            [NAV_MSG.ORIENTACION]: {
                required: ['grados', 'precision'],
                properties: {
                    grados: { type: 'number', minimum: 0, maximum: 360 },
                    precision: { type: 'number', minimum: 0, maximum: 100 },
                    timestamp: { type: 'number', optional: true }
                }
            },
            [NAV_MSG.CAMBIO_PARADA]: {
                required: ['paradaId', 'parada'],
                properties: {
                    paradaId: { type: 'string' },
                    parada: { type: 'object' },
                    indice: { type: 'number', optional: true },
                    total: { type: 'number', optional: true }
                }
            },
            [NAV_MSG.ESTABLECER_DESTINO]: {
                required: ['destino'],
                properties: {
                    destino: { type: 'object', required: ['lat', 'lng'] },
                    nombre: { type: 'string', optional: true },
                    modo: { type: 'string', optional: true }
                }
            },
            
            // Mensajes del sistema
            [SISTEMA_MSG.ERROR]: {
                required: ['tipo', 'mensaje'],
                properties: {
                    tipo: { type: 'string' },
                    mensaje: { type: 'string' },
                    codigo: { type: 'string', optional: true },
                    stack: { type: 'string', optional: true },
                    contexto: { type: 'object', optional: true }
                }
            },
            [SISTEMA_MSG.CONFIGURACION]: {
                required: ['tema', 'idioma'],
                properties: {
                    tema: { type: 'string' },
                    idioma: { type: 'string' },
                    opciones: { type: 'object', optional: true }
                }
            },
            [SISTEMA_MSG.SINCRONIZAR]: {
                required: ['estado'],
                properties: {
                    estado: { type: 'object' },
                    componente: { type: 'string', optional: true },
                    timestamp: { type: 'number', optional: true }
                }
            },
            [SISTEMA_MSG.CONFIRMACION]: {
                required: ['tipo', 'exito'],
                properties: {
                    tipo: { type: 'string' },
                    exito: { type: 'boolean' },
                    mensaje: { type: 'string', optional: true },
                    datos: { type: 'object', optional: true }
                }
            },
            
            // Mensajes de UI
            [TIPOS_MENSAJE.UI.ACTUALIZAR]: {
                required: ['tipo'],
                properties: {
                    tipo: { type: 'string', enum: ['mensaje', 'estado', 'modo'] },
                    contenido: { type: ['string', 'object'], optional: true },
                    duracion: { type: 'number', optional: true },
                    prioridad: { type: 'string', enum: ['baja', 'media', 'alta'], optional: true }
                }
            },
            
            // Mensajes de GPS
            [TIPOS_MENSAJE.GPS.ACTUALIZAR]: {
                required: ['lat', 'lng'],
                properties: {
                    lat: { type: 'number', minimum: -90, maximum: 90 },
                    lng: { type: 'number', minimum: -180, maximum: 180 },
                    precision: { type: 'number', minimum: 0, optional: true },
                    altitud: { type: 'number', optional: true },
                    velocidad: { type: 'number', minimum: 0, optional: true },
                    rumbo: { type: 'number', minimum: 0, maximum: 360, optional: true },
                    timestamp: { type: 'number', optional: true }
                }
            },
            [TIPOS_MENSAJE.GPS.COMANDO]: {
                required: ['accion'],
                properties: {
                    accion: { type: 'string', enum: ['iniciar', 'detener', 'pausar', 'reanudar'] },
                    opciones: { type: 'object', optional: true }
                }
            },
            
            // Mensajes de datos
            [TIPOS_MENSAJE.DATOS.ARRAY_ACTUALIZADO]: {
                required: ['tipo', 'datos'],
                properties: {
                    tipo: { type: 'string' },
                    datos: { type: 'array' },
                    hash: { type: 'string', optional: true },
                    timestamp: { type: 'number', optional: true }
                }
            },
            [TIPOS_MENSAJE.DATOS.SOLICITUD]: {
                required: ['tipo', 'filtros'],
                properties: {
                    tipo: { type: 'string' },
                    filtros: { type: 'object' },
                    paginacion: { type: 'object', optional: true }
                }
            }
        };
        
        /**
         * Valida los datos de un mensaje según su tipo
         * @param {string} tipo - Tipo de mensaje (de TIPOS_MENSAJE)
         * @param {Object} datos - Datos a validar
         * @throws {Error} Si la validación falla
         */
        function validarDatosMensaje(tipo, datos) {
            const esquema = ESQUEMAS_VALIDACION[tipo];
            if (!esquema) {
                logger.warn(`No hay esquema de validación para el tipo de mensaje: ${tipo}`);
                return; // No hay esquema de validación para este tipo
            }
            
            // Verificar campos requeridos
            if (esquema.required) {
                for (const campo of esquema.required) {
                    if (datos[campo] === undefined || datos[campo] === null) {
                        throw new Error(`Campo requerido faltante: ${campo}`);
                    }
                }
            }
            
            // Validar propiedades según el esquema
            if (esquema.properties) {
                for (const [prop, reglas] of Object.entries(esquema.properties)) {
                    // Si el campo es opcional y no está presente, lo saltamos
                    if (reglas.optional && datos[prop] === undefined) continue;
                    
                    // Si el campo es requerido o está presente, lo validamos
                    if (datos[prop] !== undefined) {
                        if (reglas.type && typeof datos[prop] !== reglas.type) {
                            throw new Error(`Tipo inválido para ${prop}: se esperaba ${reglas.type}, se obtuvo ${typeof datos[prop]}`);
                        }
                        
                        if (reglas.enum && !reglas.enum.includes(datos[prop])) {
                            throw new Error(`Valor inválido para ${prop}: ${datos[prop]}. Valores permitidos: ${reglas.enum.join(', ')}`);
                        }
                        
                        if (reglas.minimum !== undefined && datos[prop] < reglas.minimum) {
                            throw new Error(`${prop} debe ser mayor o igual a ${reglas.minimum}`);
                        }
                        
                        if (reglas.maximum !== undefined && datos[prop] > reglas.maximum) {
                            throw new Error(`${prop} debe ser menor o igual a ${reglas.maximum}`);
                        }
                        
                        // Validar objetos anidados
                        if (reglas.type === 'object' && reglas.required) {
                            for (const campo of reglas.required) {
                                if (datos[prop][campo] === undefined || datos[prop][campo] === null) {
                                    throw new Error(`Campo requerido faltante en ${prop}: ${campo}`);
                                }
                            }
                        }
                    }
                }
            }
        }
        
        /**
         * Envía un mensaje con lógica de reintento
         * @param {string} destino - Destinatario del mensaje
         * @param {string} tipo - Tipo de mensaje (de TIPOS_MENSAJE)
         * @param {Object} datos - Datos del mensaje
         * @param {number} [intentos=0] - Número de intentos actual (uso interno)
         * @returns {Promise<Object>} Respuesta del mensaje
         */
        async function enviarMensajeConReintento(destino, tipo, datos = {}, intentos = 0) {
            try {
                // Validar los datos antes de enviar
                if (ESQUEMAS_VALIDACION[tipo]) {
                    validarDatosMensaje(tipo, datos);
                }
                
                const mensaje = {
                    ...datos,
                    timestamp: new Date().toISOString(),
                    origen: CONFIG.IFRAME_ID,
                    destino,
                    version: '1.0',
                    intento: intentos + 1
                };
                
                return await enviarMensaje(destino, tipo, mensaje);
            } catch (error) {
                if (intentos < CONFIG.REINTENTOS.MAXIMOS) {
                    const tiempoEspera = CONFIG.REINTENTOS.TIEMPO_ESPERA * Math.pow(CONFIG.REINTENTOS.FACTOR, intentos);
                    logger.warn(`Reintentando envío (${intentos + 1}/${CONFIG.REINTENTOS.MAXIMOS}) en ${tiempoEspera}ms`, { tipo, error });
                    
                    await new Promise(resolve => setTimeout(resolve, tiempoEspera));
                    return enviarMensajeConReintento(destino, tipo, datos, intentos + 1);
                }
                
                logger.error('Número máximo de reintentos alcanzado', { tipo, error });
                throw error;
            }
        }
        
        // Configuración global para este módulo
        const CONFIG = {
            // Identificador único para esta instancia
            ID_APLICACION: 'av1-coordenadas',
            
            // Configuración de mensajería
            MENSAJERIA: {
                TIEMPO_ESPERA_RESPUESTA: 5000, // 5 segundos
                MAX_REINTENTOS: 3,
                TIEMPO_ENTRE_REINTENTOS: 1000 // 1 segundo
            },
            
            // Configuración de navegación
            NAVEGACION: {
                PRECISION_GPS: 10, // metros
                INTERVALO_ACTUALIZACION: 1000, // 1 segundo
                RADIO_LLEGADA: 10, // metros
                TIEMPO_ESTIMADO_POR_METRO: 1.2 // segundos por metro (ajustar según velocidad promedio)
            },
            
            // Configuración de la interfaz
            UI: {
                TIEMPO_MENSAJE_PREDETERMINADO: 3000, // 3 segundos
                TEMA_PREDETERMINADO: 'claro',
                IDIOMA_PREDETERMINADO: 'es'
            },
            
            // Depuración
            DEBUG: true,
            LOG_LEVEL: 1, // 0: debug, 1: info, 2: warn, 3: error, 4: none
            IFRAME_ID: 'hijo2-botones',
            DEBUG: true,
            LOG_LEVEL: 1, // 0: debug, 1: info, 2: warn, 3: error, 4: none
            REINTENTOS: {
                MAXIMOS: 3,
                TIEMPO_ESPERA: 1000,
                FACTOR: 2
            },
            // Distancia en metros para considerar que el usuario ha llegado a un punto
            DISTANCIA_UMBRAL: 30,
            TIEMPO_ACTUALIZACION: 1000,
            TIEMPO_MENSAJE: 5000
        };
        
        // Logger
        const logger = {
            debug: (mensaje, datos) => {
                if (CONFIG.DEBUG && CONFIG.LOG_LEVEL <= 0) {
                    console.debug(`[DEBUG] ${mensaje}`, datos || '');
                }
            },
            info: (mensaje, datos) => {
                if (CONFIG.LOG_LEVEL <= 1) {
                    console.log(`[INFO] ${mensaje}`, datos || '');
                }
            },
            warn: (mensaje, datos) => {
                if (CONFIG.LOG_LEVEL <= 2) {
                    console.warn(`[WARN] ${mensaje}`, datos || '');
                }
            },
            error: (mensaje, error, datos) => {
                if (CONFIG.LOG_LEVEL <= 3) {
                    console.error(`[ERROR] ${mensaje}`, error || '', datos || '');
                }
            }
        };
        
        // Estado de la aplicación
        const estado = {
            // Propiedades generales
            mensajeriaInicializada: false,
            controlesHabilitados: true,
            modoCompass: false,
            
            // Estado del modo
            modo: {
                actual: 'casa',
                anterior: null,
                ultimoCambio: new Date().toISOString(),
                cambioEnProgreso: false
            },
            configuracion: {
                distanciaUmbral: 30, // metros para considerar que se ha llegado a una parada
                distanciaMinimaParaPuntoInteres: 30 // metros mínimos para mostrar botón de punto de interés
            },
            // Estado de la navegación
            navegacion: {
                activa: false,
                pausada: false,
                puntoDestino: null,
                puntoActual: null,
                ruta: [],
                ultimaUbicacion: null,
                ultimaActualizacion: null,
                ultimoPuntoCompletado: null,
                proximoPunto: null,
                distanciaAlDestino: null,
                tiempoEstimado: null,
                orientacion: 0, // En grados (0-360)
                precision: null // Precisión del GPS en metros
            },
            // Configuración de la aplicación
            configuracion: {
                modoOscuro: false,
                notificaciones: true,
                sonidos: true,
                vibracion: true,
                actualizacionTiempoReal: true
            },
            // Estado de los controles
            controles: {
                habilitados: true,
                motivoDeshabilitacion: null,
                estadoAnterior: null
            },
            // Estado de la brújula
            brujula: {
                activa: false,
                soportada: false,
                calibrando: false,
                precision: 0
            },
            // Estado del GPS
            gps: {
                activo: false,
                soportado: false,
                permisoConcedido: false,
                ultimaUbicacion: null,
                precision: 0,
                estado: 'inactivo' // inactivo, obteniendo, activo, error
            },
            // Estado de los botones
            botones: {
                puntoInteres: {
                    estado: 'inactivo', // inactivo, activo, deshabilitado
                    texto: 'Punto de Interés',
                    icono: 'fa-map-marker-alt',
                    accion: 'seleccionarPuntoInteres'
                },
                gps: {
                    estado: 'inactivo',
                    texto: 'Iniciar Navegación',
                    icono: 'fa-directions',
                    accion: 'toggleNavegacion'
                },
                brujula: {
                    estado: 'inactivo',
                    texto: 'Brújula',
                    icono: 'fa-compass',
                    accion: 'toggleBrujula'
                },
                ayuda: {
                    estado: 'activo',
                    texto: 'Ayuda',
                    icono: 'fa-question-circle',
                    accion: 'mostrarAyuda'
                },
                repetir: {
                    estado: 'inactivo',
                    texto: 'Repetir',
                    icono: 'fa-redo',
                    accion: 'repetirUltimaAccion'
                }
            },
            // Historial de acciones
            historial: {
                acciones: [],
                ultimaAccion: null,
                maxAcciones: 10
            },
            // Estado de la interfaz
            ui: {
                cargando: false,
                mensaje: null,
                tipoMensaje: 'info', // info, exito, error, advertencia
                mostrarMensaje: false,
                tiempoMensaje: 5000 // ms
            }
        };
        
        // Inicializar mensajería
        inicializarMensajeria().then(() => {
            logger.info('Mensajería inicializada correctamente');
        }).catch(error => {
            logger.error('Error al inicializar la mensajería', error);
        });
        
        // Registrar controladores de mensajes
        registrarControlador(TIPOS_MENSAJE.INICIAR_NAV, (datos) => {
            logger.info('Iniciando navegación', datos);
            try {
                if (datos && datos.destino) {
                    iniciarNavegacionADestino(datos.destino);
                    return { exito: true, mensaje: 'Navegación iniciada' };
                } else {
                    throw new Error('Datos de destino no proporcionados');
                }
            } catch (error) {
                logger.error('Error al iniciar navegación', error);
                return { exito: false, error: error.message };
            }
        });
        
        registrarControlador(TIPOS_MENSAJE.PARAR_NAV, () => {
            logger.info('Deteniendo navegación');
            try {
                detenerNavegacion();
                return { exito: true, mensaje: 'Navegación detenida' };
            } catch (error) {
                logger.error('Error al detener navegación', error);
                return { exito: false, error: error.message };
            }
        });
        
        registrarControlador(TIPOS_MENSAJE.ACTUALIZAR_UBICACION, (datos) => {
            logger.debug('Actualizando ubicación', datos);
            try {
                if (datos && datos.ubicacion) {
                    actualizarUbicacion(datos.ubicacion);
                    return { exito: true };
                } else {
                    throw new Error('Datos de ubicación no proporcionados');
                }
            } catch (error) {
                logger.error('Error al actualizar ubicación', error);
                return { exito: false, error: error.message };
            }
        });
        
        // Controladores para habilitar/deshabilitar controles
        registrarControlador(TIPOS_MENSAJE.HABILITAR_CONTROLES, (datos) => {
            logger.info('Habilitando controles', datos);
            habilitarControles(datos?.motivo);
            return { exito: true };
        });
        
        registrarControlador(TIPOS_MENSAJE.DESHABILITAR_CONTROLES, (datos) => {
            logger.info('Deshabilitando controles', datos);
            deshabilitarControles(datos?.motivo);
            return { exito: true };
        });
        
        // Inicializar la interfaz
        document.addEventListener('DOMContentLoaded', () => {
            inicializarInterfaz();
            inicializarEventos();
            verificarCompatibilidad();
            actualizarEstadoBotones();
        });
        
        // Función para actualizar el estado de los botones
        function actualizarEstadoBotones() {
            Object.entries(estado.botones).forEach(([id, boton]) => {
                const elemento = document.getElementById(`btn-${id}`);
                if (elemento) {
                    // Actualizar clases según el estado
                    elemento.classList.toggle('active', boton.estado === 'activo');
                    elemento.classList.toggle('disabled', boton.estado === 'deshabilitado');
                    
                    // Actualizar icono y texto si es necesario
                    const icono = elemento.querySelector('i');
                    if (icono) {
                        icono.className = `fas ${boton.icono}`;
                    }
                    
                    const texto = elemento.querySelector('span');
                    if (texto) {
                        texto.textContent = boton.texto;
                    }
                }
            });
        }
        
        // Función para manejar clics en botones
        function manejarClicBoton(botonId) {
            const boton = estado.botones[botonId];
            if (!boton || boton.estado === 'deshabilitado' || !estado.controles.habilitados) {
                return;
            }
            
            // Ejecutar la acción correspondiente
            switch(boton.accion) {
                case 'seleccionarPuntoInteres':
                    seleccionarPuntoInteres();
                    break;
                case 'toggleNavegacion':
                    toggleNavegacion();
                    break;
                case 'toggleBrujula':
                    toggleBrujula();
                    break;
                case 'mostrarAyuda':
                    mostrarAyuda();
                    break;
                case 'repetirUltimaAccion':
                    repetirUltimaAccion();
                    break;
            }
            
            // Registrar acción en el historial
            registrarAccion(boton.accion, { botonId });
        }
        
        // Funciones de utilidad
        function habilitarControles(motivo = null) {
            estado.controles.habilitados = true;
            estado.controles.motivoDeshabilitacion = null;
            actualizarEstadoBotones();
            logger.info('Controles habilitados', { motivo });
        }
        
        function deshabilitarControles(motivo = 'Sin motivo especificado') {
            estado.controles.habilitados = false;
            estado.controles.motivoDeshabilitacion = motivo;
            actualizarEstadoBotones();
            logger.info('Controles deshabilitados', { motivo });
        }
        
        function registrarAccion(accion, datos = {}) {
            const accionRegistro = {
                tipo: accion,
                timestamp: new Date().toISOString(),
                datos
            };
            
            // Mantener un máximo de acciones en el historial
            if (estado.historial.acciones.length >= estado.historial.maxAcciones) {
                estado.historial.acciones.shift();
            }
            
            estado.historial.acciones.push(accionRegistro);
            estado.historial.ultimaAccion = accionRegistro;
        }
        
        // Funciones de acción de botones
        async function seleccionarPuntoInteres() {
            try {
                logger.info('Seleccionando punto de interés');
                // Actualizar estado del botón
                estado.botones.puntoInteres.estado = 'activo';
                actualizarEstadoBotones();
                
                // Aquí iría la lógica para seleccionar un punto de interés
                // Por ahora, simulamos una selección exitosa
                setTimeout(() => {
                    estado.botones.puntoInteres.estado = 'inactivo';
                    actualizarEstadoBotones();
                    mostrarMensaje('Punto de interés seleccionado', 'exito');
                }, 1000);
                
            } catch (error) {
                logger.error('Error al seleccionar punto de interés', error);
                mostrarMensaje('Error al seleccionar punto de interés', 'error');
                estado.botones.puntoInteres.estado = 'inactivo';
                actualizarEstadoBotones();
            }
        }
        
        async function toggleNavegacion() {
            try {
                if (estado.navegacion.activa) {
                    // Detener navegación
                    logger.info('Deteniendo navegación');
                    await detenerNavegacion();
                    estado.botones.gps.texto = 'Iniciar Navegación';
                    estado.botones.gps.icono = 'fa-directions';
                } else {
                    // Iniciar navegación
                    logger.info('Iniciando navegación');
                    await iniciarNavegacion();
                    estado.botones.gps.texto = 'Detener Navegación';
                    estado.botones.gps.icono = 'fa-stop';
                }
                actualizarEstadoBotones();
            } catch (error) {
                logger.error('Error al alternar navegación', error);
                mostrarMensaje('Error al alternar navegación', 'error');
            }
        }
        
        async function toggleBrujula() {
            try {
                if (estado.brujula.activa) {
                    // Desactivar brújula
                    logger.info('Desactivando brújula');
                    await detenerSeguimientoOrientacion();
                    estado.brujula.activa = false;
                    estado.botones.brujula.estado = 'inactivo';
                    estado.botones.brujula.icono = 'fa-compass';
                } else {
                    // Activar brújula
                    logger.info('Activando brújula');
                    await iniciarSeguimientoOrientacion();
                    estado.brujula.activa = true;
                    estado.botones.brujula.estado = 'activo';
                    estado.botones.brujula.icono = 'fa-compass';
                }
                actualizarEstadoBotones();
            } catch (error) {
                logger.error('Error al alternar brújula', error);
                mostrarMensaje('Error al alternar brújula', 'error');
            }
        }
        
        function mostrarAyuda() {
            logger.info('Mostrando ayuda');
            mostrarMensaje('Mostrando ayuda...', 'info');
            // Aquí iría la lógica para mostrar la ayuda
        }
        
        function repetirUltimaAccion() {
            logger.info('Repitiendo última acción');
            if (estado.historial.ultimaAccion) {
                const { tipo, datos } = estado.historial.ultimaAccion;
                manejarClicBoton(datos.botonId);
            } else {
                mostrarMensaje('No hay acciones recientes para repetir', 'info');
            }
        }
        
        // Funciones de navegación
        async function iniciarNavegacion() {
            try {
                estado.navegacion.activa = true;
                // Aquí iría la lógica para iniciar la navegación
                mostrarMensaje('Navegación iniciada', 'exito');
                return true;
            } catch (error) {
                logger.error('Error al iniciar navegación', error);
                throw error;
            }
        }
        
        // Función para detener la navegación
        async function detenerNavegacion() {
            // Guardar el estado actual antes de limpiar
            const estabaActiva = estado.navegacion.activa;
            const motivo = estado.navegacion.estado === 'error' ? 'error' : 'usuario';
            
            try {
                // Actualizar estado
                estado.navegacion.activa = false;
                estado.navegacion.estado = 'inactiva';
                
                // Detener el seguimiento de posición
                if (estado.navegacion.idSeguimiento && navigator.geolocation) {
                    navigator.geolocation.clearWatch(estado.navegacion.idSeguimiento);
                    estado.navegacion.idSeguimiento = null;
                }
                
                // Detener la orientación del dispositivo
                if (window.DeviceOrientationEvent) {
                    window.removeEventListener('deviceorientation', manejarOrientacion, true);
                }
                
                // Limpiar la línea de dirección si existe
                if (estado.navegacion.lineaDireccion) {
                    estado.navegacion.lineaDireccion.remove();
                    estado.navegacion.lineaDireccion = null;
                }
                
                // Limpiar el marcador de destino si existe
                if (estado.navegacion.marcadorDestino) {
                    estado.navegacion.marcadorDestino.remove();
                    estado.navegacion.marcadorDestino = null;
                }
                
                // Notificar al padre que la navegación se ha detenido
                if (estabaActiva) {
                    await enviarMensajeConReintento('padre', NAV_MSG.DETENIDA, {
                        datos: {
                            motivo: motivo === 'error' ? 'Error en la navegación' : 'Solicitado por el usuario',
                            ultimoPunto: estado.navegacion.ultimaParadaCompletada,
                            siguientePunto: estado.navegacion.siguienteParada,
                            precision: estado.navegacion.precisionActual
                        }
                    });
                    
                    mostrarMensaje('Navegación detenida', 'info');
                }
                
                // Reiniciar el estado de navegación
                estado.navegacion.distanciaActual = null;
                estado.navegacion.direccionDestino = null;
                estado.navegacion.siguienteParada = null;
                estado.navegacion.ultimaParadaCompletada = null;
                estado.navegacion.precisionActual = null;
                
                return true;
                
            } catch (error) {
                logger.error('Error al detener navegación:', error);
                
                // Notificar error al padre
                await enviarMensajeConReintento('padre', SISTEMA_MSG.ERROR, {
                    datos: {
                        tipo: 'error_detener_navegacion',
                        mensaje: error.message,
                        stack: error.stack
                    }
                });
                
                throw error;
            }
        }
        
        // Función para mostrar mensajes al usuario
        function mostrarMensaje(mensaje, tipo = 'info') {
            estado.ui.mensaje = mensaje;
            estado.ui.tipoMensaje = tipo;
            estado.ui.mostrarMensaje = true;
            
            // Ocultar el mensaje después del tiempo configurado
            setTimeout(() => {
                estado.ui.mostrarMensaje = false;
            }, estado.ui.tiempoMensaje);
            
            logger.info(`Mensaje [${tipo}]: ${mensaje}`);
        }
        
        // Función para verificar la compatibilidad del navegador
        function verificarCompatibilidad() {
            // Verificar si el navegador soporta la API de geolocalización
            estado.gps.soportado = 'geolocation' in navigator;
            
            // Verificar si el navegador soporta la API de orientación
            estado.brujula.soportada = 'DeviceOrientationEvent' in window;
            
            // Actualizar estado de los botones según la compatibilidad
            if (!estado.brujula.soportada) {
                estado.botones.brujula.estado = 'deshabilitado';
                estado.botones.brujula.texto = 'Brújula no soportada';
            }
            
            if (!estado.gps.soportado) {
                estado.botones.gps.estado = 'deshabilitado';
                estado.botones.gps.texto = 'GPS no soportado';
                mostrarMensaje('Tu navegador no soporta la funcionalidad de GPS', 'advertencia');
            }
            
            actualizarEstadoBotones();
        }
        
        /**
         * Muestra un medio (imagen o video) en un modal
         * @param {string} tipo - Tipo de medio a mostrar ('imagen' o 'video')
         */
        function mostrarMedioEnModal(tipo) {
            // Obtener el elemento actual
            const elementoActual = COORDENADAS_PARADAS.find(item => 
                item.id === estado.navegacion.puntoActual.id
            );
            
            if (!elementoActual) {
                actualizarStatus('No se encontró el elemento actual', 'error');
                return;
            }
            
            const mediaPath = tipo === 'imagen' 
                ? elementoActual.imagen 
                : (elementoActual.video || '');
                
            if (!mediaPath) {
                actualizarStatus(`No hay ${tipo} disponible para este elemento`, 'advertencia');
                return;
            }
            
            const modal = document.getElementById('modal-medios');
            const tituloMedio = document.getElementById('titulo-medio');
            const mediaContainer = document.querySelector('.media-container');
            
            if (!modal || !tituloMedio || !mediaContainer) {
                console.error('Elementos del modal no encontrados');
                return;
            }
            
            // Actualizar título
            tituloMedio.textContent = elementoActual.nombre || 'Elemento sin nombre';
            mediaContainer.innerHTML = '';
            
            if (tipo === 'imagen') {
                const img = document.createElement('img');
                img.src = mediaPath;
                img.alt = `Imagen de ${elementoActual.nombre || 'elemento actual'}`;
                img.style.maxWidth = '100%';
                img.style.maxHeight = '70vh';
                mediaContainer.appendChild(img);
            } else {
                const video = document.createElement('video');
                video.src = mediaPath;
                video.controls = true;
                video.autoplay = true;
                video.style.maxWidth = '100%';
                video.style.maxHeight = '70vh';
                mediaContainer.appendChild(video);
            }
            
            modal.style.display = 'flex';
        }

        /**
         * Configura los manejadores de eventos de la interfaz
         */
        function configurarEventos() {
            // Botón Punto de interés
            elementos.btnPunto.addEventListener('click', manejarClickPunto);
            
            // Configurar evento de clic en el botón de imagen
            const btnImagen = document.getElementById('btn-imagen');
            if (btnImagen) {
                btnImagen.addEventListener('click', () => mostrarMediaActual('imagen'));
            }
            
            // Configurar evento de clic en el botón de video
            const btnVideo = document.getElementById('btn-video');
            if (btnVideo) {
                btnVideo.addEventListener('click', () => mostrarMediaActual('video'));
            }
            
            // Configurar cierre del modal
            const modal = document.getElementById('modal-medios');
            const btnCerrar = document.querySelector('.cerrar');
            
            if (btnCerrar) {
                btnCerrar.addEventListener('click', () => {
                    if (modal) modal.style.display = 'none';
                    // Detener cualquier video que se esté reproduciendo
                    const videos = modal?.querySelectorAll('video');
                    videos?.forEach(video => video.pause());
                });
            }
            
            // Cerrar modal al hacer clic fuera del contenido
            window.addEventListener('click', (event) => {
                if (event.target === modal) {
                    modal.style.display = 'none';
                    // Detener cualquier video que se esté reproduciendo
                    const videos = modal.querySelectorAll('video');
                    videos.forEach(video => video.pause());
                }
            });
            
            // Los botones de mapa y brújula son enlaces directos sin manejadores
            // Botón GPS
            elementos.btnGps.addEventListener('click', manejarClickGps);
            
            // Eventos táctiles para feedback
            const botones = document.querySelectorAll('.nav-button');
            botones.forEach(boton => {
                boton.addEventListener('touchstart', (e) => {
                    if (!boton.disabled) {
                        boton.style.transform = 'scale(0.95)';
                    }
                }, { passive: true });
                
                boton.addEventListener('touchend', (e) => {
                    if (!boton.disabled) {
                        boton.style.transform = '';
                    }
                }, { passive: true });
            });
        }

        /**
         * Maneja el evento de clic en el botón de punto de interés
         * Solicita al padre el punto de interés más cercano
         * @returns {Promise<Object>} Promesa que se resuelve con la respuesta del padre
         * @throws {Error} Si ocurre un error al procesar la solicitud
         */
        async function manejarClickPunto() {
            if (!estado.controles.habilitados) return;
            
            try {
                logger.info('Seleccionando punto de interés');
                estado.botones.puntoInteres.estado = 'activo';
                actualizarEstadoBotones();
                
                // Notificar al padre que se está seleccionando un punto de interés
                await enviarMensajeConReintento('padre', NAV_MSG.SOLICITAR_DESTINO, {
                    datos: {
                        modo: estado.modo
                    }
                });
                
                // Actualizar interfaz
                actualizarEstado('Selecciona un punto de interés en el mapa', 'info');
                
            } catch (error) {
                logger.error('Error al manejar el botón de punto:', error);
                actualizarEstado('Error al seleccionar punto de interés', 'error');
                estado.botones.puntoInteres.estado = 'inactivo';
                actualizarEstadoBotones();
            }
        }

        /**
         * Maneja el evento de clic en el botón de GPS
         * Inicia o detiene la navegación según el estado actual
         * @returns {Promise<boolean>} true si la operación fue exitosa, false en caso contrario
         */
        async function manejarClickGps() {
            if (!estado.controles.habilitados) return false;
            
            try {
                estado.botones.gps.estado = 'activo';
                actualizarEstadoBotones();
                
                if (estado.navegacion.activa) {
                    // Detener navegación
                    await detenerNavegacion();
                    
                    // Notificar al padre
                    await enviarMensajeConReintento('padre', NAV_MSG.DETENER, {
                        datos: {
                            motivo: 'Solicitado por el usuario'
                        }
                    });
                    
                    actualizarEstado('Navegación detenida', 'info');
                    estado.botones.gps.texto = 'Iniciar Navegación';
                    estado.botones.gps.icono = 'fa-directions';
                } else {
                    // Iniciar navegación
                    try {
                        await iniciarNavegacion();
                        
                        // Notificar al padre
                        if (estado.navegacion.puntoDestino) {
                            await enviarMensajeConReintento('padre', NAV_MSG.INICIAR, {
                                datos: {
                                    destino: estado.navegacion.puntoDestino,
                                    modo: estado.modo
                                }
                            });
                        }
                        
                        // Notificar inicio de navegación exitoso
                        await enviarMensajeConReintento('padre', NAV_MSG.INICIADA, {
                            datos: {
                                destino: estado.navegacion.puntoDestino,
                                modo: estado.modo,
                                precision: estado.navegacion.precisionActual || 'media'
                            }
                        });
                        
                        actualizarEstado('Navegación activa', 'exito');
                        estado.botones.gps.texto = 'Detener Navegación';
                        estado.botones.gps.icono = 'fa-stop';
                    } catch (error) {
                        logger.error('Error al iniciar navegación:', error);
                        actualizarEstado('Error al iniciar navegación', 'error');
                        estado.navegacion.estado = 'inactiva';
                        estado.navegacion.activa = false;
                        
                        // Notificar error al padre
                        await enviarMensajeConReintento('padre', SISTEMA_MSG.ERROR, {
                            datos: {
                                tipo: 'error_inicio_navegacion',
                                mensaje: error.message,
                                stack: error.stack
                            }
                        });
                        
                        throw error; // Re-lanzar para que sea manejado por el catch externo
                    }
                }
                
                return true;
            } catch (error) {
                logger.error('Error al manejar el botón GPS:', error);
                actualizarEstado('Error en la navegación GPS', 'error');
                
                // Notificar error al padre
                enviarMensajeConReintento('padre', SISTEMA_MSG.ERROR, {
                    datos: {
                        tipo: 'error_inicio_navegacion',
                        mensaje: error.message,
                        stack: error.stack
                    }
                }).catch(console.error);
                
                return false;
            } finally {
                estado.botones.gps.estado = 'inactivo';
                actualizarEstadoBotones();
            }
        }

        /**
         * Maneja el clic en un punto de interés
         * @description Maneja el clic en un punto de interés y solicita al padre el punto de interés más cercano
         * @returns {Promise<Object>} Promesa que se resuelve con la respuesta del padre
         */
        async function manejarClickPunto() {
            if (!estado.controlesHabilitados) return;
            
            try {
                console.log('[MANEJADOR] Punto de interés clickeado');
                actualizarEstado('Buscando puntos de interés cercanos...', 'info');
                
                // Solicitar al padre el punto de interés más cercano
                const respuesta = await enviarMensajeConReintento('padre', NAV_MSG.SOLICITAR_DESTINO, {
                    datos: {
                        modo: estado.modo,
                        contexto: 'seleccion_usuario',
                        precisionRequerida: 'alta'
                    }
                });
                
                console.log('[MANEJADOR] Respuesta del padre:', respuesta);
                return respuesta;
                
            } catch (error) {
                console.error('[ERROR] Error al solicitar destino:', error);
                // Notificar error al padre
                await enviarMensajeConReintento('padre', SISTEMA_MSG.ERROR, {
                    datos: {
                        tipo: 'error_solicitud_destino',
                        mensaje: error.message,
                        stack: error.stack,
                        contexto: 'manejarClickPunto'
                    }
                });
                throw error; // Relanzar para manejo adicional si es necesario
            }
        }
        
        // Función para actualizar la posición del usuario
        function actualizarPosicionUsuario(posicion) {
            const { latitude: lat, longitude: lng, heading: direccion } = posicion.coords;
            const ubicacionActual = { lat, lng };
            
            // Actualizar posición en el mapa
            actualizarPosicionUsuario(lat, lng, direccion);
            
            // Actualizar el estado de los botones según la ubicación actual
            actualizarEstadoBotones(ubicacionActual);
            
            // Si no hay siguiente parada, intentar establecer la primera
            if (!estado.navegacion.siguienteParada) {
                estado.navegacion.siguienteParada = encontrarSiguienteParada(estado.navegacion.ultimaParadaCompletada?.id);
                if (estado.navegacion.siguienteParada) {
                    console.log(`Siguiente parada establecida: ${estado.navegacion.siguienteParada.nombre}`);
                    
                    // Notificar al padre sobre la nueva parada de navegación
                    enviarMensajeConReintento('padre', NAV_MSG.SIGUIENTE_PARADA_ESTABLECIDA, {
                        datos: {
                            paradaId: estado.navegacion.siguienteParada.id,
                            nombre: estado.navegacion.siguienteParada.nombre,
                            esPrimeraParada: !estado.navegacion.ultimaParadaCompletada
                        }
                    }).catch(console.error);
                }
            }
            
            // Verificar proximidad a la siguiente parada/tramo
            if (estado.navegacion.siguienteParada) {
                const puntoDestino = estado.navegacion.siguienteParada.coordenadas || 
                                   estado.navegacion.siguienteParada.inicio;
                
                if (puntoDestino) {
                    const distancia = calcularDistancia(
                        lat, lng, 
                        puntoDestino.lat, 
                        puntoDestino.lng
                    );
                    
                    estado.navegacion.distanciaActual = distancia;
                    
                    // Si estamos dentro del umbral, marcar como completado
                    if (distancia <= estado.configuracion.distanciaUmbral) {
                        marcarParadaCompletada(estado.navegacion.siguienteParada);
                    }
                    
                    // Si hay un destino activo, actualizar dirección y línea
                    if (estado.navegacion.puntoDestino) {
                        const direccionDestino = calcularDireccion(lat, lng, puntoDestino.lat, puntoDestino.lng);
                        estado.navegacion.direccionDestino = direccionDestino;
                        actualizarLineaDireccion(lat, lng, direccionDestino);
                    }
                }
            }
        }
        
        // Función para calcular la dirección hacia el destino
        function calcularDireccion(lat1, lon1, lat2, lon2) {
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
            const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
                     Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
            let brng = Math.atan2(y, x) * 180 / Math.PI;
            return (brng + 360) % 360;
        }
        
        // Función para actualizar la línea de dirección al destino
        function actualizarLineaDireccion(lat, lng, direccion) {
            if (!mapa) return;
            
            // Calcular un punto a cierta distancia en la dirección del destino
            const R = 0.0001; // Radio pequeño para la línea de dirección
            const lat2 = lat + (R * Math.cos(direccion * Math.PI / 180));
            const lng2 = lng + (R * Math.sin(direccion * Math.PI / 180));
            
            // Crear o actualizar la línea de dirección
            const puntoActual = [lat, lng];
            const puntoDireccion = [lat2, lng2];
            
            if (estado.navegacion.lineaDireccion) {
                estado.navegacion.lineaDireccion.setLatLngs([puntoActual, puntoDireccion]);
            } else {
                estado.navegacion.lineaDireccion = L.polyline([puntoActual, puntoDireccion], {
                    color: '#3388ff',
                    weight: 2,
                    opacity: 0.7,
                    dashArray: '5, 5'
                }).addTo(mapa);
            }
        }
        
        // Función para marcar una parada como completada
        function marcarParadaCompletada(parada) {
            console.log(`Parada completada: ${parada.nombre || parada.id}`);
            
            // Actualizar la última parada completada
            estado.navegacion.ultimaParadaCompletada = parada;
            
            // Encontrar la siguiente parada
            estado.navegacion.siguienteParada = encontrarSiguienteParada(parada.id);
            
            // Notificar al padre que se ha completado una parada
            if (enviarMensaje) {
                enviarMensajeConReintento('padre', NAV_MSG.LLEGADA_DETECTADA, {
                    datos: {
                        paradaId: parada.id,
                        nombre: parada.nombre
                    }
                }).catch(error => {
                    console.error('Error al notificar parada completada:', error);
                });
            }
            
            // Si no hay más paradas, notificar finalización
            if (!estado.navegacion.siguienteParada) {
                console.log('¡Ruta completada!');
                if (enviarMensaje) {
                    enviarMensajeConReintento('padre', NAV_MSG.RUTA_COMPLETADA, {
                        datos: {}
                    });
                }
            }
            
            estado.navegacion.puntoDestino = null;
        }
        
        // Función para manejar errores de geolocalización
        function manejarErrorPosicion(error) {
            console.error('Error de geolocalización:', error);
            let mensaje = 'Error de GPS';
            
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    mensaje = 'Se ha denegado el acceso a la geolocalización';
                    break;
                case error.POSITION_UNAVAILABLE:
                    mensaje = 'La información de ubicación no está disponible';
                    break;
                case error.TIMEOUT:
                    mensaje = 'Tiempo de espera de geolocalización agotado';
                    break;
            }
            
            actualizarEstado(mensaje, 'error');
        }
        
        // Función llamada cuando se alcanza un destino
        async function destinoAlcanzado() {
            // Detener la navegación
            detenerNavegacion();
        }
        
        // Función auxiliar para calcular distancia entre dos puntos en metros
        function calcularDistancia(lat1, lon1, lat2, lon2) {
            const R = 6371e3; // Radio de la Tierra en metros
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δφ = (lat2 - lat1) * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            
            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return Math.round(R * c);
        }
        
        // Función para actualizar el estado con la distancia al destino
        /**
         * Actualiza el estado de la distancia (función vacía, mantiene compatibilidad)
         * @deprecated Esta función se mantiene por compatibilidad pero no realiza ninguna acción
         */
        function actualizarEstadoDistancia() {
            // Función vacía - se ha eliminado la funcionalidad de mensajes de distancia
        }

        /**
         * Maneja el evento de clic en el botón de mapa
         * Solicita al padre que muestre el mapa
         * @returns {Promise<void>}
         */
        async function manejarClickMapa() {
            if (!estado.controlesHabilitados) return;
            
            try {
                console.log('Acción: Mostrar mapa');
                // Implementar lógica para mostrar el mapa
                await enviarMensajeConReintento('padre', NAV_MSG.MOSTRAR_MAPA, {
                    datos: {}
                });
                
            } catch (error) {
                console.error('Error al manejar el botón mapa:', error);
            }
        }

        /**
         * Maneja el evento de clic en el botón de brújula
         * Alterna el modo brújula y notifica al padre del cambio
         */
        function manejarClickBrujula() {
            if (!estado.controlesHabilitados) return;
            
            try {
                // Alternar modo brújula
                estado.modoCompass = !estado.modoCompass;
                
                // Actualizar UI
                elementos.btnCompass.classList.toggle('active', estado.modoCompass);
                
                console.log(`Modo brújula: ${estado.modoCompass ? 'activado' : 'desactivado'}`);
                
                // Notificar al padre del cambio de modo
                enviarMensajeConReintento('padre', NAV_MSG.MODO_BRUJULA, {
                    datos: {
                        activo: estado.modoCompass
                    }
                }).catch(console.error);
                
                // Iniciar/Detener seguimiento de orientación según el modo
                if (estado.modoCompass) {
                    iniciarSeguimientoOrientacion();
                } else {
                    detenerSeguimientoOrientacion();
                }
                
            } catch (error) {
                console.error('Error al manejar el botón brújula:', error);
            }
        }

        // Funciones de seguimiento de orientación
        let watchId = null;
        
        function iniciarSeguimientoOrientacion() {
            if ('DeviceOrientationEvent' in window) {
                // Verificar permisos en dispositivos iOS 13+
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                window.addEventListener('deviceorientation', manejarOrientacion, true);
                            }
                        })
                        .catch(console.error);
                } else {
                    // Navegadores que no requieren solicitud de permiso
                    window.addEventListener('deviceorientation', manejarOrientacion, true);
                }
            }
        }
        
        function detenerSeguimientoOrientacion() {
            window.removeEventListener('deviceorientation', manejarOrientacion, true);
        }
        
        /**
         * Maneja los eventos de orientación del dispositivo
         * @param {DeviceOrientationEvent} event - Evento de orientación del dispositivo
         */
        function manejarOrientacion(event) {
            if (event.alpha !== null && estado.modoCompass) {
                const alpha = event.alpha;  // Grados de rotación (0-360)
                // Enviar actualización de orientación al padre
                enviarMensajeConReintento('padre', NAV_MSG.ORIENTACION, {
                    datos: {
                        grados: alpha
                    }
                }).catch(console.error);
            }
        }

        /**
         * Maneja la configuración del sistema (tema, idioma, etc.)
         * @param {Object} mensaje - Mensaje de configuración
         * @returns {Promise<Object>} Respuesta con el estado actualizado
         */
        async function manejarConfiguracion(mensaje) {
            try {
                // Validar el mensaje usando el esquema definido
                validarMensaje(mensaje, ESQUEMAS_VALIDACION[SISTEMA_MSG.CONFIGURACION]);
                
                const { tema, idioma, opciones } = mensaje.datos;
                
                // Actualizar configuración local
                if (tema) {
                    // Aplicar tema
                    document.documentElement.setAttribute('data-tema', tema);
                    estado.configuracion.tema = tema;
                }
                
                if (idioma) {
                    // Actualizar idioma
                    estado.configuracion.idioma = idioma;
                    // Aquí iría la lógica para actualizar los textos de la interfaz
                }
                
                if (opciones) {
                    // Actualizar opciones adicionales
                    estado.configuracion.opciones = { ...estado.configuracion.opciones, ...opciones };
                }
                
                logger.info('Configuración actualizada', estado.configuracion);
                
                // Enviar confirmación al padre
                return {
                    exito: true,
                    mensaje: 'Configuración actualizada correctamente',
                    configuracion: estado.configuracion
                };
                
            } catch (error) {
                logger.error('Error al manejar configuración:', error);
                throw new Error(`Error de configuración: ${error.message}`);
            }
        }
        
        /**
         * Maneja la sincronización de estado con el padre
         * @param {Object} mensaje - Mensaje de sincronización
         * @returns {Promise<Object>} Estado actual del componente
         */
        async function manejarSincronizacion(mensaje) {
            try {
                validarMensaje(mensaje, ESQUEMAS_VALIDACION[SISTEMA_MSG.SINCRONIZAR]);
                
                // Actualizar estado local con el estado recibido si es necesario
                if (mensaje.datos && mensaje.datos.estado) {
                    // Aquí iría la lógica para actualizar el estado local
                    // con el estado recibido del padre
                    estado = { ...estado, ...mensaje.datos.estado };
                }
                
                // Devolver el estado actual del componente
                return {
                    exito: true,
                    estado: estado,
                    timestamp: Date.now()
                };
                
            } catch (error) {
                logger.error('Error en sincronización:', error);
                throw new Error(`Error de sincronización: ${error.message}`);
            }
        }
        
        /**
         * Maneja la confirmación de operaciones
         * @param {Object} mensaje - Mensaje de confirmación
         */
        async function manejarConfirmacion(mensaje) {
            try {
                validarMensaje(mensaje, ESQUEMAS_VALIDACION[SISTEMA_MSG.CONFIRMACION]);
                
                const { tipo, exito, mensaje: mensajeConfirmacion, datos } = mensaje.datos;
                
                logger.info(`Confirmación recibida - Tipo: ${tipo}, Éxito: ${exito}`, {
                    mensaje: mensajeConfirmacion,
                    datos
                });
                
                // Aquí se puede agregar lógica específica basada en el tipo de confirmación
                
            } catch (error) {
                logger.error('Error al procesar confirmación:', error);
            }
        }

        /**
         * Maneja la habilitación de controles
         * @param {Object} mensaje - Mensaje de habilitación
         */
        function manejarHabilitarControles(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: { type: 'object', optional: true }
                });
                
                estado.controlesHabilitados = true;
                console.log('Controles habilitados por:', mensaje.origen || 'origen desconocido');
                
                // Actualizar la interfaz
                document.body.classList.remove('controles-deshabilitados');
                
                // Notificar confirmación
                enviarMensajeConReintento(mensaje.origen, SISTEMA_MSG.CONFIRMACION, {
                    tipo: 'controles_habilitados',
                    estado: 'completado',
                    timestamp: new Date().toISOString()
                }).catch(console.error);
                
            } catch (error) {
                console.error('Error al habilitar controles:', error);
                notificarError('habilitar_controles', error, { origen: mensaje?.origen });
            }
        }

        /**
         * Maneja la deshabilitación de controles
         * @param {Object} mensaje - Mensaje de deshabilitación
         */
        function manejarDeshabilitarControles(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: { 
                        type: 'object',
                        properties: {
                            motivo: { type: 'string', optional: true },
                            mostrarMensaje: { type: 'boolean', optional: true }
                        }
                    }
                });
                
                const { motivo = 'No especificado', mostrarMensaje = true } = mensaje.datos || {};
                
                estado.controlesHabilitados = false;
                console.log(`Controles deshabilitados por: ${mensaje.origen} - Motivo: ${motivo}`);
                
                // Actualizar la interfaz
                document.body.classList.add('controles-deshabilitados');
                
                // Mostrar mensaje al usuario si es necesario
                if (mostrarMensaje) {
                    actualizarEstado(`Controles deshabilitados: ${motivo}`, 'advertencia');
                }
                
                // Notificar confirmación
                enviarMensajeConReintento(mensaje.origen, SISTEMA_MSG.CONFIRMACION, {
                    tipo: 'controles_deshabilitados',
                    estado: 'completado',
                    timestamp: new Date().toISOString()
                }).catch(console.error);
                
            } catch (error) {
                console.error('Error al deshabilitar controles:', error);
                notificarError('deshabilitar_controles', error, { origen: mensaje?.origen });
            }
        }

        /**
         * Maneja el cambio de parada en la navegación
         * @param {Object} mensaje - Mensaje de cambio de parada
         */
        function manejarCambioParada(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['paradaId', 'nombre'],
                        properties: {
                            paradaId: { type: 'string' },
                            nombre: { type: 'string' },
                            coordenadas: {
                                type: 'object',
                                required: ['lat', 'lng'],
                                properties: {
                                    lat: { type: 'number' },
                                    lng: { type: 'number' }
                                }
                            },
                            esFinal: { type: 'boolean', optional: true }
                        }
                    }
                });
                
                const { paradaId, nombre, coordenadas, esFinal } = mensaje.datos;
                
                // Actualizar estado de navegación
                estado.navegacion.paradaActual = { id: paradaId, nombre, coordenadas };
                
                if (esFinal) {
                    estado.navegacion.rutaCompletada = true;
                    // Notificar llegada al destino final
                    enviarMensajeConReintento('padre', NAV_MSG.LLEGADA_DETECTADA, {
                        tipo: 'destino_final',
                        paradaId,
                        nombre,
                        timestamp: new Date().toISOString()
                    }).catch(console.error);
                }
                
                // Actualizar UI
                actualizarEstado(`Próxima parada: ${nombre}`, 'info');
                
            } catch (error) {
                console.error('Error al procesar cambio de parada:', error);
                notificarError('cambio_parada', error, { origen: mensaje?.origen });
            }
        }
        
        /**
         * Maneja la solicitud de establecer un nuevo destino
         * @param {Object} mensaje - Mensaje con los datos del destino
         */
        function manejarEstablecerDestino(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['destino'],
                        properties: {
                            destino: {
                                type: 'object',
                                required: ['id', 'nombre', 'coordenadas'],
                                properties: {
                                    id: { type: 'string' },
                                    nombre: { type: 'string' },
                                    coordenadas: {
                                        type: 'object',
                                        required: ['lat', 'lng'],
                                        properties: {
                                            lat: { type: 'number' },
                                            lng: { type: 'number' }
                                        }
                                    }
                                }
                            },
                            opciones: { type: 'object', optional: true }
                        }
                    }
                });
                
                const { destino, opciones = {} } = mensaje.datos;
                
                // Actualizar estado de navegación
                estado.navegacion.destino = destino;
                estado.navegacion.rutaCompletada = false;
                
                // Iniciar navegación si no está activa
                if (!estado.navegacion.activa) {
                    iniciarNavegacion(destino, opciones);
                }
                
                // Confirmar recepción
                enviarMensajeConReintento(mensaje.origen, NAV_MSG.DESTINO_ESTABLECIDO, {
                    destinoId: destino.id,
                    nombre: destino.nombre,
                    timestamp: new Date().toISOString()
                }).catch(console.error);
                
            } catch (error) {
                console.error('Error al establecer destino:', error);
                notificarError('establecer_destino', error, { origen: mensaje?.origen });
                
                // Notificar error al remitente
                enviarMensajeConReintento(mensaje.origen, SISTEMA_MSG.ERROR, {
                    tipo: 'error_establecer_destino',
                    mensaje: error.message,
                    timestamp: new Date().toISOString()
                }).catch(console.error);
            }
        }
        
        /**
         * Maneja las actualizaciones de la interfaz de usuario
         * @param {Object} mensaje - Mensaje con las actualizaciones de UI
         */
        function manejarActualizacionUI(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: { type: 'object', required: true }
                });
                
                const { accion, parametros = {} } = mensaje.datos;
                
                switch (accion) {
                    case 'mostrar_mensaje':
                        const { texto, tipo = 'info', duracion } = parametros;
                        mostrarMensaje(texto, tipo, duracion);
                        break;
                        
                    case 'actualizar_estado':
                        actualizarEstado(parametros.texto, parametros.tipo);
                        break;
                        
                    case 'alternar_modo_compass':
                        if (typeof parametros.activo === 'boolean') {
                            estado.modoCompass = parametros.activo;
                            // Actualizar UI según el modo
                            document.querySelectorAll('.compass-control')
                                .forEach(el => el.classList.toggle('activo', estado.modoCompass));
                        }
                        break;
                        
                    default:
                        console.warn('Acción de UI no reconocida:', accion);
                }
                
            } catch (error) {
                console.error('Error al actualizar la interfaz:', error);
                notificarError('actualizacion_ui', error, { origen: mensaje?.origen });
            }
        }
        
        /**
         * Maneja las actualizaciones de GPS
         * @param {Object} mensaje - Mensaje con datos de GPS
         * @returns {Promise<Object>} Estado actualizado de la navegación
         */
        async function manejarActualizacionGPS(mensaje) {
            try {
                // Validar el mensaje usando el esquema definido
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['coordenadas'],
                        properties: {
                            coordenadas: {
                                type: 'object',
                                required: ['lat', 'lng'],
                                properties: {
                                    lat: { type: 'number' },
                                    lng: { type: 'number' },
                                    precision: { type: 'number', optional: true },
                                    altitud: { type: 'number', optional: true },
                                    rumbo: { type: 'number', optional: true },
                                    velocidad: { type: 'number', optional: true }
                                }
                            },
                            precision: { type: 'number', optional: true },
                            altitud: { type: 'number', optional: true },
                            rumbo: { type: 'number', optional: true },
                            velocidad: { type: 'number', optional: true },
                            timestamp: { type: 'number', optional: true }
                        }
                    }
                });
                
                const { coordenadas, precision, altitud, rumbo, velocidad, timestamp } = mensaje.datos;
                const { lat, lng } = coordenadas;
                
                // Actualizar estado de ubicación
                estado.ubicacion = {
                    lat,
                    lng,
                    precision: precision || 0,
                    altitud: altitud || null,
                    velocidad: velocidad || 0,
                    rumbo: rumbo || null,
                    ultimaActualizacion: timestamp || Date.now()
                };
                
                // Si hay navegación activa, actualizar la ruta y la orientación
                if (estado.navegacion.activa && estado.navegacion.destino) {
                    // Calcular distancia al destino
                    const distancia = calcularDistancia(
                        lat,
                        lng,
                        estado.navegacion.destino.coordenadas.lat,
                        estado.navegacion.destino.coordenadas.lng
                    );
                    
                    // Actualizar estado de navegación
                    estado.navegacion.distanciaAlDestino = distancia;
                    estado.navegacion.ubicacionActual = { lat, lng };
                    
                    // Calcular dirección al destino
                    const direccion = calcularDireccionHaciaDestino(
                        { lat, lng },
                        estado.navegacion.destino.coordenadas
                    );
                    
                    // Actualizar dirección en el estado de navegación
                    estado.navegacion.direccionAlDestino = direccion;
                    
                    // Si estamos en modo brújula, actualizar la orientación
                    if (estado.modoCompass) {
                        // Disparar evento de actualización de dirección
                        const eventoDireccion = new CustomEvent('actualizarDireccion', {
                            detail: { direccion, precision: precision || 0 }
                        });
                        window.dispatchEvent(eventoDireccion);
                    }
                    
                    // Verificar si hemos llegado al destino (10 metros por defecto)
                    if (distancia < (estado.navegacion.radioLlegada || 10)) {
                        await manejarLlegadaDestino(estado.navegacion.destino);
                    }
                }
                
                // Notificar a los suscriptores de actualización de ubicación
                const evento = new CustomEvent('actualizacionUbicacion', {
                    detail: { ...estado.ubicacion }
                });
                window.dispatchEvent(evento);
                
                return {
                    exito: true,
                    mensaje: 'Ubicación actualizada correctamente',
                    ubicacion: estado.ubicacion
                };
                
            } catch (error) {
                const errorMsg = 'Error al actualizar la ubicación GPS';
                logger.error(errorMsg, error);
                
                // Notificar error al padre
                enviarMensajeConReintento('padre', TIPOS_MENSAJE.SISTEMA.ERROR, {
                    tipo: 'error_actualizacion_gps',
                    mensaje: error.message,
                    timestamp: Date.now()
                }).catch(console.error);
                
                throw new Error(`${errorMsg}: ${error.message}`);
            }
        }

        /**
         * Maneja el cambio de modo (casa/aventura) - Implementación mejorada
         * @param {Object} mensaje - Mensaje de cambio de modo
         * @returns {Promise<Object>} - Resultado de la operación
         */
        async function manejarCambioModo(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['modo'],
                        properties: {
                            modo: { type: 'string', enum: ['casa', 'aventura'] },
                            motivo: { type: 'string', optional: true },
                            forzar: { type: 'boolean', optional: true }
                        }
                    }
                });

                const { modo, motivo = 'sin motivo especificado', forzar = false } = mensaje.datos;
                const modoAnterior = estado.modo.actual;
                
                // Verificar si ya está en el modo solicitado
                if (!forzar && modo === modoAnterior) {
                    logger.info(`[MODO] Ya está en modo ${modo}, ignorando solicitud`);
                    return {
                        exito: true,
                        modo,
                        estado: 'ya_estaba_en_modo',
                        timestamp: new Date().toISOString()
                    };
                }

                logger.info(`[MODO] Cambiando a modo: ${modo} (${motivo})`);

                // Actualizar la interfaz
                await actualizarInterfazModo(modo);

                // Actualizar el estado
                estado.modo.anterior = modoAnterior;
                estado.modo.actual = modo;
                estado.modo.ultimoCambio = new Date().toISOString();

                // Preparar confirmación
                const confirmacion = {
                    exito: true,
                    modo,
                    modoAnterior,
                    origen: CONFIG.ID_APLICACION,
                    timestamp: new Date().toISOString(),
                    detalles: `Modo cambiado a ${modo} correctamente`
                };

                // Enviar confirmación al padre
                if (typeof enviarMensaje === 'function') {
                    await enviarMensajeConReintento('padre', TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO_CONFIRMACION, confirmacion);
                    
                    // Difundir el nuevo estado a todos los componentes
                    await enviarMensajeConReintento('todos', TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO_ESTADO, {
                        modo,
                        modoAnterior,
                        origen: CONFIG.ID_APLICACION,
                        timestamp: new Date().toISOString()
                    });
                }

                logger.info(`[MODO] Cambio a modo ${modo} completado`);
                return confirmacion;
                
            } catch (error) {
                const errorMsg = `Error al cambiar el modo: ${error.message}`;
                logger.error(errorMsg, error);
                
                // Notificar error al padre
                if (typeof enviarMensaje === 'function') {
                    await enviarMensajeConReintento('padre', TIPOS_MENSAJE.SISTEMA.ERROR, {
                        tipo: 'cambio_modo_fallido',
                        mensaje: error.message,
                        stack: error.stack,
                        origen: CONFIG.ID_APLICACION,
                        timestamp: new Date().toISOString(),
                        datos: {
                            modo: mensaje.datos?.modo || 'desconocido',
                            modoAnterior: estado.modo.actual,
                            error: error.message
                        }
                    }).catch(e => logger.error('Error al notificar error de cambio de modo:', e));
                }
                
                throw error;
            }
        }

        /**
         * Actualiza la interfaz según el modo especificado
         * @param {'casa'|'aventura'} modo - El modo al que cambiar
         */
        async function actualizarInterfazModo(modo) {
            logger.info(`[MODO] Actualizando interfaz a modo: ${modo}`);
            
            // Actualizar clases CSS
            document.body.classList.remove('modo-casa', 'modo-aventura');
            document.body.classList.add(`modo-${modo}`);
            
            // Mostrar/ocultar elementos según el modo
            const elementosModo = document.querySelectorAll('[data-modo]');
            elementosModo.forEach(elemento => {
                const modosElemento = (elemento.getAttribute('data-modo') || '').split(' ');
                elemento.style.display = modosElemento.includes(modo) ? '' : 'none';
            });

            // Lógica específica de cada modo
            if (modo === 'casa') {
                logger.info('[MODO] Inicializando interfaz de casa');
                // Lógica específica para modo casa
            } else if (modo === 'aventura') {
                logger.info('[MODO] Inicializando interfaz de aventura');
                // Lógica específica para modo aventura
            }
        }

        /**
         * Maneja la sincronización del estado de modo
         * @param {Object} mensaje - Mensaje de estado de modo
         */
        function manejarEstadoModo(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['modo'],
                        properties: {
                            modo: { type: 'string', enum: ['casa', 'aventura'] },
                            modoAnterior: { type: 'string', optional: true }
                        }
                    }
                });

                const { modo, modoAnterior } = mensaje.datos;
                
                // Ignorar si el mensaje es de este componente o el modo no ha cambiado
                if (mensaje.origen === CONFIG.ID_APLICACION || modo === estado.modo.actual) {
                    return;
                }

                logger.info(`[MODO] Sincronizando estado de modo a: ${modo}`);
                return manejarCambioModo({
                    origen: mensaje.origen,
                    timestamp: mensaje.timestamp,
                    datos: { 
                        modo, 
                        motivo: 'sincronizacion_estado',
                        forzar: true // Forzar actualización incluso si el modo es el mismo
                    }
                });
            } catch (error) {
                logger.error('Error al manejar estado de modo:', error);
            }
        }

        /**
         * Maneja la confirmación de cambio de modo
         * @param {Object} mensaje - Mensaje de confirmación
         */
        function manejarConfirmacionCambioModo(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['exito', 'modo'],
                        properties: {
                            exito: { type: 'boolean' },
                            modo: { type: 'string', enum: ['casa', 'aventura'] },
                            modoAnterior: { type: 'string', enum: ['casa', 'aventura'], optional: true },
                            timestamp: { type: 'string', format: 'date-time' },
                            detalles: { type: 'string', optional: true }
                        }
                    }
                });

                const { exito, modo, modoAnterior, detalles } = mensaje.datos;
                
                if (exito) {
                    logger.info(`[MODO] Cambio de modo confirmado: ${modoAnterior || 'ninguno'} → ${modo}` + 
                               (detalles ? ` (${detalles})` : ''));
                    
                    // Actualizar estado si es necesario
                    if (estado.modo.actual !== modo) {
                        estado.modo.anterior = estado.modo.actual;
                        estado.modo.actual = modo;
                        estado.modo.ultimoCambio = new Date().toISOString();
                        
                        // Actualizar la interfaz si el mensaje es de otro componente
                        if (mensaje.origen !== CONFIG.ID_APLICACION) {
                            actualizarInterfazModo(modo).catch(error => 
                                logger.error('Error al actualizar interfaz de modo:', error)
                            );
                        }
                    }
                } else {
                    logger.warn(`[MODO] Fallo en el cambio de modo a ${modo}`);
                }
            } catch (error) {
                logger.error('Error al procesar confirmación de cambio de modo:', error);
                // No relanzar para no interrumpir el flujo
            }
        }

        /**
         * Maneja la notificación de inicialización completada
         * @param {Object} mensaje - Mensaje de inicialización completada
         * @returns {Object} - Respuesta de confirmación
         */
        async function manejarInicializacionCompletada(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['version'],
                        properties: {
                            version: { type: 'string' },
                            estado: { type: 'object', optional: true }
                        }
                    }
                });

                const { version, estado: estadoRemoto } = mensaje.datos;
                logger.info(`Componente ${mensaje.origen} inicializado (v${version})`);

                // Sincronizar estado si se proporciona
                if (estadoRemoto) {
                    Object.assign(estado, estadoRemoto);
                }

                return {
                    exito: true,
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    estado: {
                        modo: estado.modo.actual,
                        navegacion: estado.navegacion.activa
                    }
                };
                
            } catch (error) {
                logger.error('Error al procesar inicialización completada:', error);
                return {
                    exito: false,
                    error: error.message,
                    timestamp: new Date().toISOString()
                };
            }
        }

        /**
         * Maneja la solicitud de inicio de navegación
         * @param {Object} mensaje - Mensaje de inicio de navegación
         * @returns {Promise<Object>} - Resultado de la operación
         */
        async function manejarIniciarNavegacion(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['destino'],
                        properties: {
                            destino: { type: 'object' },
                            opciones: { type: 'object', optional: true }
                        }
                    }
                });

                const { destino, opciones = {} } = mensaje.datos;
                
                // Validar destino
                if (!destino.lat || !destino.lng) {
                    throw new Error('El destino debe contener coordenadas válidas (lat, lng)');
                }

                // Actualizar estado de navegación
                estado.navegacion = {
                    activa: true,
                    destino,
                    estado: 'iniciando',
                    opciones,
                    timestamp: new Date().toISOString()
                };

                // Iniciar navegación
                await iniciarNavegacionHacia(destino, opciones);

                // Notificar que la navegación ha comenzado
                await enviarMensajeConReintento('padre', NAV_MSG.INICIADA, {
                    destino,
                    timestamp: new Date().toISOString(),
                    estado: 'en_progreso'
                });

                return { exito: true, estado: 'navegacion_iniciada' };
                
            } catch (error) {
                const errorMsg = 'Error al iniciar navegación';
                logger.error(errorMsg, error);
                
                // Notificar error
                if (mensaje?.origen) {
                    await enviarMensajeConReintento(mensaje.origen, SISTEMA_MSG.ERROR, {
                        tipo: 'inicio_navegacion',
                        mensaje: error.message,
                        timestamp: new Date().toISOString()
                    });
                }
                
                // Actualizar estado
                if (estado.navegacion) {
                    estado.navegacion.estado = 'error';
                    estado.navegacion.error = error.message;
                }
                
                throw error;
            }
        }

        /**
         * Maneja la confirmación de navegación iniciada
         * @param {Object} mensaje - Mensaje de navegación iniciada
         */
        function manejarNavegacionIniciada(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['destino', 'estado'],
                        properties: {
                            destino: { type: 'object' },
                            estado: { type: 'string', enum: ['en_progreso', 'error'] },
                            mensaje: { type: 'string', optional: true },
                            timestamp: { type: 'string', format: 'date-time' }
                        }
                    }
                });

                const { destino, estado: estadoNavegacion, mensaje: mensajeEstado } = mensaje.datos;
                
                // Actualizar estado local
                if (estadoNavegacion === 'en_progreso') {
                    estado.navegacion.activa = true;
                    estado.navegacion.estado = 'en_progreso';
                    logger.info(`Navegación iniciada hacia destino: ${JSON.stringify(destino)}`);
                    
                    // Actualizar UI
                    actualizarEstado('Navegación en curso', 'info');
                } else {
                    estado.navegacion.estado = 'error';
                    estado.navegacion.error = mensajeEstado || 'Error desconocido';
                    logger.warn(`Error al iniciar navegación: ${mensajeEstado}`);
                }
                
            } catch (error) {
                logger.error('Error al procesar confirmación de navegación:', error);
            }
        }

        /**
         * Maneja la cancelación de navegación
         * @param {Object} mensaje - Mensaje de cancelación de navegación
         */
        async function manejarNavegacionCancelada(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        properties: {
                            motivo: { type: 'string', optional: true },
                            forzar: { type: 'boolean', optional: true }
                        }
                    }
                });

                const { motivo = 'Solicitado por el usuario', forzar = false } = mensaje.datos || {};
                
                // Verificar si hay navegación activa
                if (!estado.navegacion.activa && !forzar) {
                    logger.info('No hay navegación activa para cancelar');
                    return { exito: true, mensaje: 'No hay navegación activa' };
                }

                // Detener navegación
                await detenerNavegacion();

                // Actualizar estado
                estado.navegacion = {
                    activa: false,
                    estado: 'cancelada',
                    motivo,
                    timestamp: new Date().toISOString()
                };

                // Notificar confirmación
                await enviarMensajeConReintento('padre', NAV_MSG.ESTADO, {
                    estado: 'cancelada',
                    motivo,
                    timestamp: new Date().toISOString()
                });

                // Actualizar UI
                actualizarEstado(`Navegación cancelada: ${motivo}`, 'advertencia');
                
                return { exito: true, estado: 'navegacion_cancelada' };
                
            } catch (error) {
                const errorMsg = 'Error al cancelar navegación';
                logger.error(errorMsg, error);
                
                // Notificar error
                if (mensaje?.origen) {
                    await enviarMensajeConReintento(mensaje.origen, SISTEMA_MSG.ERROR, {
                        tipo: 'cancelacion_navegacion',
                        mensaje: error.message,
                        timestamp: new Date().toISOString()
                    });
                }
                
                throw error;
            }
        }

        /**
         * Maneja las actualizaciones de estado de navegación
         * @param {Object} mensaje - Mensaje de estado de navegación
         */
        function manejarEstadoNavegacion(mensaje) {
            try {
                validarMensaje(mensaje, {
                    origen: { type: 'string', required: true },
                    timestamp: { type: 'string', required: true },
                    datos: {
                        type: 'object',
                        required: ['estado'],
                        properties: {
                            estado: { type: 'string' },
                            progreso: { type: 'number', optional: true, minimum: 0, maximum: 100 },
                            tiempoRestante: { type: 'number', optional: true },
                            distanciaRestante: { type: 'number', optional: true },
                            proximaInstruccion: { type: 'string', optional: true },
                            timestamp: { type: 'string', format: 'date-time' }
                        }
                    }
                });

                const { estado: estadoNavegacion, ...detalles } = mensaje.datos;
                
                // Actualizar estado de navegación
                estado.navegacion.estado = estadoNavegacion;
                estado.navegacion.ultimaActualizacion = new Date().toISOString();
                
                // Actualizar detalles adicionales
                Object.assign(estado.navegacion, detalles);
                
                // Actualizar UI según el estado
                switch (estadoNavegacion) {
                    case 'en_ruta':
                        actualizarEstado('En ruta al destino', 'info');
                        break;
                    case 'cercano_destino':
                        actualizarEstado('Cerca del destino', 'info');
                        break;
                    case 'llegada_inminente':
                        actualizarEstado('Llegada inminente', 'exito');
                        break;
                    case 'llegada':
                        actualizarEstado('¡Has llegado a tu destino!', 'exito');
                        break;
                    case 'desviado':
                        actualizarEstado('Ruta recalculando...', 'advertencia');
                        break;
                    case 'error':
                        actualizarEstado('Error en la navegación', 'error');
                        break;
                }
                
                // Log detallado en modo depuración
                logger.debug('Estado de navegación actualizado:', estado.navegacion);
                
            } catch (error) {
                logger.error('Error al procesar actualización de estado de navegación:', error);
            }
        }

        /**
         * Registra los manejadores de mensajes para la comunicación con el padre
         * Los manejadores se encargan de procesar los mensajes entrantes según su tipo
         * Manejo de mensajes
         */
        function registrarManejadoresMensajes() {
            // Controladores de mensajes del sistema
            registrarControlador(SISTEMA_MSG.CONFIGURACION, manejarConfiguracion);
            registrarControlador(SISTEMA_MSG.SINCRONIZAR, manejarSincronizacion);
            registrarControlador(SISTEMA_MSG.CONFIRMACION, manejarConfirmacion);
            
            // Controladores de modo mejorados
            registrarControlador(SISTEMA_MSG.CAMBIO_MODO, manejarCambioModo);
            registrarControlador(SISTEMA_MSG.CAMBIO_MODO_CONFIRMACION, manejarConfirmacionCambioModo);
            registrarControlador(SISTEMA_MSG.CAMBIO_MODO_ESTADO, manejarEstadoModo);
            
            registrarControlador(SISTEMA_MSG.INICIALIZACION_COMPLETADA, manejarInicializacionCompletada);
            
            // Controladores de navegación
            registrarControlador(NAV_MSG.INICIAR, manejarIniciarNavegacion);
            registrarControlador(NAV_MSG.INICIADA, manejarNavegacionIniciada);
            registrarControlador(NAV_MSG.CANCELADA, manejarNavegacionCancelada);
            registrarControlador(NAV_MSG.ESTADO, manejarEstadoNavegacion);
            registrarControlador(NAV_MSG.CAMBIO_PARADA, manejarCambioParada);
            registrarControlador(NAV_MSG.ESTABLECER_DESTINO, manejarEstablecerDestino);
            
            // Interfaz de usuario
            registrarControlador('UI.ACTUALIZAR', manejarActualizacionUI);
            registrarControlador('UI.HABILITAR_CONTROLES', manejarHabilitarControles);
            registrarControlador('UI.DESHABILITAR_CONTROLES', manejarDeshabilitarControles);
            
            // GPS
            registrarControlador('GPS.ACTUALIZAR', manejarActualizacionGPS);
            registrarControlador('GPS.COMANDO', manejarComandoGPS);
            
            // Control (mantener compatibilidad)
            registrarControlador(TIPOS_MENSAJE.CONTROL.HABILITAR, manejarHabilitarControles);
            registrarControlador(TIPOS_MENSAJE.CONTROL.DESHABILITAR, manejarDeshabilitarControles);
            
            // Confirmaciones
            registrarControlador(SISTEMA_MSG.CONFIRMACION, manejarConfirmacion);
            
            // Feedback visual cuando los controles están deshabilitados
            document.body.classList.toggle('controles-deshabilitados', !estado.controlesHabilitados);
            
            // Otros manejadores según sea necesario
        }

        // Actualizar estado de conexión
        function actualizarEstadoConexion(conectado) {
            if (elementos.statusIndicator) {
                elementos.statusIndicator.classList.toggle('active', conectado);
                elementos.statusIndicator.style.backgroundColor = conectado ? '#2ecc71' : '#e74c3c';
            }
        }

        // Función para inicializar la aplicación
        function inicializarAplicacion() {
            // Inicializar cuando el DOM esté listo
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', inicializar);
            } else {
                inicializar();
            }
            
            // Manejar eventos de visibilidad
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden && estado.modoCompass) {
                    // Reanudar seguimiento de orientación si está activo
                    iniciarSeguimientoOrientacion();
                }
            });

            // Limpieza al cerrar
            window.addEventListener('beforeunload', () => {
                detenerSeguimientoOrientacion();
            });

        }

        // Inicializar la aplicación cuando se carga el script
        document.addEventListener('DOMContentLoaded', inicializarAplicacion);
    </script>
    
    <!-- Exportar variables al ámbito global -->
    <script>
        // Exportar las variables necesarias al ámbito global
        window.TIPOS_MENSAJE = window.TIPOS_MENSAJE || TIPOS_MENSAJE;
        window.NAV_MSG = window.NAV_MSG || NAV_MSG;
        window.SISTEMA_MSG = window.SISTEMA_MSG || SISTEMA_MSG;
        window.enviarMensaje = window.enviarMensaje || enviarMensaje;
        window.registrarControlador = window.registrarControlador || registrarControlador;
    </script>
</body>
</html>
