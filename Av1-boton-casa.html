<!DOCTYPE html>
<html lang="es">
<head>
    <script type="module">
      // ================== CONFIGURACIÓN ==================
      const CONFIG = {
        IFRAME_ID: 'hijo5-casa',
        LOG_LEVEL: 2, // 0: debug, 1: info, 2: warn, 3: error, 4: none
        DEBUG: true,
        REINTENTOS: {
          MAXIMOS: 3,
          TIEMPO_ESPERA: 1000,
          FACTOR: 2
        },
        ESTADO_INICIAL: {
          modo: 'casa',
          controlesHabilitados: true,
          puntoActual: null,
          gpsActivo: false,
          tramoActual: null,
          ultimoError: null
        }
      };

      // Tipos de mensajes específicos de este componente
      let TIPOS_MENSAJE = {
        // Valores por defecto en caso de que falle la importación
        SISTEMA: {
          INICIALIZACION: 'sistema:inicializacion',
          CAMBIO_MODO: 'sistema:cambio_modo',
          CONFIRMACION: 'sistema:confirmacion',
          ACTUALIZAR_ESTADO: 'sistema:actualizar_estado',
          SOLICITAR_ESTADO: 'sistema:solicitar_estado',
          LISTO: 'sistema:listo'
        },
        // Mensajes específicos del componente
        CAMBIO_PUNTO: 'hijo5:cambio_punto',
        ACTUALIZAR_ESTADO: 'hijo5:actualizar_estado',
        NOTIFICAR_PUNTO: 'hijo5:notificar_punto'
      };
      
      // Intentar importar las constantes de mensajería
      (async () => {
        try {
          const mod = await import('./mensajeria.js');
          if (mod && mod.TIPOS_MENSAJE) {
            TIPOS_MENSAJE = { ...TIPOS_MENSAJE, ...mod.TIPOS_MENSAJE };
            console.log(`[${CONFIG.IFRAME_ID}] Constantes de mensajería actualizadas:`, TIPOS_MENSAJE);
          }
        } catch (e) {
          console.warn('[hijo5] No se pudieron cargar las constantes de mensajería, usando valores por defecto', e);
        }
      })();

      /**
       * Inicializa la mensajería y registra los manejadores de mensajes
       * @returns {Promise<boolean>} True si la inicialización fue exitosa
       */
      async function inicializarMensajeria() {
        try {
            // Usar la configuración global
            
            console.log(`[${CONFIG.IFRAME_ID}] Cargando módulo de mensajería...`);
            
            try {
                const { 
                    Mensajeria, 
                    TIPOS_MENSAJE, 
                    inicializarMensajeria, 
                    enviarMensaje, 
                    registrarControlador 
                } = await import('./mensajeria.js');
                
                // Store in window for backward compatibility (to be removed later)
                window.Mensajeria = { 
                    Mensajeria, 
                    TIPOS_MENSAJE, 
                    inicializarMensajeria, 
                    enviarMensaje, 
                    registrarControlador 
                };
                
                console.log(`[${CONFIG.IFRAME_ID}] Módulo de mensajería cargado correctamente`);
                return { 
                    Mensajeria, 
                    TIPOS_MENSAJE, 
                    inicializarMensajeria, 
                    enviarMensaje, 
                    registrarControlador 
                };
            } catch (importError) {
                console.error(`[${CONFIG.IFRAME_ID}] Error al cargar el módulo de mensajería:`, importError);
                throw new Error(`Error al cargar el módulo de mensajería: ${importError.message}`);
            }
            
            if (!window.Mensajeria) {
                throw new Error('El módulo de mensajería se cargó pero es undefined');
            }
            
            if (typeof window.Mensajeria.inicializarMensajeria !== 'function') {
                console.error('Métodos disponibles en Mensajeria:', Object.keys(window.Mensajeria).join(', '));
                throw new Error('La función inicializarMensajeria no está disponible en el módulo');
            }
            
            // Configurar la mensajería
            console.log(`[${CONFIG.IFRAME_ID}] Inicializando mensajería con configuración:`, {
                iframeId: CONFIG.IFRAME_ID,
                logLevel: CONFIG.LOG_LEVEL,
                debug: CONFIG.DEBUG,
                reintentos: {
                max: CONFIG.REINTENTOS.MAXIMOS,
                delay: CONFIG.REINTENTOS.TIEMPO_ESPERA,
                factor: CONFIG.REINTENTOS.FACTOR
                }
            });

            try {
                await window.Mensajeria.inicializarMensajeria({
                iframeId: CONFIG.IFRAME_ID,
                logLevel: CONFIG.LOG_LEVEL,
                debug: CONFIG.DEBUG,
                reintentos: {
                    max: CONFIG.REINTENTOS.MAXIMOS,
                    delay: CONFIG.REINTENTOS.TIEMPO_ESPERA,
                    factor: CONFIG.REINTENTOS.FACTOR
                }
                });
                console.log(`[${CONFIG.IFRAME_ID}] Mensajería inicializada correctamente`);
            } catch (initError) {
                console.error(`[${CONFIG.IFRAME_ID}] Error al inicializar la mensajería:`, initError);
                throw new Error(`Error al inicializar la mensajería: ${initError.message}`);
            }
            
            // Asegurarse de que las funciones globales estén disponibles
            if (window.Mensajeria) {
                // Hacer que las funciones estén disponibles globalmente
                window.enableControls = window.Mensajeria.enableControls || function() {
                console.warn('enableControls no está disponible en Mensajeria');
                return Promise.resolve(false);
                };
                
                window.disableControls = window.Mensajeria.disableControls || function() {
                console.warn('disableControls no está disponible en Mensajeria');
                return Promise.resolve(false);
                };
            }
            
            try {
                // Registrar manejadores de mensajes
                console.log(`[${CONFIG.IFRAME_ID}] Registrando manejadores de mensajes...`);
                await registrarManejadores();
                
                // Notificar al padre que estamos listos
                console.log(`[${CONFIG.IFRAME_ID}] Notificando al padre...`);
                await notificarEstado('inicializado');
                
                console.log(`[${CONFIG.IFRAME_ID}] Inicialización completada exitosamente`);
                return true;
            } catch (handlerError) {
                console.error(`[${CONFIG.IFRAME_ID}] Error al registrar manejadores:`, handlerError);
                throw new Error(`Error al registrar manejadores: ${handlerError.message}`);
            }
            
        } catch (error) {
            const errorMsg = `Error al inicializar la mensajería: ${error.message}`;
            console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
            mostrarError(errorMsg);
            return false;
        }
      }
      
      /**
       * Registra los manejadores de mensajes para este componente
       * @returns {Promise<void>}
       */
      async function registrarManejadores() {
        if (!window.Mensajeria) {
          throw new Error('Mensajería no disponible para registrar manejadores');
        }
        
        try {
          // Registrar manejadores de mensajes del sistema
          const manejadoresSistema = [
            { tipo: TIPOS_MENSAJE.SISTEMA.INICIALIZACION, manejador: manejarInicializacion },
            { tipo: TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO, manejador: manejarCambioModo },
            { tipo: TIPOS_MENSAJE.SISTEMA.CONFIRMACION, manejador: manejarConfirmacion },
            { tipo: TIPOS_MENSAJE.SISTEMA.ACTUALIZAR_ESTADO, manejador: manejarActualizacionEstado },
            { tipo: TIPOS_MENSAJE.SISTEMA.SOLICITAR_ESTADO, manejador: manejarSolicitudEstado }
          ];
          
          // Registrar todos los manejadores
          for (const { tipo, manejador } of manejadoresSistema) {
            if (typeof manejador === 'function') {
              window.Mensajeria.registrarControlador(tipo, manejador);
              console.log(`[${CONFIG.IFRAME_ID}] Manejador registrado para: ${tipo}`);
            }
          }
          
          console.log(`[${CONFIG.IFRAME_ID}] Todos los manejadores de mensajes registrados`);
          return true;
          
        } catch (error) {
          console.error(`[${CONFIG.IFRAME_ID}] Error al registrar manejadores:`, error);
          throw error; // Relanzar para que el llamador pueda manejarlo
        }
      }
      
      /**
       * Notifica el estado actual al iframe padre
       * @param {string} accion - Acción que generó el cambio de estado
       * @param {Object} [datosAdicionales={}] - Datos adicionales a incluir en la notificación
       * @returns {Promise<boolean>} True si la notificación se envió correctamente
       */
      async function notificarEstado(accion, datosAdicionales = {}) {
        if (!window.Mensajeria) {
          console.warn(`[${CONFIG.IFRAME_ID}] Mensajería no disponible para notificar estado`);
          return false;
        }
        
        const timestamp = new Date().toISOString();
        const mensaje = {
          tipo: TIPOS_MENSAJE.SISTEMA.ACTUALIZAR_ESTADO,
          origen: CONFIG.IFRAME_ID,
          accion,
          datos: {
            ...datosAdicionales,
            timestamp,
            modo: estadoApp.modo,
            gpsActivo: estadoApp.gpsActivo,
            controlesHabilitados: estadoApp.controlesHabilitados,
            puntoActual: estadoApp.puntoActual,
            tramoActual: estadoApp.tramoActual
          }
        };
        
        try {
          // Usar el sistema de mensajería con reintentos
          await window.Mensajeria.enviarMensaje(
            'padre',
            TIPOS_MENSAJE.SISTEMA.ACTUALIZAR_ESTADO,
            mensaje.datos,
            { 
              maxRetries: CONFIG.REINTENTOS.MAXIMOS,
              retryDelay: CONFIG.REINTENTOS.TIEMPO_ESPERA
            }
          );
          
          console.log(`[${CONFIG.IFRAME_ID}] Estado notificado: ${accion}`, mensaje.datos);
          return true;
          
        } catch (error) {
          const errorMsg = `Error al notificar estado (${accion}): ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          mostrarError(errorMsg);
          return false;
        }
      }
      
      // Manejador de inicialización
      async function manejarInicializacion(mensaje) {
        console.log(`[${CONFIG.IFRAME_ID}] Inicialización solicitada:`, mensaje);
        
        try {
          // Actualizar el estado con los datos recibidos
          if (mensaje.datos) {
            const { modo, controlesHabilitados, puntoActual, gpsActivo, tramoActual } = mensaje.datos;
            
            if (modo) estadoApp.modo = modo;
            if (typeof controlesHabilitados === 'boolean') {
              estadoApp.controlesHabilitados = controlesHabilitados;
            }
            if (puntoActual) estadoApp.puntoActual = puntoActual;
            if (typeof gpsActivo === 'boolean') estadoApp.gpsActivo = gpsActivo;
            if (tramoActual !== undefined) estadoApp.tramoActual = tramoActual;
          }
          
          // Actualizar la interfaz de usuario según el estado actual
          actualizarInterfaz();
          
          // Notificar que la inicialización fue exitosa
          await notificarEstado('inicializado');
          return true;
          
        } catch (error) {
          const errorMsg = `Error en inicialización: ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          mostrarError(errorMsg);
          return false;
        }
      }
      
      /**
       * Maneja las actualizaciones de estado recibidas
       * @param {Object} mensaje - Mensaje con la actualización de estado
       * @returns {Promise<boolean>} True si la actualización se procesó correctamente
       */
      async function manejarActualizacionEstado(mensaje) {
        console.log(`[${CONFIG.IFRAME_ID}] Actualización de estado recibida:`, mensaje);
        
        try {
          if (!mensaje.datos) {
            throw new Error('Datos de actualización no proporcionados');
          }
          
          const { 
            modo, 
            gpsActivo, 
            controlesHabilitados, 
            puntoActual, 
            tramoActual,
            motivo = 'actualizacion_estado'
          } = mensaje.datos;
          
          // Actualizar el estado según los datos recibidos
          let cambios = [];
          
          if (modo && estadoApp.modo !== modo) {
            estadoApp.modo = modo;
            cambios.push(`modo: ${modo}`);
          }
          
          if (typeof gpsActivo === 'boolean' && estadoApp.gpsActivo !== gpsActivo) {
            estadoApp.gpsActivo = gpsActivo;
            cambios.push(`gpsActivo: ${gpsActivo}`);
          }
          
          if (typeof controlesHabilitados === 'boolean' && 
              estadoApp.controlesHabilitados !== controlesHabilitados) {
            estadoApp.controlesHabilitados = controlesHabilitados;
            cambios.push(`controles: ${controlesHabilitados ? 'habilitados' : 'deshabilitados'}`);
          }
          
          if (puntoActual !== undefined && JSON.stringify(estadoApp.puntoActual) !== JSON.stringify(puntoActual)) {
            estadoApp.puntoActual = puntoActual;
            cambios.push('punto actual actualizado');
          }
          
          if (tramoActual !== undefined && estadoApp.tramoActual !== tramoActual) {
            estadoApp.tramoActual = tramoActual;
            cambios.push(`tramo actual: ${tramoActual}`);
          }
          
          // Si hubo cambios, actualizar la interfaz
          if (cambios.length > 0) {
            console.log(`[${CONFIG.IFRAME_ID}] Estado actualizado: ${cambios.join(', ')}`);
            actualizarInterfaz();
          }
          
          return true;
          
        } catch (error) {
          const errorMsg = `Error al actualizar estado: ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          mostrarError(errorMsg);
          return false;
        }
      }
      
      // Manejador de cambio de modo
      async function manejarCambioModo(mensaje = {}) {
        console.log('[hijo5] Recibido mensaje de cambio de modo:', mensaje);
        
        try {
          // Manejar diferentes formatos de mensaje
          const datos = mensaje.datos || {};
          const nuevoModo = datos.modo || datos.nuevoModo || 'casa';
          const motivo = datos.motivo || 'desconocido';
          const forzar = datos.forzar || false;
          
          if (!nuevoModo) {
            throw new Error('No se especificó el modo en el mensaje');
          }
          
          // Validar el modo
          if (nuevoModo !== 'casa' && nuevoModo !== 'aventura') {
            throw new Error(`Modo no válido: ${nuevoModo}`);
          }
          
          const modoAnterior = estadoApp.modo;
          if (modoAnterior === nuevoModo && !forzar) {
            console.log(`[hijo5] Ya se encuentra en modo ${nuevoModo}, ignorando cambio`);
            return { exito: true, mensaje: 'Ya está en el modo solicitado' };
          }
          
          console.log(`[hijo5] Cambiando de modo: ${modoAnterior} -> ${nuevoModo}`);
          estadoApp.modo = nuevoModo;
          
          // 1. Actualizar el estado
          // 2. Ajustes específicos según el modo
          if (nuevoModo === 'casa') {
            // Desactivar GPS al cambiar a modo casa
            estadoApp.gpsActivo = false;
            console.log(`[${CONFIG.IFRAME_ID}] GPS desactivado al cambiar a modo casa`);
          }
          
          // 3. Actualizar la interfaz
          actualizarInterfaz();
          
          // 4. Notificar el cambio si es necesario
          // Notificar al padre del cambio exitoso
          if (window.Mensajeria) {
            try {
              await window.Mensajeria.enviarMensaje(
                'padre',
                TIPOS_MENSAJE.SISTEMA.CONFIRMACION,
                {
                  tipo: 'cambio_modo',
                  id: mensaje.id || Date.now().toString(),
                  exito: true,
                  datos: {
                    modoAnterior,
                    modoNuevo: nuevoModo,
                    motivo,
                    timestamp: new Date().toISOString()
                  }
                },
                { 
                  maxRetries: 3,
                  retryDelay: 1000,
                  timeout: 5000
                }
              );
              console.log(`[${CONFIG.IFRAME_ID}] Confirmación de cambio de modo enviada al padre`);
            } catch (error) {
              console.error('[hijo5] Error al enviar confirmación al padre:', error);
              // Continuar a pesar del error de confirmación
            }
          } else {
            console.warn(`[${CONFIG.IFRAME_ID}] No se pudo enviar confirmación: Mensajería no disponible`);
          }
          
          console.log(`[${CONFIG.IFRAME_ID}] Modo cambiado exitosamente a ${nuevoModo}`);
          return true;
          
        } catch (error) {
          const errorMsg = `Error al cambiar el modo: ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          
          // Notificar el error
          try {
            await notificarEstado('error_cambio_modo', {
              error: error.message,
              motivo: mensaje.datos?.motivo || 'desconocido',
              modoAnterior: estadoApp.modo,
              modoIntentado: mensaje.datos?.modo
            });
          } catch (notifyError) {
            console.error(`[${CONFIG.IFRAME_ID}] Error al notificar error de cambio de modo:`, notifyError);
          }
          
          return false;
        }
      }
      
      /**
       * Maneja las solicitudes de estado de la aplicación
       * @param {Object} mensaje - Mensaje de solicitud de estado
       * @param {string} [mensaje.datos.solicitud] - Tipo de información solicitada
       * @param {string} [mensaje.datos.idSolicitud] - ID opcional para seguimiento
       * @returns {Promise<boolean>} True si se manejó la solicitud correctamente
       */
      async function manejarSolicitudEstado(mensaje = {}) {
        const { solicitud = 'completo', idSolicitud } = mensaje.datos || {};
        const idMensaje = idSolicitud || `solicitud_${Date.now()}`;
        
        console.log(`[${CONFIG.IFRAME_ID}] Solicitud de estado recibida (${solicitud})`, { 
          idSolicitud: idMensaje,
          origen: mensaje.origen 
        });
        
        try {
          // Preparar la respuesta según el tipo de solicitud
          let datosRespuesta = {
            idSolicitud: idMensaje,
            timestamp: new Date().toISOString(),
            origen: CONFIG.IFRAME_ID,
            estado: {
              modo: estadoApp.modo,
              gpsActivo: estadoApp.gpsActivo,
              controlesHabilitados: estadoApp.controlesHabilitados,
              puntoActual: estadoApp.puntoActual,
              tramoActual: estadoApp.tramoActual,
              ultimoError: estadoApp.ultimoError,
              version: '1.0.0' // Versión del formato de respuesta
            }
          };
          
          // Filtrar respuesta según lo solicitado
          if (solicitud !== 'completo') {
            if (solicitud === 'basico') {
              // Solo información básica
              datosRespuesta.estado = {
                modo: estadoApp.modo,
                gpsActivo: estadoApp.gpsActivo,
                controlesHabilitados: estadoApp.controlesHabilitados
              };
            } else if (solicitud === 'punto_actual' && estadoApp.puntoActual) {
              // Solo información del punto actual
              datosRespuesta.estado = {
                puntoActual: estadoApp.puntoActual,
                tramoActual: estadoApp.tramoActual
              };
            }
          }
          
          // Enviar la respuesta
          if (window.Mensajeria) {
            await window.Mensajeria.enviarMensaje(
              mensaje.origen || 'padre',
              'respuesta_estado',
              datosRespuesta,
              { 
                maxRetries: CONFIG.REINTENTOS.MAXIMOS,
                retryDelay: CONFIG.REINTENTOS.TIEMPO_ESPERA
              }
            );
            
            console.log(`[${CONFIG.IFRAME_ID}] Estado enviado (${solicitud})`, { 
              idSolicitud: idMensaje,
              destino: mensaje.origen || 'padre'
            });
          } else {
            console.warn(`[${CONFIG.IFRAME_ID}] No se pudo enviar el estado: Mensajería no disponible`);
            return false;
          }
          
          return true;
          
        } catch (error) {
          const errorMsg = `Error al procesar solicitud de estado (${solicitud}): ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          
          // Intentar notificar el error
          try {
            if (window.Mensajeria) {
              await window.Mensajeria.enviarMensaje(
                mensaje.origen || 'padre',
                'error_solicitud_estado',
                {
                  idSolicitud: idMensaje,
                  error: error.message,
                  timestamp: new Date().toISOString()
                },
                { maxRetries: 1 } // Solo un intento para errores
              );
            }
          } catch (notifyError) {
            console.error(`[${CONFIG.IFRAME_ID}] Error al notificar error de estado:`, notifyError);
          }
          
          return false;
        }
      }
      
      /**
       * Maneja las confirmaciones de operaciones enviadas previamente
       * @param {Object} mensaje - Mensaje de confirmación
       * @param {string} mensaje.tipo - Tipo de operación confirmada
       * @param {string} mensaje.id - ID único de la operación
       * @param {boolean} mensaje.exito - Indica si la operación fue exitosa
       * @param {Object} [mensaje.datos] - Datos adicionales de la confirmación
       * @param {string} [mensaje.mensaje] - Mensaje descriptivo
       * @returns {Promise<boolean>} True si se manejó la confirmación correctamente
       */
      async function manejarConfirmacion(mensaje = {}) {
        const { tipo, id, exito, datos = {}, mensaje: mensajeTexto } = mensaje.datos || {};
        const idOperacion = id || 'desconocido';
        
        // Log detallado de la confirmación
        console.log(`[${CONFIG.IFRAME_ID}] Confirmación recibida`, {
          tipo: tipo || 'sin_tipo',
          id: idOperacion,
          exito: exito === true,
          origen: mensaje.origen || 'desconocido',
          timestamp: new Date().toISOString()
        });
        
        try {
          // Manejar la confirmación según el tipo de operación
          if (exito) {
            // Operación exitosa
            console.log(`[${CONFIG.IFRAME_ID}] Operación '${tipo}' (${idOperacion}) confirmada con éxito`);
            
            // Aquí podrías agregar lógica específica para cada tipo de operación
            switch (tipo) {
              case 'cambio_modo':
                console.log(`[${CONFIG.IFRAME_ID}] Modo cambiado exitosamente a: ${datos.modoNuevo}`);
                break;
                
              case 'actualizacion_estado':
                // Actualizar el estado local si es necesario
                if (datos.estado) {
                  console.log(`[${CONFIG.IFRAME_ID}] Estado sincronizado:`, datos.estado);
                }
                break;
                
              default:
                // No se requiere acción específica para otros tipos
                break;
            }
            
            // Notificar a la interfaz de usuario si es necesario
            actualizarInterfaz();
            
          } else {
            // Operación fallida
            const errorMsg = datos?.error || mensajeTexto || 'Error desconocido';
            console.error(`[${CONFIG.IFRAME_ID}] Error en operación '${tipo}' (${idOperacion}):`, errorMsg);
            
            // Mostrar notificación de error al usuario
            mostrarError(`Error en ${tipo || 'operación'}: ${errorMsg}`);
            
            // Revertir cambios si es necesario según el tipo de operación
            switch (tipo) {
              case 'cambio_modo':
                // Revertir al modo anterior si el cambio falló
                if (datos.modoAnterior) {
                  console.warn(`[${CONFIG.IFRAME_ID}] Revertiendo a modo anterior: ${datos.modoAnterior}`);
                  estadoApp.modo = datos.modoAnterior;
                  actualizarInterfaz();
                }
                break;
                
              // Agregar más casos según sea necesario
            }
            
            // Registrar el error en el estado
            estadoApp.ultimoError = {
              tipo,
              id: idOperacion,
              mensaje: errorMsg,
              timestamp: new Date().toISOString(),
              datos
            };
          }
          
          return true;
          
        } catch (error) {
          // Manejar errores en el procesamiento de la confirmación
          console.error(`[${CONFIG.IFRAME_ID}] Error al procesar confirmación:`, error);
          
          // Notificar el error sin reintentos para evitar bucles
          try {
            if (window.Mensajeria) {
              await window.Mensajeria.enviarMensaje(
                mensaje.origen || 'padre',
                'error_procesamiento_confirmacion',
                {
                  idConfirmacion: idOperacion,
                  tipo,
                  error: error.message,
                  timestamp: new Date().toISOString()
                },
                { maxRetries: 1 } // Solo un intento para errores
              );
            }
          } catch (notifyError) {
            console.error(`[${CONFIG.IFRAME_ID}] Error al notificar error de confirmación:`, notifyError);
          }
          
          return false;
        }
      }
      
      // Función para notificar errores
      async function notificarError(tipo, error) {
        console.error(`[${CONFIG.IFRAME_ID}] Error (${tipo}):`, error);
        
        if (window.Mensajeria) {
          try {
            await window.Mensajeria.enviarMensaje(
              'padre',
              'error',
              {
                tipo,
                mensaje: error.message,
                stack: error.stack,
                timestamp: Date.now(),
                origen: CONFIG.IFRAME_ID
              },
              CONFIG.REINTENTOS
            );
          } catch (e) {
            console.error(`[${CONFIG.IFRAME_ID}] Error al notificar error:`, e);
          }
        }
      }
      
      // Sincronizar estado con el padre
      async function sincronizarEstado(estado) {
        if (!estado) return;
        
        console.log(`[${CONFIG.IFRAME_ID}] Sincronizando estado:`, estado);
        
        // Actualizar estado local
        if (estado.modo) {
          estadoApp.modo = estado.modo;
        }
        
        if (typeof estado.controlesHabilitados !== 'undefined') {
          estadoApp.controlesHabilitados = estado.controlesHabilitados;
        }
        
        if (estado.puntoActual) {
          estadoApp.puntoActual = estado.puntoActual;
        }
        
        // Aplicar cambios en la interfaz
        actualizarInterfaz();
      }
      
      // La función actualizarInterfaz ha sido movida más abajo para mantener todo el código relacionado junto
      
      // Incluir aquí las funciones existentes como actualizarBotonGPS, etc.
      // ...
      
      // Función para mostrar errores en la interfaz
      function mostrarError(mensaje) {
        // Implementar lógica para mostrar errores al usuario
        console.error(mensaje);
        
        // Mostrar mensaje de error en la interfaz si es necesario
        const errorContainer = document.getElementById('error-container');
        if (errorContainer) {
          errorContainer.textContent = mensaje;
          errorContainer.style.display = 'block';
          
          // Ocultar después de 5 segundos
          setTimeout(() => {
            errorContainer.style.display = 'none';
          }, 5000);
        }
      }
      
      // Función para habilitar controles
      async function habilitarControles(modo) {
        console.log(`[${CONFIG.IFRAME_ID}] Habilitando controles para modo: ${modo}`);
        estadoApp.controlesHabilitados = true;
        
        // Aquí iría la lógica para habilitar controles específicos
        const gpsBtn = document.getElementById('gps-casa-btn');
        if (gpsBtn) {
          gpsBtn.disabled = false;
        }
        
        return true;
      }
      
      // Función para deshabilitar controles
      async function deshabilitarControles(razon) {
        console.log(`[${CONFIG.IFRAME_ID}] Deshabilitando controles. Razón: ${razon}`);
        estadoApp.controlesHabilitados = false;
        
        // Aquí iría la lógica para deshabilitar controles específicos
        const gpsBtn = document.getElementById('gps-casa-btn');
        if (gpsBtn) {
          gpsBtn.disabled = true;
        }
        
        return true;
      }
      
      /**
       * Actualiza la interfaz de usuario según el estado actual de la aplicación
       * @returns {void}
       */
      function actualizarInterfaz() {
        try {
          const { modo, gpsActivo, controlesHabilitados, puntoActual, tramoActual } = estadoApp;
          
          // 1. Actualizar el botón GPS
          const gpsBtn = document.getElementById('gps-casa-btn');
          if (gpsBtn) {
            // Actualizar clases según el modo
            gpsBtn.classList.toggle('modo-casa', modo === 'casa');
            gpsBtn.classList.toggle('modo-aventura', modo === 'aventura');
            
            // Actualizar estado activo/inactivo
            gpsBtn.classList.toggle('activo', gpsActivo);
            gpsBtn.title = gpsActivo ? 'GPS Activado' : 'GPS Desactivado';
            
            // Actualizar estado habilitado/deshabilitado
            gpsBtn.disabled = !controlesHabilitados;
          }
          
          // 2. Actualizar indicadores de estado
          const actualizarIndicador = (id, texto, clase = '') => {
            const elemento = document.getElementById(id);
            if (elemento) {
              if (texto !== undefined) elemento.textContent = texto;
              if (clase) elemento.className = clase;
            }
          };
          
          // Indicador de modo
          actualizarIndicador(
            'indicador-modo',
            `Modo: ${modo || 'no definido'}`,
            `modo-indicador modo-${modo || 'desconocido'}`
          );
          
          // Indicador de GPS
          actualizarIndicador(
            'estado-gps',
            `GPS: ${gpsActivo ? 'Activo' : 'Inactivo'}`,
            `estado-gps ${gpsActivo ? 'activo' : 'inactivo'}`
          );
          
          // Indicador de punto/tramo actual
          if (puntoActual) {
            const esParada = puntoActual.tipo === 'parada' || puntoActual.parada !== undefined;
            const textoPunto = esParada 
              ? `Parada: ${puntoActual.nombre || puntoActual.id || 'Desconocida'}`
              : `Tramo: ${puntoActual.nombre || puntoActual.id || 'Desconocido'}`;
            
            actualizarIndicador('punto-actual', textoPunto, 'punto-actual');
          } else {
            actualizarIndicador('punto-actual', 'Ningún punto seleccionado', 'punto-actual');
          }
          
          // 3. Actualizar clases del body para estilos contextuales
          document.body.classList.toggle('controles-deshabilitados', !controlesHabilitados);
          document.body.classList.toggle('gps-activo', gpsActivo);
          document.body.classList.toggle(`modo-${modo}`, !!modo);
          
          // 4. Actualizar controles interactivos
          const controles = document.querySelectorAll('button, .control-interactivo');
          controles.forEach(control => {
            // No modificar controles marcados como siempre habilitados
            if (control.hasAttribute('data-siempre-habilitado')) return;
            
            // Actualizar estado habilitado/deshabilitado
            control.disabled = !controlesHabilitados;
            control.classList.toggle('deshabilitado', !controlesHabilitados);
          });
          
          console.log(`[${CONFIG.IFRAME_ID}] Interfaz actualizada`, {
            modo,
            gpsActivo,
            controlesHabilitados,
            puntoActual: puntoActual ? puntoActual.id || puntoActual.nombre : 'ninguno'
          });
          
        } catch (error) {
          console.error(`[${CONFIG.IFRAME_ID}] Error al actualizar la interfaz:`, error);
        }
      }
      
      // Inicializar la aplicación cuando el DOM esté listo
      document.addEventListener('DOMContentLoaded', () => {
        try {
          console.log('[hijo5-casa] Iniciando inicialización...');
          window.CONFIG = window.CONFIG || { IFRAME_ID: 'hijo5-casa' };
          window.estadoApp = window.estadoApp || {
            gpsActivo: false,
            modo: 'casa',
            controlesHabilitados: true,
            puntoActual: null,
            tramoActual: null,
            ultimoError: null
          };
          cargarEstado();
          const gpsBtn = document.getElementById('gps-casa-btn');
          if (gpsBtn) {
            const newBtn = gpsBtn.cloneNode(true);
            gpsBtn.parentNode.replaceChild(newBtn, gpsBtn);
            console.log(`[${CONFIG.IFRAME_ID}] Aplicación inicializada correctamente`);
            const gpsBtn = document.getElementById('gps-casa-btn');
            if (gpsBtn) {
              gpsBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                const nuevoModo = estadoApp.modo === 'casa' ? 'aventura' : 'casa';
                await manejarCambioModo({
                  datos: { modo: nuevoModo, motivo: 'click_usuario' }
                });
              });
            }
            actualizarInterfaz();
          }
        } catch (error) {
          console.error(`[${CONFIG.IFRAME_ID}] Error en la inicialización:`, error);
          mostrarError('Error al inicializar la aplicación. Por favor, recarga la página.');
        }
      });
      
      // Array completo de paradas y tramos con padreid añadido
      const puntosRuta = [
        { padreid: "padre-P-0", tipo: "inicio", parada: 0, nombre: "Torres de Serranos (start)" },
        { padreid: "padre-TR-1", tipo: "tramo", tramo: 1, nombre: "Torres de Serranos → Plaza de la crida (Puente de Serranos)" },
        { padreid: "padre-P-1", tipo: "parada", parada: 1, nombre: "Plaza de la crida (Puente de Serranos)" },
        { padreid: "padre-TR-2", tipo: "tramo", tramo: 2, nombre: "Plaza de la crida → Calle Muro de Santa Ana" },
        { padreid: "padre-P-2", tipo: "parada", parada: 2, nombre: "Calle Muro de Santa Ana" },
        { padreid: "padre-TR-3", tipo: "tramo", tramo: 3, nombre: "Calle Muro de Santa Ana → Palacio de los Borgia" },
        { padreid: "padre-P-3", tipo: "parada", parada: 3, nombre: "Iglesia de San Lorenzo" },
        { padreid: "padre-TR-4", tipo: "tramo", tramo: 4, nombre: "Iglesia de San Lorenzo → Plaza de la Virgen" },
        { padreid: "padre-P-4", tipo: "parada", parada: 4, nombre: "Plaza de la Virgen Reto 6" },
        { padreid: "padre-P-5", tipo: "parada", parada: 5, nombre: "Plaza de la Virgen Reto 7" },
        { padreid: "padre-TR-5", tipo: "tramo", tramo: 5, nombre: "Plaza de la Virgen → Plaza de la Almoína" },
        { padreid: "padre-P-6", tipo: "parada", parada: 6, nombre: "Panel cerámico muro Catedral" },
        { padreid: "padre-P-7", tipo: "parada", parada: 7, nombre: "Capilla exterior catedral Reto 10" },
        { padreid: "padre-P-8", tipo: "parada", parada: 8, nombre: "Capilla exterior catedral Reto 11" },
        { padreid: "padre-P-9", tipo: "parada", parada: 9, nombre: "Arco Novo Catedral y Puerta Negra Basílica" },
        { padreid: "padre-P-10", tipo: "parada", parada: 10, nombre: "Casa del Punt de Gantxo" },
        { padreid: "padre-TR-6", tipo: "tramo", tramo: 6, nombre: "Plaza de la Almoína → Plaza Decimo Junio Bruto (Museo Arqueológico de la Almoína)" },
        { padreid: "padre-P-11", tipo: "parada", parada: 11, nombre: "Museo arqueológico La Almoína" },
        { padreid: "padre-P-12", tipo: "parada", parada: 12, nombre: "Museo arqueológico La Almoína" },
        { padreid: "padre-P-13", tipo: "parada", parada: 13, nombre: "Vista de la Catedral, Cimborrio" },
        { padreid: "padre-TR-7", tipo: "tramo", tramo: 7, nombre: "Museo arqueológico La Almoína → Palacio Arzobispal" },
        { padreid: "padre-P-14", tipo: "parada", parada: 14, nombre: "Palacio Arzobispal y Puerta Románica de la Catedral" },
        { padreid: "padre-P-15", tipo: "parada", parada: 15, nombre: "Puerta Románica de la Catedral" },
        { padreid: "padre-TR-8", tipo: "tramo", tramo: 8, nombre: "Puerta Románica de la Catedral → Plaza del Ayuntamiento" },
        { padreid: "padre-P-16", tipo: "parada", parada: 16, nombre: "Plaza del Ayuntamiento" },
        { padreid: "padre-TR-9", tipo: "tramo", tramo: 9, nombre: "Plaza del Ayuntamiento → Edificio del Ayuntamiento de València" },
        { padreid: "padre-P-17", tipo: "parada", parada: 17, nombre: "Edificio del Ayuntamiento" },
        { padreid: "padre-P-18", tipo: "parada", parada: 18, nombre: "Edificio del Ayuntamiento" },
        { padreid: "padre-TR-10", tipo: "tramo", tramo: 10, nombre: "Edificio del Ayuntamiento → Estación del Norte" },
        { padreid: "padre-P-19", tipo: "parada", parada: 19, nombre: "Estación del Norte" },
        { padreid: "padre-TR-11", tipo: "tramo", tramo: 11, nombre: "Estación del Norte → Plaza de Toros de València" },
        { padreid: "padre-TR-12", tipo: "tramo", tramo: 12, nombre: "Plaza de Toros → Casa estilo Árabe" },
        { padreid: "padre-P-20", tipo: "parada", parada: 20, nombre: "Casa estilo Árabe" },
        { padreid: "padre-P-21", tipo: "parada", parada: 21, nombre: "Casa estilo Árabe, mitad Aventura" },
        { padreid: "padre-TR-13", tipo: "tramo", tramo: 13, nombre: "Casa estilo Árabe → Palacio de Comunicaciones (Correos)" },
        { padreid: "padre-P-22", tipo: "parada", parada: 22, nombre: "Palacio de Comunicaciones: Correos" },
        { padreid: "padre-P-23", tipo: "parada", parada: 23, nombre: "Edificio Suay" },
        { padreid: "padre-TR-14", tipo: "tramo", tramo: 14, nombre: "Palacio de Comunicaciones → Banco de València" },
        { padreid: "padre-P-24", tipo: "parada", parada: 24, nombre: "Banco de Valencia" },
        { padreid: "padre-TR-15", tipo: "tramo", tramo: 15, nombre: "Banco de València → Palacio del Marqués de Dos Aguas (Museo Nacional de Cerámica)" },
        { padreid: "padre-P-25", tipo: "parada", parada: 25, nombre: "Palacio del Marqués de Dos Aguas (Museo Nacional de Cerámica)" },
        { padreid: "padre-TR-16", tipo: "tramo", tramo: 16, nombre: "Palacio del Marqués → Mercado Central" },
        { padreid: "padre-P-26", tipo: "parada", parada: 26, nombre: "Mercado central" },
        { padreid: "padre-TR-17", tipo: "tramo", tramo: 17, nombre: "Mercado Central → Lonja de la Seda" },
        { padreid: "padre-P-27", tipo: "parada", parada: 27, nombre: "Lonja de la Seda" },
        { padreid: "padre-TR-18", tipo: "tramo", tramo: 18, nombre: "Lonja de la Seda → Plaza Redonda" },
        { padreid: "padre-P-28", tipo: "parada", parada: 28, nombre: "Plaza Redonda" },
        { padreid: "padre-TR-19", tipo: "tramo", tramo: 19, nombre: "Plaza Redonda → Iglesia de los Santos Juanes" },
        { padreid: "padre-P-29", tipo: "parada", parada: 29, nombre: "Iglesia de los Santos Juanes" },
        { padreid: "padre-TR-20", tipo: "tramo", tramo: 20, nombre: "Iglesia de los Santos Juanes → Mercado Central" },
        { padreid: "padre-TR-21", tipo: "tramo", tramo: 21, nombre: "Mercado Central → Palacio de la Generalitat" },
        { padreid: "padre-P-30", tipo: "parada", parada: 30, nombre: "Palau de la Generalitat" },
        { padreid: "padre-TR-22", tipo: "tramo", tramo: 22, nombre: "Palacio de la Generalitat → Torres de Serranos (Final)" },
        { padreid: "padre-P-31", tipo: "parada", parada: 31, nombre: "Torres de Serranos (Final)" }
      ];

      // ...existing code...
    </script>
    <style>
    /* Contenedor principal */
    #zona-boton-casa {
      position: relative;
      width: 100%;
      height: 60px;
    }
    
    /* Botón GPS: medidas y estilos del primer código */
    #gps-casa-btn {
      position: absolute;
      top: 5px;
      left: 5px;
      width: 50px;
      height: 50px;
      min-width: 50px;
      min-height: 50px;
      border-radius: 4px;
      border: 1px solid #fff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      padding: 0;
      margin: 0 0 0 10px;
      position: relative;
      z-index: 10002;
      cursor: pointer;
      font-size: 16px;
      /* Estado inicial (OFF) */
      background-color: #f44336;
      border-color: #d32f2f;
    }
    
    /* Estado ON - Verde */
    #gps-casa-btn.on {
      background-color: #4CAF50 !important;
      border-color: #45a049 !important;
    }
    
    /* Estado OFF - Rojo */
    #gps-casa-btn.off {
      background-color: #f44336 !important;
      border-color: #d32f2f !important;
    }
    #gps-casa-btn:hover {
      opacity: 0.9;
      transform: scale(1.05);
    }
    #gps-casa-btn:active {
      transform: scale(0.95);
    }
    .button-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      line-height: 1;
    }
    .satellite-emoji {
      font-size: 35px;
      line-height: 1;
      margin-bottom: 2px;
      display: block;
    }
    .gps-label {
      font-size: 20px;
      font-weight: bold;
      line-height: 1;
      margin: 0;
      padding: 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    /* Ventana de paradas: estética y medidas del segundo código */
    #paradas-window {
      position: absolute;
      top: 0;
      left: 75px; 
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      display: none; /* Se controla desde JavaScript */
      padding: 0;
      border: 1px solid #e0e0e0;
      max-width: 300px;
      min-width: 250px;
      z-index: 10003;
      height: 60px; /* Altura total: 50px botón + 10px margen inferior */
      overflow: visible;
      padding-bottom: 1px; /* 1px de espacio debajo de la barra */
      /* Asegurar que no haya transiciones que interfieran */
      transition: none !important;
      /* Asegurar que no haya estilos en línea que sobrescriban */
      opacity: 1 !important;
      visibility: visible !important;
    }
    /* Clase para mostrar/ocultar la ventana */
    #paradas-window.visible {
      display: flex !important;
    }
    #paradas-window.hidden {
      display: none !important;
    }
    #paradas-list {
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      padding: 8px 12px;
      margin: 0;
      overflow-x: auto;
      overflow-y: hidden;
      height: 100%;
      box-sizing: border-box;
      align-items: center;
      white-space: nowrap;
      -webkit-overflow-scrolling: touch;
      gap: 8px;
      scrollbar-width: thin;
      scrollbar-color: #888 #f1f1f1;
      align-content: center;
    }
    
    /* Estilo para la barra de desplazamiento en WebKit (Chrome, Safari) */
    #paradas-list::-webkit-scrollbar {
      height: 5px;
    }
    
    #paradas-list::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    #paradas-list::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 3px;
    }
    
    #paradas-list::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    
    /* Hide scrollbar for Webkit browsers */
    #paradas-list::-webkit-scrollbar {
      display: none;
    }
    .parada-tramo-btn {
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 4px 8px;
      margin: 0 2px;
      cursor: pointer;
      font-size: 14px;
      display: inline-block;
      height: 50px;
      white-space: nowrap;
      width: auto;
      min-width: max-content;
    }
    
    .btn-content {
      display: inline-block;
      white-space: nowrap;
    }
    
    .btn-icon {
      margin-right: 4px;
    }
    .parada-btn {
      background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
      color: white;
      min-width: max-content;
      padding: 4px 8px;
      border: none !important;
    }
    .tramo-btn {
      background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%);
      color: white;
      border: none !important;
    }
    .inicio-btn {
      background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
      color: white;
      border: none !important;
    }
    .parada-tramo-btn.actual {
      border: 2px solid #ffd700 !important;
      box-shadow: 0 0 0 2px #ffd700, 0 0 15px rgba(255, 215, 0, 0.7) !important;
      transform: scale(1.05);
      font-weight: bold;
      z-index: 2;
      position: relative;
    }
    .btn-icon {
      font-size: 1.5em;
      flex-shrink: 0;
    }
    .btn-title {
      font-weight: 600;
      white-space: nowrap;
      font-size: 0.95em;
      margin-bottom: 2px;
    }
    .btn-desc {
      font-size: 0.85em;
      opacity: 0.9;
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      max-width: 130px;
      font-weight: 500;
      line-height: 1.2;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2; /* Standard property */
      -webkit-box-orient: vertical;
      text-align: left;
      position: relative;
    }
    
    /* Fallback for Firefox */
    @supports (-moz-appearance: none) {
      .btn-desc {
        display: -moz-box;
        -moz-box-orient: vertical;
      }
    }
    
    /* Estilos para la ventana de paradas */
    #paradas-window {
      position: absolute;
      top: 0;
      left: 60px; /* Alinear con el borde derecho del botón */
      width: 300px; /* Ancho fijo para la ventana */
      background: white;
      border: 1px solid #ddd;
      border-radius: 0 4px 4px 0;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      max-height: 400px;
      overflow-y: auto;
      display: none; /* Inicialmente oculto */
    }
    
    #paradas-list {
      padding: 10px;
    }
    
    /* Asegurar que el contenedor principal tenga posición relativa */
    #zona-boton-casa {
      position: relative;
      display: inline-block;
    }
    
    .parada-tramo-btn {
      display: block;
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      text-align: left;
      border: 1px solid #eee;
      border-radius: 4px;
      background-color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .parada-tramo-btn:hover {
      background-color: #f5f5f5;
    }
    
    .parada-btn {
      border-left: 4px solid #4CAF50;
    }
    
    .tramo-btn {
      border-left: 4px solid #2196F3;
    }
    
    .inicio-btn {
      border-left: 4px solid #FF9800;
    }
    
    .actual {
      font-weight: bold;
      background-color: #e3f2fd;
    }
    
    .badge {
      float: right;
      background-color: #4CAF50;
      color: white;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 0.8em;
    }
  </style>
</head>
<body>
  <div id="zona-boton-casa">
    <button id="gps-casa-btn" class="on" title="Activar GPS">
      <div class="button-content">
        <span class="satellite-emoji">📡</span>
        <span class="gps-label">ON</span>
      </div>
    </button>
    <div id="paradas-container" class="paradas-container">
      <!-- Las paradas y tramos se agregarán aquí dinámicamente -->
    </div>
    <div id="paradas-window">
      <div id="paradas-list"></div>
    </div>
  </div>
</body>
</html>
