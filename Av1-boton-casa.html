<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hijo5-casa</title>
    <script type="module">
      // Importar módulos necesarios
      import { 
        TIPOS_MENSAJE, 
        inicializarMensajeria, 
        enviarMensaje, 
        registrarControlador
      } from './mensajeria.js';
      
      // Initialize notificarError if not already defined
      if (typeof window.notificarError === 'undefined') {
          window.notificarError = function(tipo, error, datosAdicionales = {}) {
              const errorObj = error instanceof Error ? error : new Error(String(error));
              const errorInfo = {
                  tipo,
                  mensaje: errorObj.message,
                  stack: errorObj.stack,
                  ...datosAdicionales,
                  timestamp: new Date().toISOString()
              };
              console.error(`[BotonCasa] Error (${tipo}):`, errorInfo);
              return errorInfo;
          };
      }
      
      // Hacer las constantes disponibles globalmente
      window.TIPOS_MENSAJE = TIPOS_MENSAJE;
      window.Mensajeria = {
        inicializarMensajeria: withErrorHandling(inicializarMensajeria, 'boton-casa:inicializar'),
        enviarMensaje: withErrorHandling(enviarMensaje, 'boton-casa:enviar'),
        registrarControlador,
        TIPOS_MENSAJE
      };
      
      // Hacer notificarError disponible globalmente
      window.notificarError = notificarError;

      // ================== CONFIGURACIÓN ESTÁNDAR ==================
      // ================== CONSTANTES ==================
      
      // Niveles de log
      const LOG_LEVELS = {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        NONE: 4
      };
      
      // Utilidad de logging estandarizada
      const logger = (() => {
        // Función interna para el registro de logs
        const log = (nivel, nivelTexto, mensaje, datos) => {
          // Si el nivel de log está deshabilitado o es inferior al nivel configurado, no hacer nada
          if (CONFIG.LOG_LEVEL > nivel) return;
          
          const timestamp = new Date().toISOString();
          const prefijo = `[${timestamp}] [${CONFIG.IFRAME_ID}] [${nivelTexto}]`;
          
          // Determinar el método de consola a utilizar
          let metodoConsola = 'log';
          if (nivel === LOG_LEVELS.WARN) metodoConsola = 'warn';
          else if (nivel >= LOG_LEVELS.ERROR) metodoConsola = 'error';
          
          // Registrar el mensaje
          if (datos !== undefined) {
            console[metodoConsola](`${prefijo} ${mensaje}`, datos);
          } else {
            console[metodoConsola](`${prefijo} ${mensaje}`);
          }
        };
        
        return {
          /**
           * Registra un mensaje de depuración
           * @param {string} mensaje - Mensaje a registrar
           * @param {*} [datos] - Datos adicionales a registrar
           */
          debug: (mensaje, datos) => {
            log(LOG_LEVELS.DEBUG, 'DEBUG', mensaje, datos);
          },
          
          /**
           * Registra un mensaje informativo
           * @param {string} mensaje - Mensaje a registrar
           * @param {*} [datos] - Datos adicionales a registrar
           */
          info: (mensaje, datos) => {
            log(LOG_LEVELS.INFO, 'INFO', mensaje, datos);
          },
          
          /**
           * Registra un mensaje de advertencia
           * @param {string} mensaje - Mensaje a registrar
           * @param {*} [datos] - Datos adicionales a registrar
           */
          warn: (mensaje, datos) => {
            log(LOG_LEVELS.WARN, 'WARN', mensaje, datos);
          },
          
          /**
           * Registra un mensaje de error
           * @param {string} mensaje - Mensaje a registrar
           * @param {Error} error - Objeto de error
           * @param {Object} [datosAdicionales] - Datos adicionales a registrar
           */
          error: (mensaje, error, datosAdicionales = {}) => {
            const datos = { ...datosAdicionales };
            
            if (error) {
              datos.error = {
                mensaje: error.message,
                stack: error.stack,
                ...(error.details && { detalles: error.details })
              };
            }
            
            log(LOG_LEVELS.ERROR, 'ERROR', mensaje, Object.keys(datos).length ? datos : undefined);
          }
        };
      })();
      
      // Modos de operación
      const MODOS = {
        CASA: 'casa',
        AVENTURA: 'aventura'
      };
      
      // Tipos de puntos
      const TIPOS_PUNTO = {
        PARADA: 'parada',
        TRAMO: 'tramo',
        INICIO: 'inicio'
      };
      
      // Acciones comunes
      const ACCIONES = {
        ACTIVAR_GPS: 'activar_gps',
        DESACTIVAR_GPS: 'desactivar_gps',
        SELECCION_PUNTO: 'seleccion_punto',
        CAMBIO_MODO: 'cambio_modo',
        ERROR: 'error'
      };
      
      // Constantes de mensajería
      const MENSAJES = {
        ERROR: {
          CAMPO_REQUERIDO: 'Campo requerido',
          TIPO_INVALIDO: 'Tipo de dato inválido',
          FORMATO_INVALIDO: 'Formato inválido',
          MENSAJE_INVALIDO: 'Mensaje inválido'
        },
        ESTADOS: {
          EXITO: 'exito',
          ERROR: 'error',
          PENDIENTE: 'pendiente'
        }
      };
      
      // Constantes de configuración
      const CONFIG = {
        IFRAME_ID: 'hijo5-casa',
        DEBUG: true,
        LOG_LEVEL: LOG_LEVELS.INFO,
        REINTENTOS: {
          MAXIMOS: 3,
          TIEMPO_ESPERA: 1000,
          FACTOR: 2
        },
        ESTADO_INICIAL: {
          modo: 'casa',
          controlesHabilitados: true,
          puntoActual: null,
          gpsActivo: false,
          tramoActual: null,
          ultimoError: null
        }
      };

      // Configuración de importaciones dinámicas
      const MODULOS = {
        mensajeria: './mensajeria.js',
        funcionesMapa: './funciones-mapa.js'
      };

      // Objeto para almacenar las importaciones
      const modulosImportados = {};
      
      /**
       * Carga un módulo de forma segura
       * @param {string} nombreModulo - Nombre del módulo a cargar
       * @returns {Promise<Object>} Módulo cargado
       * @throws {Error} Si ocurre un error al cargar el módulo
       */
      async function cargarModulo(nombreModulo) {
        try {
          if (!modulosImportados[nombreModulo]) {
            logger.info(`Cargando módulo: ${nombreModulo}`);
            
            // Validar que el módulo esté en la lista de módulos soportados
            if (!MODULOS[nombreModulo]) {
              throw new Error(`Módulo no soportado: ${nombreModulo}`);
            }
            
            // Cargar el módulo dinámicamente
            modulosImportados[nombreModulo] = await import(MODULOS[nombreModulo]);
            
            // Hacer que las funciones estén disponibles globalmente para compatibilidad
            if (nombreModulo === 'mensajeria') {
              window.Mensajeria = modulosImportados.mensajeria;
            }
            
            logger.info(`Módulo cargado: ${nombreModulo}`);
          }
          
          return modulosImportados[nombreModulo];
          
        } catch (error) {
          logger.error(`Error al cargar el módulo ${nombreModulo}`, error);
          throw new Error(`No se pudo cargar el módulo ${nombreModulo}: ${error.message}`);
        }
      }

      // Cargar módulos requeridos
      let mensajeria, funcionesMapa;
      let enviarMensaje, registrarControlador, TIPOS_MENSAJE;
      // Remove duplicate declarations that might conflict with imported modules
      
      try {
        logger.info('Iniciando carga de módulos...');
        
        // Cargar módulos en paralelo para mejor rendimiento
        [mensajeria, funcionesMapa] = await Promise.all([
          cargarModulo('mensajeria'),
          cargarModulo('funcionesMapa')
        ]);
        
        // Desestructurar las funciones necesarias del módulo de mensajería
        if (mensajeria) {
          // Only assign these if they're not already defined to avoid redeclaration
          if (typeof enviarMensaje === 'undefined') {
            ({ enviarMensaje, registrarControlador, TIPOS_MENSAJE } = mensajeria);
          }
          ({ 
            inicializarMensajeria, 
            enviarMensaje, 
            registrarControlador, 
            TIPOS_MENSAJE 
          } = mensajeria);
          
          // Hacer que las funciones estén disponibles globalmente para compatibilidad
          window.inicializarMensajeria = inicializarMensajeria;
          window.enviarMensaje = enviarMensaje;
          window.registrarControlador = registrarControlador;
        }
        
        if (funcionesMapa) {
          ({ 
            inicializarMapa, 
            centrarMapa, 
            actualizarPuntoActual,
            actualizarTramoActual,
            actualizarModo
          } = funcionesMapa);
        }
        
        logger.info('Módulos cargados correctamente');
        
      } catch (error) {
        const errorMsg = 'Error crítico al cargar módulos';
        console.error(errorMsg, error);
        
        // Mostrar mensaje de error al usuario
        const errorContainer = document.createElement('div');
        errorContainer.style.cssText = 'padding: 20px; color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; margin: 10px;';
        errorContainer.innerHTML = `
          <h2>Error al cargar la aplicación</h2>
          <p>No se pudieron cargar los módulos necesarios. Por favor, recarga la página o inténtalo más tarde.</p>
          <p>Detalles: ${error.message}</p>
        `;
        
        document.body.innerHTML = '';
        document.body.appendChild(errorContainer);
        
        throw new Error(`${errorMsg}: ${error.message}`); // Detener la ejecución
      }

      // Extender tipos de mensajes específicos de este componente
      if (TIPOS_MENSAJE) {
        TIPOS_MENSAJE = {
          ...TIPOS_MENSAJE,
          // Mensajes específicos del componente
          CAMBIO_PUNTO: 'hijo5:cambio_punto',
          ACTUALIZAR_ESTADO: 'hijo5:actualizar_estado',
          NOTIFICAR_PUNTO: 'hijo5:notificar_punto'
        };
        logger.info('Constantes de mensajería cargadas correctamente');
      } else {
        logger.error('TIPOS_MENSAJE no está definido');
        throw new Error('No se pudieron cargar las constantes de mensajería');
      }
      
      // Estado inicial de la aplicación
      const ESTADO_INICIAL = {
        modo: 'casa', // 'casa' o 'aventura'
        gpsActivo: false,
        controlesHabilitados: true,
        puntoActual: null,
        tramoActual: null,
        ultimaActualizacion: null,
        version: '1.0.0'
      };

      // Estado global de la aplicación
      let estadoApp = {
        ...ESTADO_INICIAL,
        mensajeriaInicializada: false,
        manejadoresRegistrados: false,
        _listeners: new Set(),
        
        // Método para actualizar el estado de forma controlada
        async actualizarEstado(nuevoEstado) {
          const estadoAnterior = { ...this };
          Object.assign(this, nuevoEstado);
          this.ultimaActualizacion = new Date().toISOString();
          
          // Notificar a los listeners
          await this._notificarCambios(estadoAnterior);
          return true;
        },
        
        // Registrar listeners para cambios de estado
        onCambio(listener) {
          if (typeof listener !== 'function') {
            throw new Error('El listener debe ser una función');
          }
          this._listeners.add(listener);
          return () => this._listeners.delete(listener);
        },
        
        // Notificar cambios a los listeners
        async _notificarCambios(estadoAnterior) {
          const cambios = {};
          
          // Encontrar propiedades que cambiaron
          for (const [key, valor] of Object.entries(this)) {
            if (key.startsWith('_')) continue; // Ignorar propiedades privadas
            if (valor !== estadoAnterior[key]) {
              cambios[key] = {
                anterior: estadoAnterior[key],
                nuevo: valor
              };
            }
          }
          
          // Si no hay cambios, no notificar
          if (Object.keys(cambios).length === 0) return;
          
          // Notificar a los listeners
          const notificaciones = [];
          for (const listener of this._listeners) {
            try {
              notificaciones.push(listener(cambios, this));
            } catch (error) {
              console.error('Error en listener de estado:', error);
            }
          }
          
          // Esperar a que todos los listeners terminen
          await Promise.allSettled(notificaciones);
        },
        
        // Reiniciar al estado inicial
        async reiniciar() {
          const estadoAnterior = { ...this };
          Object.assign(this, {
            ...ESTADO_INICIAL,
            mensajeriaInicializada: this.mensajeriaInicializada,
            manejadoresRegistrados: this.manejadoresRegistrados,
            _listeners: this._listeners,
            _notificarCambios: this._notificarCambios
          });
          await this._notificarCambios(estadoAnterior);
          return true;
        }
      };

      /**
       * Inicializa el sistema de mensajería
       * @returns {Promise<boolean>} True si la inicialización fue exitosa
       */
      async function inicializarMensajeriaApp() {
        if (estadoApp.mensajeriaInicializada) {
          logger.info('La mensajería ya está inicializada');
          return true;
        }

        try {
          logger.info('Inicializando mensajería...');
          
          // Validar que la función de inicialización esté disponible
          if (typeof inicializarMensajeria !== 'function') {
            throw new Error('La función inicializarMensajeria no está disponible');
          }
          
          // Validar configuración
          if (!CONFIG.IFRAME_ID) {
            throw new Error('Configuración no válida: falta IFRAME_ID');
          }
          
          // Inicializar la mensajería con la configuración actual
          await inicializarMensajeria({
            iframeId: CONFIG.IFRAME_ID,
            debug: CONFIG.DEBUG,
            logLevel: CONFIG.LOG_LEVEL,
            reintentos: CONFIG.REINTENTOS
          });
          
          // Actualizar el estado
          await estadoApp.actualizar({ mensajeriaInicializada: true });
          logger.info('Mensajería inicializada correctamente');
          return true;
          
        } catch (error) {
          const errorInfo = await notificarError('inicializacion_mensajeria', error);
          logger.error('Error al inicializar la mensajería', errorInfo);
          throw error;
        }
      }

      /**
       * Registra los manejadores de mensajes del sistema
       * @returns {Promise<boolean>} True si los manejadores se registraron correctamente
       */
      async function registrarManejadores() {
        try {
          logger.info('Registrando manejadores de mensajes...');
          
          // Validar que las funciones necesarias estén disponibles
          if (typeof registrarManejadorMensaje !== 'function') {
            throw new Error('La función registrarManejadorMensaje no está disponible');
          }
          
          if (typeof registrarControlador !== 'function') {
            throw new Error('La función registrarControlador no está disponible');
          }
          
          if (typeof inicializarMensajeria !== 'function') {
            throw new Error('La función inicializarMensajeria no está disponible en el módulo');
          }
          
          // Validar configuración
          if (!CONFIG || !CONFIG.IFRAME_ID) {
            throw new Error('Configuración no válida: falta IFRAME_ID');
          }
          
          if (!TIPOS_MENSAJE) {
            throw new Error('TIPOS_MENSAJE no está definido');
          }
          
          logger.info('Validaciones de manejadores completadas');
          
          // Definir manejadores del sistema
          const manejadoresSistema = [
            { tipo: TIPOS_MENSAJE.SISTEMA.INICIALIZACION, manejador: manejarInicializacion },
            { tipo: TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO, manejador: manejarCambioModo },
            { tipo: TIPOS_MENSAJE.SISTEMA.CONFIRMACION, manejador: manejarConfirmacion },
            { tipo: TIPOS_MENSAJE.SISTEMA.ACTUALIZAR_ESTADO, manejador: manejarActualizacionEstado },
            { tipo: TIPOS_MENSAJE.SISTEMA.SOLICITAR_ESTADO, manejador: manejarSolicitudEstado },
            { tipo: TIPOS_MENSAJE.SISTEMA.ERROR, manejador: manejarError }
          ];
          
          // Registrar manejadores específicos del componente si existen
          if (typeof manejarMensajeEspecifico === 'function') {
            manejadoresSistema.push({
              tipo: TIPOS_MENSAJE.ESPECIFICO,
              manejador: manejarMensajeEspecifico
            });
          }
          
          // Registrar todos los manejadores
          for (const { tipo, manejador } of manejadoresSistema) {
            if (typeof manejador === 'function') {
              registrarControlador(tipo, manejador);
              if (CONFIG.DEBUG) {
                console.log(`[${CONFIG.IFRAME_ID}] Manejador registrado para: ${tipo}`);
              }
            }
          }
          
          estadoApp.manejadoresRegistrados = true;
          console.log(`[${CONFIG.IFRAME_ID}] Todos los manejadores de mensajes registrados`);
          return true;
          
        } catch (error) {
          await notificarError('registro_manejadores', error);
          throw error; // Relanzar para que el llamador pueda manejarlo
        }
      }

      /**
       * Notifica el estado actual al iframe padre
       * @param {string} accion - Acción que generó el cambio de estado
       * @param {Object} [datosAdicionales={}] - Datos adicionales a incluir en la notificación
       * @returns {Promise<boolean>} True si la notificación se envió correctamente
       */
      // ================== MANEJO DE ERRORES ESTÁNDAR ==================
      /**
       * Notifica un error al padre y lo registra en el logger
       * @param {string} tipo - Tipo de error
       * @param {Error|string|Object} error - Objeto de error, mensaje u objeto con detalles
       * @param {Object} [datosAdicionales={}] - Datos adicionales para incluir en el error
       * @returns {Promise<Object>} Información detallada del error
       */
      async function notificarError(tipo, error, datosAdicionales = {}) {
        try {
          // Ensure we have a valid error object
          const errorObj = typeof error === 'string' 
            ? new Error(error) 
            : error instanceof Error 
              ? error 
              : new Error('Error desconocido');
          
          // Prepare error info
          const errorInfo = {
            tipo,
            mensaje: errorObj.message,
            stack: errorObj.stack,
            ...datosAdicionales,
            origen: CONFIG.IFRAME_ID,
            timestamp: new Date().toISOString()
          };
          
          // Log the error
          console.error(`[${CONFIG.IFRAME_ID}] Error (${tipo}):`, errorInfo);
          
          // Send error to parent if messaging is available
          if (typeof enviarMensaje === 'function') {
            try {
              await enviarMensaje('padre', TIPOS_MENSAJE.SISTEMA.ERROR, errorInfo);
            } catch (sendError) {
              console.error('Error al enviar mensaje de error al padre:', sendError);
            }
          }
          
          return errorInfo;
          
        } catch (error) {
          // If there's an error in the error handler, use console.error directly
          console.error('Error crítico en notificarError:', error);
          return {
            tipo: 'error_critico',
            mensaje: 'Error en el manejador de errores: ' + (error.message || 'Error desconocido'),
            stack: error.stack,
            origen: CONFIG.IFRAME_ID,
            timestamp: new Date().toISOString()
          };
        }
      }
      
      // Función auxiliar para manejo de errores en promesas
      const manejarError = (tipo) => (error) => {
        notificarError(tipo, error);
        return Promise.reject(error);
      };

      // ================== FUNCIONES DE VALIDACIÓN ==================
      
      /**
       * Valida un ID de punto
       * @param {string} idPunto - ID del punto a validar
       * @returns {Object} { valido: boolean, mensaje: string }
       */
      function validarIdPunto(idPunto) {
        if (!idPunto || typeof idPunto !== 'string') {
          return { 
            valido: false, 
            mensaje: `${MENSAJES.ERROR.CAMPO_REQUERIDO}: ID del punto debe ser una cadena no vacía`
          };
        }
        
        // Verificar formato del ID (ejemplo: 'padre-P-1' o 'padre-TR-1')
        const regex = /^padre-(P|TR)-\d+$/;
        if (!regex.test(idPunto)) {
          return { 
            valido: false, 
            mensaje: `${MENSAJES.ERROR.FORMATO_INVALIDO}: ${idPunto}. Debe seguir el formato 'padre-P-<número>' o 'padre-TR-<número>'`
          };
        }
        
        return { valido: true };
      }
      
      /**
       * Valida un objeto de punto
       * @param {Object} punto - Punto a validar
       * @returns {Object} { valido: boolean, errores: string[] }
       */
      function validarPunto(punto) {
        const errores = [];
        
        if (!punto || typeof punto !== 'object') {
          return { 
            valido: false, 
            errores: [`${MENSAJES.ERROR.TIPO_INVALIDO}: Se esperaba un objeto para el punto`] 
          };
        }
        
        // Validar campos requeridos
        const camposRequeridos = ['padreid', 'tipo', 'nombre'];
        camposRequeridos.forEach(campo => {
          if (!(campo in punto)) {
            errores.push(`${MENSAJES.ERROR.CAMPO_REQUERIDO}: '${campo}'`);
          }
        });
        
        // Validar tipo de punto
        if (punto.tipo && !Object.values(TIPOS_PUNTO).includes(punto.tipo)) {
          errores.push(`${MENSAJES.ERROR.TIPO_INVALIDO}: '${punto.tipo}'. Valores permitidos: ${Object.values(TIPOS_PUNTO).join(', ')}`);
        }
        
        // Validar ID del punto
        if (punto.padreid) {
          const validacionId = validarIdPunto(punto.padreid);
          if (!validacionId.valido) {
            errores.push(validacionId.mensaje);
          }
        }
        
        // Validar que tenga al menos parada o tramo según el tipo
        if (punto.tipo === TIPOS_PUNTO.PARADA && punto.parada === undefined) {
          errores.push(`${MENSAJES.ERROR.CAMPO_REQUERIDO}: 'parada' para puntos de tipo '${TIPOS_PUNTO.PARADA}'`);
        }
        
        if (punto.tipo === TIPOS_PUNTO.TRAMO && punto.tramo === undefined) {
          errores.push(`${MENSAJES.ERROR.CAMPO_REQUERIDO}: 'tramo' para puntos de tipo '${TIPOS_PUNTO.TRAMO}'`);
        }
        
        return {
          valido: errores.length === 0,
          errores
        };
      }
      
      /**
       * Valida un mensaje recibido
       * @param {Object} mensaje - Mensaje a validar
       * @param {Array<string>} camposRequeridos - Campos requeridos en el mensaje
       * @returns {Object} { valido: boolean, error?: string }
       */
      function validarMensaje(mensaje, camposRequeridos = ['tipo', 'origen']) {
        if (!mensaje || typeof mensaje !== 'object') {
          return { 
            valido: false, 
            error: `${MENSAJES.ERROR.TIPO_INVALIDO}: Se esperaba un objeto para el mensaje`
          };
        }
        
        // Verificar campos requeridos
        const faltantes = camposRequeridos.filter(campo => !(campo in mensaje));
        if (faltantes.length > 0) {
          return { 
            valido: false, 
            error: `${MENSAJES.ERROR.CAMPO_REQUERIDO}: ${faltantes.join(', ')}`
          };
        }
        
        // Validar tipo de mensaje
        if (mensaje.tipo && typeof mensaje.tipo !== 'string') {
          return { 
            valido: false, 
            error: `${MENSAJES.ERROR.TIPO_INVALIDO}: 'tipo' debe ser una cadena`
          };
        }
        
        // Validar origen
        if (mensaje.origen && typeof mensaje.origen !== 'string') {
          return { 
            valido: false, 
            error: `${MENSAJES.ERROR.TIPO_INVALIDO}: 'origen' debe ser una cadena`
          };
        }
        
        return { valido: true };
      }
      
      /**
       * Valida los datos de entrada para el cambio de modo
       * @param {Object} datos - Datos a validar
       * @returns {Object} { valido: boolean, error?: string, modo?: string }
       */
      function validarCambioModo(datos = {}) {
        const { modo, motivo = 'desconocido' } = datos;
        
        // Validar que el modo sea válido
        if (!Object.values(MODOS).includes(modo)) {
          return { 
            valido: false, 
            error: `${MENSAJES.ERROR.TIPO_INVALIDO}: '${modo}'. Debe ser uno de: ${Object.values(MODOS).join(', ')}`
          };
        }
        
        // Validar que el motivo sea una cadena
        if (typeof motivo !== 'string') {
          return { 
            valido: false, 
            error: `${MENSAJES.ERROR.TIPO_INVALIDO}: 'motivo' debe ser una cadena`
          };
        }
        
        // Si todo es válido, devolver los datos normalizados
        return { 
          valido: true, 
          modo,
          motivo: motivo.trim() || 'sin motivo especificado'
        };
      }

      // ================== FUNCIONES DE ESTADO ==================
      async function notificarEstado(accion, datos = {}) {
        // Validar entrada
        if (typeof accion !== 'string' || !accion.trim()) {
          console.error(`[${CONFIG.IFRAME_ID}] Acción no válida para notificar estado`);
          return false;
        }
        
        if (!enviarMensaje) {
          console.warn(`[${CONFIG.IFRAME_ID}] Mensajería no disponible para notificar estado`);
          return false;
        }
        
        // Validar que los datos sean un objeto
        if (typeof datos !== 'object' || datos === null) {
          console.error(`[${CONFIG.IFRAME_ID}] Datos de estado no válidos`);
          return false;
        }
        
        const timestamp = new Date().toISOString();
        const mensaje = {
          tipo: TIPOS_MENSAJE.SISTEMA.ACTUALIZAR_ESTADO,
          origen: CONFIG.IFRAME_ID,
          accion,
          datos: {
            ...datos, // Usar el parámetro datos en lugar de datosAdicionales
            timestamp,
            modo: estadoApp.modo,
            gpsActivo: estadoApp.gpsActivo,
            controlesHabilitados: estadoApp.controlesHabilitados,
            puntoActual: estadoApp.puntoActual,
            tramoActual: estadoApp.tramoActual
          }
        };
        
        try {
          // Usar el sistema de mensajería con reintentos
          await enviarMensaje(
            'padre',
            TIPOS_MENSAJE.SISTEMA.ACTUALIZAR_ESTADO,
            mensaje.datos,
            { reintentos: CONFIG.REINTENTOS.MAXIMOS }
          );
          
          console.log(`[${CONFIG.IFRAME_ID}] Estado notificado: ${accion}`, mensaje.datos);
          return true;
          
        } catch (error) {
          const errorMsg = `Error al notificar estado (${accion}): ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          mostrarError(errorMsg);
          return false;
        }
      }
      
      // Manejador de inicialización
      async function manejarInicializacion(mensaje) {
        console.log(`[${CONFIG.IFRAME_ID}] Inicialización solicitada:`, mensaje);
        
        try {
          // Actualizar el estado con los datos recibidos
          if (mensaje.datos) {
            const { modo, controlesHabilitados, puntoActual, gpsActivo, tramoActual } = mensaje.datos;
            
            if (modo) estadoApp.modo = modo;
            if (typeof controlesHabilitados === 'boolean') {
              estadoApp.controlesHabilitados = controlesHabilitados;
            }
            if (puntoActual) estadoApp.puntoActual = puntoActual;
            if (typeof gpsActivo === 'boolean') estadoApp.gpsActivo = gpsActivo;
            if (tramoActual !== undefined) estadoApp.tramoActual = tramoActual;
          }
          
          // Actualizar la interfaz de usuario según el estado actual
          actualizarInterfaz();
          
          // Notificar que la inicialización fue exitosa
          await notificarEstado('inicializado');
          return true;
          
        } catch (error) {
          const errorMsg = `Error en inicialización: ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          mostrarError(errorMsg);
          return false;
        }
      }
      
      /**
       * Maneja las actualizaciones de estado recibidas
       * @param {Object} mensaje - Mensaje con la actualización de estado
       * @returns {Promise<boolean>} True si la actualización se procesó correctamente
       */
      async function manejarActualizacionEstado(mensaje) {
        console.log(`[${CONFIG.IFRAME_ID}] Actualización de estado recibida:`, mensaje);
        
        try {
          if (!mensaje.datos) {
            throw new Error('Datos de actualización no proporcionados');
          }
          
          const { 
            modo, 
            gpsActivo, 
            controlesHabilitados, 
            puntoActual, 
            tramoActual,
            motivo = 'actualizacion_estado'
          } = mensaje.datos;
          
          // Actualizar el estado según los datos recibidos
          let cambios = [];
          
          if (modo && estadoApp.modo !== modo) {
            estadoApp.modo = modo;
            cambios.push(`modo: ${modo}`);
          }
          
          if (typeof gpsActivo === 'boolean' && estadoApp.gpsActivo !== gpsActivo) {
            estadoApp.gpsActivo = gpsActivo;
            cambios.push(`gpsActivo: ${gpsActivo}`);
          }
          
          if (typeof controlesHabilitados === 'boolean' && 
              estadoApp.controlesHabilitados !== controlesHabilitados) {
            estadoApp.controlesHabilitados = controlesHabilitados;
            cambios.push(`controles: ${controlesHabilitados ? 'habilitados' : 'deshabilitados'}`);
          }
          
          if (puntoActual !== undefined && JSON.stringify(estadoApp.puntoActual) !== JSON.stringify(puntoActual)) {
            estadoApp.puntoActual = puntoActual;
            cambios.push('punto actual actualizado');
          }
          
          if (tramoActual !== undefined && estadoApp.tramoActual !== tramoActual) {
            estadoApp.tramoActual = tramoActual;
            cambios.push(`tramo actual: ${tramoActual}`);
          }
          
          // Si hubo cambios, actualizar la interfaz
          if (cambios.length > 0) {
            console.log(`[${CONFIG.IFRAME_ID}] Estado actualizado: ${cambios.join(', ')}`);
            actualizarInterfaz();
          }
          
          return true;
          
        } catch (error) {
          const errorMsg = `Error al actualizar estado: ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          mostrarError(errorMsg);
          return false;
        }
      }
      
      // Manejador de cambio de modo
      async function manejarCambioModo(datos = {}) {
        // Validar datos de entrada
        const validacion = validarCambioModo(datos);
        if (!validacion.valido) {
          throw new Error(validacion.error);
        }
        
        const { modo: modoSolicitado, motivo = 'Cambio de modo solicitado' } = validacion;
        const modoAnterior = estadoApp.modo;
        
        // Validar modo
        if (modoSolicitado !== 'casa' && modoSolicitado !== 'aventura') {
          const errorMsg = `Modo no válido: ${modoSolicitado}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`);
          
          // Enviar mensaje de error al padre
          if (enviarMensaje) {
            try {
              await enviarMensaje(
                'padre',
                TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO_CONFIRMACION,
                {
                  estado: 'error',
                  error: errorMsg,
                  modo: modoAnterior,
                  modoSolicitado,
                  motivo,
                  timestamp: new Date().toISOString(),
                  origen: CONFIG.IFRAME_ID,
                  destino: 'padre',
                  version: '1.0',
                  metadata: {
                    forzar: Boolean(datos.forzar),
                    solicitante: datos.origen || 'sistema',
                    timestampSolicitud: datos.timestamp || new Date().toISOString(),
                    timestampError: new Date().toISOString()
                  }
                },
                { maxRetries: 3, retryDelay: 1000, timeout: 5000 }
              );
            } catch (error) {
              console.error(`[${CONFIG.IFRAME_ID}] Error al notificar error de cambio de modo:`, error);
            }
          }
          
          throw new Error(errorMsg);
        }
        
        // Si ya está en el modo solicitado, notificar al padre y salir
        if (modoSolicitado === modoAnterior) {
          console.log(`[${CONFIG.IFRAME_ID}] Ya está en modo ${modoSolicitado}, notificando al padre...`);
          
          if (enviarMensaje) {
            try {
              await enviarMensaje(
                'padre',
                TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO_CONFIRMACION,
                {
                  estado: 'completado',
                  modo: modoSolicitado,
                  modoAnterior,
                  motivo: 'Ya estaba en el modo solicitado',
                  timestamp: new Date().toISOString(),
                  origen: CONFIG.IFRAME_ID,
                  destino: 'padre',
                  version: '1.0',
                  metadata: {
                    forzar: Boolean(datos.forzar),
                    solicitante: datos.origen || 'sistema',
                    timestampSolicitud: datos.timestamp || new Date().toISOString()
                  }
                },
                { maxRetries: 3, retryDelay: 1000, timeout: 5000 }
              );
            } catch (error) {
              console.error(`[${CONFIG.IFRAME_ID}] Error al notificar confirmación de modo:`, error);
            }
          }
          
          return true;
        }
        
        try {
          console.log(`[${CONFIG.IFRAME_ID}] Cambiando de modo ${modoAnterior} a ${modoSolicitado}...`);
          
          // Actualizar el estado local
          estadoApp.modo = modoSolicitado;
          
          // Actualizar la interfaz
          actualizarInterfaz();
          
          // Notificar al padre del cambio de modo exitoso
          if (enviarMensaje) {
            try {
              await enviarMensaje(
                'padre',
                TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO_CONFIRMACION,
                {
                  estado: 'completado',
                  modo: modoSolicitado,
                  modoAnterior,
                  motivo: motivo || 'Cambio de modo exitoso',
                  timestamp: new Date().toISOString(),
                  origen: CONFIG.IFRAME_ID,
                  destino: 'padre',
                  version: '1.0',
                  metadata: {
                    forzar: Boolean(datos.forzar),
                    solicitante: datos.origen || 'sistema',
                    timestampSolicitud: datos.timestamp || new Date().toISOString()
                  }
                },
                { maxRetries: 3, retryDelay: 1000, timeout: 5000 }
              );
              console.log(`[${CONFIG.IFRAME_ID}] Confirmación de cambio de modo enviada al padre`);
            } catch (notifyError) {
              console.error(`[${CONFIG.IFRAME_ID}] Error al notificar confirmación de modo:`, notifyError);
              throw notifyError; // Relanzar para que se maneje en el catch externo
            }
          } else {
            console.warn(`[${CONFIG.IFRAME_ID}] No se pudo enviar confirmación: Mensajería no disponible`);
          }
          
          console.log(`[${CONFIG.IFRAME_ID}] Modo cambiado exitosamente a ${modoSolicitado}`);
          return true;
          
        } catch (error) {
          const errorMsg = `Error al cambiar el modo: ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          
          // Notificar el error al padre
          if (enviarMensaje) {
            try {
              await enviarMensaje(
                'padre',
                TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO_CONFIRMACION,
                {
                  estado: 'error',
                  error: error.message,
                  modo: modoAnterior,
                  modoSolicitado,
                  motivo: motivo || 'Error al cambiar de modo',
                  timestamp: new Date().toISOString(),
                  origen: CONFIG.IFRAME_ID,
                  destino: 'padre',
                  version: '1.0',
                  metadata: {
                    forzar: Boolean(datos.forzar),
                    solicitante: datos.origen || 'sistema',
                    timestampSolicitud: datos.timestamp || new Date().toISOString(),
                    timestampError: new Date().toISOString(),
                    stack: error.stack
                  }
                },
                { maxRetries: 3, retryDelay: 1000, timeout: 5000 }
              );
            } catch (notifyError) {
              console.error(`[${CONFIG.IFRAME_ID}] Error al notificar error de cambio de modo:`, notifyError);
            }
          }
          
          // También notificar a través del sistema de notificaciones local
          try {
            await notificarEstado('error_cambio_modo', {
              error: error.message,
              motivo: motivo || 'desconocido',
              modoAnterior,
              modoIntentado: modoSolicitado,
              stack: error.stack
            });
          } catch (notifyError) {
            console.error(`[${CONFIG.IFRAME_ID}] Error al notificar el error localmente:`, notifyError);
          }
          
          // Relanzar el error para que el llamador pueda manejarlo si es necesario
          throw error;
        }
      }
      
      /**
       * Maneja las solicitudes de estado de la aplicación
       * @param {Object} mensaje - Mensaje de solicitud de estado
       * @param {string} [mensaje.datos.solicitud] - Tipo de información solicitada
       * @param {string} [mensaje.datos.idSolicitud] - ID opcional para seguimiento
       * @returns {Promise<boolean>} True si se manejó la solicitud correctamente
       */
      async function manejarSolicitudEstado(mensaje = {}) {
        const { solicitud = 'completo', idSolicitud } = mensaje.datos || {};
        const idMensaje = idSolicitud || `solicitud_${Date.now()}`;
        
        console.log(`[${CONFIG.IFRAME_ID}] Solicitud de estado recibida (${solicitud})`, { 
          idSolicitud: idMensaje,
          origen: mensaje.origen 
        });
        
        try {
          // Preparar la respuesta según el tipo de solicitud
          let datosRespuesta = {
            idSolicitud: idMensaje,
            timestamp: new Date().toISOString(),
            origen: CONFIG.IFRAME_ID,
            estado: {
              modo: estadoApp.modo,
              gpsActivo: estadoApp.gpsActivo,
              controlesHabilitados: estadoApp.controlesHabilitados,
              puntoActual: estadoApp.puntoActual,
              tramoActual: estadoApp.tramoActual,
              ultimoError: estadoApp.ultimoError,
              version: '1.0.0' // Versión del formato de respuesta
            }
          };

          // Enviar respuesta
          await enviarMensaje(
            mensaje.origen || 'padre',
            'respuesta_estado',
            datosRespuesta,
            { 
              maxRetries: CONFIG.REINTENTOS.MAXIMOS,
              retryDelay: CONFIG.REINTENTOS.TIEMPO_ESPERA
            }
          );

          console.log(`[${CONFIG.IFRAME_ID}] Estado enviado (${solicitud})`, { 
            idSolicitud: idMensaje,
            destino: mensaje.origen || 'padre'
          });
          return true;
        } catch (error) {
          const errorMsg = `Error al procesar solicitud de estado (${solicitud}): ${error.message}`;
          console.error(`[${CONFIG.IFRAME_ID}] ${errorMsg}`, error);
          
          // Intentar notificar el error
          try {
            await enviarMensaje(
              mensaje.origen || 'padre',
              'error_solicitud_estado',
              {
                idSolicitud: idMensaje,
                error: error.message,
                timestamp: new Date().toISOString()
              },
              { maxRetries: 1 } // Solo un intento para errores
            );
          } catch (notifyError) {
            console.error(`[${CONFIG.IFRAME_ID}] Error al notificar error de estado:`, notifyError);
          }
          
          return false;
        }
      }
      
      /**
       * Maneja las confirmaciones de operaciones enviadas previamente
       * @param {Object} mensaje - Mensaje de confirmación
       * @param {string} mensaje.tipo - Tipo de operación confirmada
       * @param {string} mensaje.id - ID único de la operación
       * @param {boolean} mensaje.exito - Indica si la operación fue exitosa
       * @param {Object} [mensaje.datos] - Datos adicionales de la confirmación
       * @param {string} [mensaje.mensaje] - Mensaje descriptivo
       * @returns {Promise<boolean>} True si se manejó la confirmación correctamente
       */
      async function manejarConfirmacion(mensaje = {}) {
        const { tipo, id, exito, datos = {}, mensaje: mensajeTexto } = mensaje.datos || {};
        const idOperacion = id || 'desconocido';
        
        // Log detallado de la confirmación
        console.log(`[${CONFIG.IFRAME_ID}] Confirmación recibida`, {
          tipo: tipo || 'sin_tipo',
          id: idOperacion,
          exito: exito === true,
          origen: mensaje.origen || 'desconocido',
          timestamp: new Date().toISOString()
        });
        
        try {
          // Manejar la confirmación según el tipo de operación
          if (exito) {
            // Operación exitosa
            console.log(`[${CONFIG.IFRAME_ID}] Operación '${tipo}' (${idOperacion}) confirmada con éxito`);
            
            // Aquí podrías agregar lógica específica para cada tipo de operación
            switch (tipo) {
              case 'cambio_modo':
                console.log(`[${CONFIG.IFRAME_ID}] Modo cambiado exitosamente a: ${datos.modoNuevo}`);
                break;
                
              case 'actualizacion_estado':
                // Actualizar el estado local si es necesario
                if (datos.estado) {
                  console.log(`[${CONFIG.IFRAME_ID}] Estado sincronizado:`, datos.estado);
                }
                break;
                
              default:
                // No se requiere acción específica para otros tipos
                break;
            }
            
            // Notificar a la interfaz de usuario si es necesario
            actualizarInterfaz();
            
          } else {
            // Operación fallida
            const errorMsg = datos?.error || mensajeTexto || 'Error desconocido';
            console.error(`[${CONFIG.IFRAME_ID}] Error en operación '${tipo}' (${idOperacion}):`, errorMsg);
            
            // Mostrar notificación de error al usuario
            mostrarError(`Error en ${tipo || 'operación'}: ${errorMsg}`);
            
            // Revertir cambios si es necesario según el tipo de operación
            switch (tipo) {
              case 'cambio_modo':
                // Revertir al modo anterior si el cambio falló
                if (datos.modoAnterior) {
                  console.warn(`[${CONFIG.IFRAME_ID}] Revertiendo a modo anterior: ${datos.modoAnterior}`);
                  estadoApp.modo = datos.modoAnterior;
                  actualizarInterfaz();
                }
                break;
                
              // Agregar más casos según sea necesario
            }
            
            // Registrar el error en el estado
            estadoApp.ultimoError = {
              tipo,
              id: idOperacion,
              mensaje: errorMsg,
              timestamp: new Date().toISOString(),
              datos
            };
          }
          
          return true;
          
        } catch (error) {
          // Manejar errores en el procesamiento de la confirmación
          console.error(`[${CONFIG.IFRAME_ID}] Error al procesar confirmación:`, error);
          
          // Notificar el error sin reintentos para evitar bucles
          try {
            await enviarMensaje(
              mensaje.origen || 'padre',
              'error_procesamiento_confirmacion',
              {
                idConfirmacion: idOperacion,
                tipo,
                error: error.message,
                timestamp: new Date().toISOString()
              },
              { maxRetries: 1 } // Solo un intento para errores
            );
          } catch (notifyError) {
            console.error(`[${CONFIG.IFRAME_ID}] Error al notificar error de confirmación:`, notifyError);
          }
          
          return false;
        }
      }
      
      /**
       * Notifica un error al sistema de registro y opcionalmente al padre
       * @param {string} tipo - Tipo de error
       * @param {Error} error - Objeto de error
       * @returns {Promise<Object>} Información del error notificado
       */
      // La función notificarError ahora se importa del módulo error-handler.js
      
      // Sincronizar estado con el padre
      async function sincronizarEstado(estado) {
        if (!estado) return;
        
        console.log(`[${CONFIG.IFRAME_ID}] Sincronizando estado:`, estado);
        
        // Actualizar estado local
        if (estado.modo) {
          estadoApp.modo = estado.modo;
        }
        
        if (typeof estado.controlesHabilitados !== 'undefined') {
          estadoApp.controlesHabilitados = estado.controlesHabilitados;
        }
        
        if (estado.puntoActual) {
          estadoApp.puntoActual = estado.puntoActual;
        }
        
        // Aplicar cambios en la interfaz
        actualizarInterfaz();
      }
      
      // La función actualizarInterfaz ha sido movida más abajo para mantener todo el código relacionado junto
      
      // Incluir aquí las funciones existentes como actualizarBotonGPS, etc.
      // ...
      
      /**
       * Muestra un mensaje de error en la interfaz de usuario
       * @param {string} mensaje - Mensaje de error a mostrar
       * @param {Error} [error] - Error opcional para registrar
       */
      function mostrarError(mensaje, error = null) {
        // Registrar el error
        if (error) {
          logger.error(mensaje, error);
        } else {
          logger.error(mensaje);
        }
        
        // Mostrar mensaje de error en la interfaz si es posible
        const errorContainer = document.getElementById('error-container');
        if (errorContainer) {
          errorContainer.textContent = mensaje;
          errorContainer.style.display = 'block';
          
          // Ocultar el mensaje después de 5 segundos
          setTimeout(() => {
            errorContainer.style.display = 'none';
          }, 5000);
        }
      }
      
      /**
       * Habilita o deshabilita los controles de la interfaz según el modo
       * @param {string} modo - Modo para el cual habilitar los controles
       * @returns {Promise<boolean>} True si los controles se habilitaron correctamente
       */
      async function habilitarControles(modo) {
        logger.debug(`Habilitando controles para modo: ${modo}`);
        
        try {
          // Actualizar estado
          estadoApp.controlesHabilitados = true;
          
          // Habilitar controles específicos
          const gpsBtn = document.getElementById('gps-casa-btn');
          const modoBtn = document.getElementById('boton-cambio-modo');
          
          if (gpsBtn) gpsBtn.disabled = false;
          if (modoBtn) modoBtn.disabled = false;
          
          logger.info(`Controles habilitados para modo: ${modo}`);
          return true;
          
        } catch (error) {
          const errorMsg = 'Error al habilitar controles';
          console.error(errorMsg, error);
          throw new Error(`${errorMsg}: ${error.message}`);
        }
      }
      
      /**
       * Deshabilita los controles de la interfaz
       * @param {string} razon - Razón por la que se deshabilitan los controles
       * @returns {Promise<boolean>} True si los controles se deshabilitaron correctamente
       */
      async function deshabilitarControles(razon) {
        logger.debug(`Deshabilitando controles. Razón: ${razon}`);
        
        try {
          // Actualizar estado
          estadoApp.controlesHabilitados = false;
          
          // Deshabilitar controles específicos
          const gpsBtn = document.getElementById('gps-casa-btn');
          const modoBtn = document.getElementById('boton-cambio-modo');
          
          if (gpsBtn) gpsBtn.disabled = true;
          if (modoBtn) modoBtn.disabled = true;
          
          logger.info(`Controles deshabilitados. Razón: ${razon}`);
          return true;
          
        } catch (error) {
          const errorMsg = 'Error al deshabilitar controles';
          console.error(errorMsg, error);
          throw new Error(`${errorMsg}: ${error.message}`);
        }
      }
      
      /**
       * Actualiza la interfaz de usuario según el estado actual de la aplicación
       * @returns {void}
       */
      function actualizarInterfaz() {
        try {
          const { modo, gpsActivo, controlesHabilitados, puntoActual, tramoActual } = estadoApp;
          
          // 1. Actualizar el botón GPS
          const gpsBtn = document.getElementById('gps-casa-btn');
          if (gpsBtn) {
            // Actualizar clases según el modo
            gpsBtn.classList.toggle('modo-casa', modo === 'casa');
            gpsBtn.classList.toggle('modo-aventura', modo === 'aventura');
            
            // Actualizar estado activo/inactivo
            gpsBtn.classList.toggle('activo', gpsActivo);
            gpsBtn.title = gpsActivo ? 'GPS Activado' : 'GPS Desactivado';
            
            // Actualizar estado habilitado/deshabilitado
            gpsBtn.disabled = !controlesHabilitados;
          }
          
          // 2. Actualizar indicadores de estado
          const actualizarIndicador = (id, texto, clase = '') => {
            const elemento = document.getElementById(id);
            if (elemento) {
              if (texto !== undefined) elemento.textContent = texto;
              if (clase) elemento.className = clase;
            }
          };
          
          // Indicador de modo
          actualizarIndicador(
            'indicador-modo',
            `Modo: ${modo || 'no definido'}`,
            `modo-indicador modo-${modo || 'desconocido'}`
          );
          
          // Indicador de GPS
          actualizarIndicador(
            'estado-gps',
            `GPS: ${gpsActivo ? 'Activo' : 'Inactivo'}`,
            `estado-gps ${gpsActivo ? 'activo' : 'inactivo'}`
          );
          
          // Indicador de punto/tramo actual
          if (puntoActual) {
            const esParada = puntoActual.tipo === 'parada' || puntoActual.parada !== undefined;
            const textoPunto = esParada 
              ? `Parada: ${puntoActual.nombre || puntoActual.id || 'Desconocida'}`
              : `Tramo: ${puntoActual.nombre || puntoActual.id || 'Desconocido'}`;
            
            actualizarIndicador('punto-actual', textoPunto, 'punto-actual');
          } else {
            actualizarIndicador('punto-actual', 'Ningún punto seleccionado', 'punto-actual');
          }
          
          // 3. Actualizar clases del body para estilos contextuales
          document.body.classList.toggle('controles-deshabilitados', !controlesHabilitados);
          document.body.classList.toggle('gps-activo', gpsActivo);
          document.body.classList.toggle(`modo-${modo}`, !!modo);
          
          // 4. Actualizar controles interactivos
          const controles = document.querySelectorAll('button, .control-interactivo');
          controles.forEach(control => {
            // No modificar controles marcados como siempre habilitados
            if (control.hasAttribute('data-siempre-habilitado')) return;
            
            // Actualizar estado habilitado/deshabilitado
            control.disabled = !controlesHabilitados;
            control.classList.toggle('deshabilitado', !controlesHabilitados);
          });
          
          console.log(`[${CONFIG.IFRAME_ID}] Interfaz actualizada`, {
            modo,
            gpsActivo,
            controlesHabilitados,
            puntoActual: puntoActual ? puntoActual.id || puntoActual.nombre : 'ninguno'
          });
          
        } catch (error) {
          console.error(`[${CONFIG.IFRAME_ID}] Error al actualizar la interfaz:`, error);
        }
      }
      
      // ================== MANEJADORES DE EVENTOS ==================
      
      // Sistema de gestión de manejadores de eventos
      const manejadoresEventos = {
        _almacen: new Map(),
        
        /**
         * Agrega un manejador de eventos a un elemento
         * @param {HTMLElement} elemento - Elemento al que se agregará el manejador
         * @param {string} tipoEvento - Tipo de evento a manejar
         * @param {Function} manejador - Función que manejará el evento
         * @param {Object} [opciones] - Opciones adicionales para el manejador
         */
        agregar(elemento, tipoEvento, manejador, opciones) {
          if (!elemento || !tipoEvento || typeof manejador !== 'function') {
            logger.warn('Parámetros inválidos para agregar manejador', { 
              elemento: !!elemento, 
              tipoEvento,
              esFuncion: typeof manejador === 'function'
            });
            return;
          }
          
          const clave = this._generarClave(elemento);
          
          if (!this._almacen.has(clave)) {
            this._almacen.set(clave, new Map());
          }
          
          const eventosElemento = this._almacen.get(clave);
          
          if (!eventosElemento.has(tipoEvento)) {
            eventosElemento.set(tipoEvento, []);
          }
          
          eventosElemento.get(tipoEvento).push({ manejador, opciones });
          elemento.addEventListener(tipoEvento, manejador, opciones);
          
          logger.debug(`Manejador agregado: ${clave} - ${tipoEvento}`);
        },
        
        /**
         * Elimina manejadores de eventos de un elemento
         * @param {HTMLElement} elemento - Elemento del que se eliminarán los manejadores
         * @param {string} [tipoEvento] - Tipo de evento a eliminar (opcional)
         */
        eliminar(elemento, tipoEvento) {
          if (!elemento) {
            logger.warn('No se puede eliminar manejadores: elemento no proporcionado');
            return;
          }
          
          const clave = this._generarClave(elemento);
          if (!this._almacen.has(clave)) {
            logger.debug(`No hay manejadores registrados para el elemento: ${clave}`);
            return;
          }
          
          const eventosElemento = this._almacen.get(clave);
          
          if (tipoEvento) {
            this._eliminarTipoEvento(elemento, eventosElemento, tipoEvento);
            
            if (eventosElemento.size === 0) {
              this._almacen.delete(clave);
              logger.debug(`Todos los manejadores eliminados para: ${clave}`);
            }
          } else {
            // Eliminar todos los tipos de eventos para este elemento
            for (const [tipo] of eventosElemento) {
              this._eliminarTipoEvento(elemento, eventosElemento, tipo);
            }
            this._almacen.delete(clave);
            logger.debug(`Todos los manejadores eliminados para: ${clave}`);
          }
        },
        
        /**
         * Elimina todos los manejadores de eventos registrados
         */
        limpiarTodo() {
          if (this._almacen.size === 0) {
            logger.debug('No hay manejadores para limpiar');
            return;
          }
          
          logger.info(`Limpiando ${this._almacen.size} elementos con manejadores...`);
          
          for (const [clave, eventosElemento] of this._almacen) {
            const [tag, id, ...clases] = clave.split('.');
            let selector = tag;
            if (id) selector += `#${id}`;
            if (clases.length) selector += `.${clases.join('.')}`;
            
            const elemento = document.querySelector(selector);
            if (!elemento) {
              logger.warn(`Elemento no encontrado: ${selector}`);
              continue;
            }
            
            for (const [tipoEvento] of eventosElemento) {
              this.eliminar(elemento, tipoEvento);
            }
          }
          
          this._almacen.clear();
          logger.info('Todos los manejadores han sido eliminados');
        },
        
        /**
         * Genera una clave única para identificar un elemento
         * @private
         * @param {HTMLElement} elemento - Elemento para generar la clave
         * @returns {string} Clave única para el elemento
         */
        _generarClave(elemento) {
          const tag = elemento.tagName ? elemento.tagName.toLowerCase() : 'unknown';
          const id = elemento.id ? elemento.id : '';
          const clases = elemento.classList ? Array.from(elemento.classList).join('.') : '';
          return [tag, id, clases].filter(Boolean).join('.');
        },
        
        /**
         * Elimina todos los manejadores de un tipo de evento específico
         * @private
         * @param {HTMLElement} elemento - Elemento del que se eliminarán los manejadores
         * @param {Map} eventosElemento - Mapa de eventos del elemento
         * @param {string} tipoEvento - Tipo de evento a eliminar
         */
        _eliminarTipoEvento(elemento, eventosElemento, tipoEvento) {
          if (!eventosElemento.has(tipoEvento)) {
            logger.debug(`No hay manejadores para el tipo de evento: ${tipoEvento}`);
            return;
          }
          
          const manejadores = eventosElemento.get(tipoEvento);
          const clave = this._generarClave(elemento);
          
          logger.debug(`Eliminando ${manejadores.length} manejadores para: ${clave} - ${tipoEvento}`);
          
          for (const { manejador, opciones } of manejadores) {
            try {
              elemento.removeEventListener(tipoEvento, manejador, opciones);
              logger.debug(`Manejador eliminado: ${clave} - ${tipoEvento}`);
            } catch (error) {
              logger.error(`Error al eliminar manejador: ${clave} - ${tipoEvento}`, error);
            }
          }
          
          eventosElemento.delete(tipoEvento);
        }
      };
      
      /**
       * Configura los manejadores de eventos de la interfaz de usuario
       */
      function configurarManejadoresUI() {
        // Manejador para el botón de GPS
        const gpsBtn = document.getElementById('gps-casa-btn');
        if (gpsBtn) {
          manejadoresEventos.agregar(gpsBtn, 'click', manejarClickGPS);
        }
        
        // Manejador para el botón de cambio de modo
        const botonCambioModo = document.getElementById('boton-cambio-modo');
        if (botonCambioModo) {
          manejadoresEventos.agregar(botonCambioModo, 'click', manejarCambioModo);
        }
        
        // Manejador para los botones de paradas/tramos
        manejadoresEventos.agregar(document, 'click', (event) => {
          const botonParada = event.target.closest('.parada-tramo-btn');
          if (botonParada) {
            const idPunto = botonParada.dataset.idPunto;
            if (idPunto) {
              manejarSeleccionPunto(idPunto);
            }
          }
        });
        
        // Manejador para cerrar la ventana de paradas al hacer clic fuera
        manejadoresEventos.agregar(document, 'click', (event) => {
          const zonaBoton = document.getElementById('zona-boton-casa');
          const ventanaParadas = document.getElementById('paradas-window');
          
          if (ventanaParadas && ventanaParadas.classList.contains('visible') && 
              zonaBoton && !zonaBoton.contains(event.target)) {
            ventanaParadas.classList.remove('visible');
          }
        });
        
        // Manejador para el evento personalizado de cambio de modo
        manejadoresEventos.agregar(document, 'modoCambiado', (event) => {
          const { modo } = event.detail || {};
          actualizarInterfazModo(modo);
        });
      }
      
      /**
       * Maneja el clic en el botón de GPS
       * @param {Event} event - Evento de clic
       */
      async function manejarClickGPS(event) {
        event.stopPropagation();
        
        try {
          const nuevoEstado = !estadoApp.gpsActivo;
          console.log(`[${CONFIG.IFRAME_ID}] Cambiando estado GPS a: ${nuevoEstado ? 'ACTIVO' : 'INACTIVO'}`);
          
          // Actualizar estado local
          await estadoApp.actualizarEstado({
            gpsActivo: nuevoEstado,
            ultimaAccion: nuevoEstado ? 'activar_gps' : 'desactivar_gps',
            timestamp: new Date().toISOString()
          });
          
          // Notificar al padre del cambio
          await notificarEstado('cambio_estado_gps', { 
            gpsActivo: nuevoEstado 
          });
          
          // Mostrar/ocultar ventana de paradas si está disponible
          const ventanaParadas = document.getElementById('paradas-window');
          if (ventanaParadas) {
            if (nuevoEstado) {
              ventanaParadas.classList.add('visible');
            } else {
              ventanaParadas.classList.remove('visible');
            }
          }
          
        } catch (error) {
          console.error(`[${CONFIG.IFRAME_ID}] Error al manejar clic en GPS:`, error);
          notificarError('error_gps', error);
        }
      }
      
      /**
       * Maneja la selección de un punto (parada o tramo)
       * @param {string} idPunto - ID del punto seleccionado
       */
      async function manejarSeleccionPunto(idPunto) {
        try {
          console.log(`[${CONFIG.IFRAME_ID}] Punto seleccionado:`, idPunto);
          
          // Validar ID del punto
          const validacionId = validarIdPunto(idPunto);
          if (!validacionId.valido) {
            throw new Error(validacionId.mensaje);
          }
          
          // Encontrar el punto en el array de puntosRuta
          const punto = puntosRuta.find(p => p.padreid === idPunto);
          if (!punto) {
            throw new Error(`No se encontró el punto con ID: ${idPunto}`);
          }
          
          // Validar la estructura del punto
          const validacionPunto = validarPunto(punto);
          if (!validacionPunto.valido) {
            throw new Error(`Punto inválido: ${validacionPunto.errores.join('; ')}`);
          }
          
          // Actualizar estado local
          const actualizacion = {
            puntoActual: punto,
            ultimaAccion: 'seleccion_punto',
            timestamp: new Date().toISOString()
          };
          
          // Actualizar según el tipo de punto
          if (punto.tipo === 'parada' || punto.parada !== undefined) {
            actualizacion.paradaActual = punto.parada;
          } else if (punto.tipo === 'tramo' || punto.tramo !== undefined) {
            actualizacion.tramoActual = punto.tramo;
          }
          
          await estadoApp.actualizarEstado(actualizacion);
          
          // Notificar al padre
          await notificarEstado('punto_seleccionado', { 
            tipo: punto.tipo,
            id: punto.padreid,
            nombre: punto.nombre,
            datosAdicionales: punto
          });
          
          // Resaltar el punto seleccionado
          document.querySelectorAll('.parada-tramo-btn').forEach(btn => {
            btn.classList.toggle('actual', btn.dataset.idPunto === idPunto);
          });
          
        } catch (error) {
          console.error(`[${CONFIG.IFRAME_ID}] Error al manejar selección de punto:`, error);
          notificarError('seleccion_punto', error);
        }
      }
      
      // Inicializar la aplicación cuando el DOM esté listo
      // ================== INICIALIZACIÓN ==================
      /**
       * Inicializa la aplicación
       * @returns {Promise<boolean>} True si la inicialización fue exitosa
       */
      /**
       * Inicializa la aplicación
       * @returns {Promise<boolean>} True si la inicialización fue exitosa
       */
      /**
       * Inicializa la aplicación
       * @returns {Promise<boolean>} True si la inicialización fue exitosa
       */
      async function inicializarAplicacion() {
        logger.info('Inicializando aplicación...');
        
        try {
          // Inicializar estado global
          window.CONFIG = CONFIG;
          window.estadoApp = estadoApp;
          
          // Configurar manejadores de eventos
          configurarManejadoresUI();
          
          // Inicializar componentes
          logger.debug('Inicializando componentes...');
          await Promise.all([
            inicializarMensajeriaApp(),
            registrarManejadores()
          ]);
          
          // Configurar estado inicial
          estadoApp = {
            ...estadoApp,
            ...CONFIG.ESTADO_INICIAL,
            inicializado: true
          };
          
          // Cargar estado inicial y actualizar la interfaz
          logger.debug('Cargando estado inicial...');
          await cargarEstado();
          actualizarInterfaz();
          
          // Notificar al padre que la aplicación está lista
          logger.debug('Notificando al padre que la aplicación está lista...');
          await notificarEstado('aplicacion_inicializada', {
            version: '1.0.0',
            timestamp: new Date().toISOString()
          });
          
          logger.info('Aplicación inicializada correctamente');
          return true;
          
        } catch (error) {
          const errorMsg = 'Error al inicializar la aplicación';
          console.error(errorMsg, error);
          await notificarError('inicializacion_aplicacion', error);
          mostrarError('Error al inicializar la aplicación. Por favor, recarga la página.');
          throw error;
        }
      }
      
      // Array completo de paradas y tramos con padreid añadido
      const puntosRuta = [
        { padreid: "padre-P-0", tipo: "inicio", parada: 0, nombre: "Torres de Serranos (start)" },
        { padreid: "padre-TR-1", tipo: "tramo", tramo: 1, nombre: "Torres de Serranos → Plaza de la crida (Puente de Serranos)" },
        { padreid: "padre-P-1", tipo: "parada", parada: 1, nombre: "Plaza de la crida (Puente de Serranos)" },
        { padreid: "padre-TR-2", tipo: "tramo", tramo: 2, nombre: "Plaza de la crida → Calle Muro de Santa Ana" },
        { padreid: "padre-P-2", tipo: "parada", parada: 2, nombre: "Calle Muro de Santa Ana" },
        { padreid: "padre-TR-3", tipo: "tramo", tramo: 3, nombre: "Calle Muro de Santa Ana → Palacio de los Borgia" },
        { padreid: "padre-P-3", tipo: "parada", parada: 3, nombre: "Iglesia de San Lorenzo" },
        { padreid: "padre-TR-4", tipo: "tramo", tramo: 4, nombre: "Iglesia de San Lorenzo → Plaza de la Virgen" },
        { padreid: "padre-P-4", tipo: "parada", parada: 4, nombre: "Plaza de la Virgen Reto 6" },
        { padreid: "padre-P-5", tipo: "parada", parada: 5, nombre: "Plaza de la Virgen Reto 7" },
        { padreid: "padre-TR-5", tipo: "tramo", tramo: 5, nombre: "Plaza de la Virgen → Plaza de la Almoína" },
        { padreid: "padre-P-6", tipo: "parada", parada: 6, nombre: "Panel cerámico muro Catedral" },
        { padreid: "padre-P-7", tipo: "parada", parada: 7, nombre: "Capilla exterior catedral Reto 10" },
        { padreid: "padre-P-8", tipo: "parada", parada: 8, nombre: "Capilla exterior catedral Reto 11" },
        { padreid: "padre-P-9", tipo: "parada", parada: 9, nombre: "Arco Novo Catedral y Puerta Negra Basílica" },
        { padreid: "padre-P-10", tipo: "parada", parada: 10, nombre: "Casa del Punt de Gantxo" },
        { padreid: "padre-TR-6", tipo: "tramo", tramo: 6, nombre: "Plaza de la Almoína → Plaza Decimo Junio Bruto (Museo Arqueológico de la Almoína)" },
        { padreid: "padre-P-11", tipo: "parada", parada: 11, nombre: "Museo arqueológico La Almoína" },
        { padreid: "padre-P-12", tipo: "parada", parada: 12, nombre: "Museo arqueológico La Almoína" },
        { padreid: "padre-P-13", tipo: "parada", parada: 13, nombre: "Vista de la Catedral, Cimborrio" },
        { padreid: "padre-TR-7", tipo: "tramo", tramo: 7, nombre: "Museo arqueológico La Almoína → Palacio Arzobispal" },
        { padreid: "padre-P-14", tipo: "parada", parada: 14, nombre: "Palacio Arzobispal y Puerta Románica de la Catedral" },
        { padreid: "padre-P-15", tipo: "parada", parada: 15, nombre: "Puerta Románica de la Catedral" },
        { padreid: "padre-TR-8", tipo: "tramo", tramo: 8, nombre: "Puerta Románica de la Catedral → Plaza del Ayuntamiento" },
        { padreid: "padre-P-16", tipo: "parada", parada: 16, nombre: "Plaza del Ayuntamiento" },
        { padreid: "padre-TR-9", tipo: "tramo", tramo: 9, nombre: "Plaza del Ayuntamiento → Edificio del Ayuntamiento de València" },
        { padreid: "padre-P-17", tipo: "parada", parada: 17, nombre: "Edificio del Ayuntamiento" },
        { padreid: "padre-P-18", tipo: "parada", parada: 18, nombre: "Edificio del Ayuntamiento" },
        { padreid: "padre-TR-10", tipo: "tramo", tramo: 10, nombre: "Edificio del Ayuntamiento → Estación del Norte" },
        { padreid: "padre-P-19", tipo: "parada", parada: 19, nombre: "Estación del Norte" },
        { padreid: "padre-TR-11", tipo: "tramo", tramo: 11, nombre: "Estación del Norte → Plaza de Toros de València" },
        { padreid: "padre-TR-12", tipo: "tramo", tramo: 12, nombre: "Plaza de Toros → Casa estilo Árabe" },
        { padreid: "padre-P-20", tipo: "parada", parada: 20, nombre: "Casa estilo Árabe" },
        { padreid: "padre-P-21", tipo: "parada", parada: 21, nombre: "Casa estilo Árabe, mitad Aventura" },
        { padreid: "padre-TR-13", tipo: "tramo", tramo: 13, nombre: "Casa estilo Árabe → Palacio de Comunicaciones (Correos)" },
        { padreid: "padre-P-22", tipo: "parada", parada: 22, nombre: "Palacio de Comunicaciones: Correos" },
        { padreid: "padre-P-23", tipo: "parada", parada: 23, nombre: "Edificio Suay" },
        { padreid: "padre-TR-14", tipo: "tramo", tramo: 14, nombre: "Palacio de Comunicaciones → Banco de València" },
        { padreid: "padre-P-24", tipo: "parada", parada: 24, nombre: "Banco de Valencia" },
        { padreid: "padre-TR-15", tipo: "tramo", tramo: 15, nombre: "Banco de València → Palacio del Marqués de Dos Aguas (Museo Nacional de Cerámica)" },
        { padreid: "padre-P-25", tipo: "parada", parada: 25, nombre: "Palacio del Marqués de Dos Aguas (Museo Nacional de Cerámica)" },
        { padreid: "padre-TR-16", tipo: "tramo", tramo: 16, nombre: "Palacio del Marqués → Mercado Central" },
        { padreid: "padre-P-26", tipo: "parada", parada: 26, nombre: "Mercado central" },
        { padreid: "padre-TR-17", tipo: "tramo", tramo: 17, nombre: "Mercado Central → Lonja de la Seda" },
        { padreid: "padre-P-27", tipo: "parada", parada: 27, nombre: "Lonja de la Seda" },
        { padreid: "padre-TR-18", tipo: "tramo", tramo: 18, nombre: "Lonja de la Seda → Plaza Redonda" },
        { padreid: "padre-P-28", tipo: "parada", parada: 28, nombre: "Plaza Redonda" },
        { padreid: "padre-TR-19", tipo: "tramo", tramo: 19, nombre: "Plaza Redonda → Iglesia de los Santos Juanes" },
        { padreid: "padre-P-29", tipo: "parada", parada: 29, nombre: "Iglesia de los Santos Juanes" },
        { padreid: "padre-TR-20", tipo: "tramo", tramo: 20, nombre: "Iglesia de los Santos Juanes → Mercado Central" },
        { padreid: "padre-TR-21", tipo: "tramo", tramo: 21, nombre: "Mercado Central → Palacio de la Generalitat" },
        { padreid: "padre-P-30", tipo: "parada", parada: 30, nombre: "Palau de la Generalitat" },
        { padreid: "padre-TR-22", tipo: "tramo", tramo: 22, nombre: "Palacio de la Generalitat → Torres de Serranos (Final)" },
        { padreid: "padre-P-31", tipo: "parada", parada: 31, nombre: "Torres de Serranos (Final)" }
      ];

      /**
       * Carga el estado inicial de la aplicación
       * @returns {Promise<void>}
       */
      async function cargarEstado() {
        try {
          // 1. Cargar datos de la ruta
          logger.debug('Cargando datos de la ruta...');
          // ... (código para cargar datos de la ruta)
          
          // 2. Cargar preferencias del usuario
          logger.debug('Cargando preferencias del usuario...');
          // ... (código para cargar preferencias)
          
          // 3. Actualizar el estado de la aplicación
          logger.debug('Actualizando estado de la aplicación...');
          // ... (código para actualizar el estado)
          
          logger.info('Estado inicial cargado correctamente');
          
        } catch (error) {
          const errorMsg = 'Error al cargar el estado';
          console.error(errorMsg, error);
          await notificarError('carga_estado', error);
          throw error; // Relanzar para que el llamador pueda manejarlo
        }
      }

      // Inicializar la aplicación cuando el DOM esté listo
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          inicializarAplicacion().catch(error => {
            logger.error('Error crítico durante la inicialización', error);
          });
        });
      } else {
        // Si el DOM ya está listo, inicializar de inmediato
        inicializarAplicacion().catch(error => {
          logger.error('Error crítico durante la inicialización', error);
        });
      }
      
      // Limpiar manejadores de eventos cuando se desmonte el iframe
      window.addEventListener('beforeunload', () => {
        if (typeof manejadoresEventos !== 'undefined' && typeof manejadoresEventos.limpiarTodo === 'function') {
          logger.debug('Limpiando manejadores de eventos...');
          
          try {
            manejadoresEventos.limpiarTodo();
            logger.info('Limpieza de manejadores de eventos completada');
          } catch (error) {
            logger.error('Error al limpiar manejadores de eventos', error);
          }
        }
      });
      
      // Configurar manejador de eventos para el botón GPS
      document.addEventListener('click', async (e) => {
        const gpsBtn = e.target.closest('#gps-casa-btn');
        if (gpsBtn) {
          e.preventDefault();
          e.stopPropagation();
          
          // Determinar el nuevo modo (alternar entre 'ruta' y 'casa')
          const nuevoModo = estadoApp.modo === 'ruta' ? 'casa' : 'ruta';
          
          try {
            // Enviar mensaje de cambio de modo al padre
            await enviarMensaje('padre', TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO, {
              modo: nuevoModo,
              origen: CONFIG.IFRAME_ID,
              timestamp: Date.now(),
              motivo: 'click_usuario'
            });
            
            // Si estamos cambiando a modo 'casa', desactivar el GPS si está activo
            if (nuevoModo === 'casa' && estadoApp.gpsActivo) {
              await enviarMensaje('padre', TIPOS_MENSAJE.GPS.COMANDO, {
                accion: 'desactivar',
                origen: CONFIG.IFRAME_ID
              });
              actualizarEstado({ gpsActivo: false });
            }
            
            // Actualizar estado local
            actualizarEstado({ modo: nuevoModo });
            actualizarInterfaz();
            
            logger.info(`Modo cambiado a: ${nuevoModo}`);
          } catch (error) {
            console.error(`[${CONFIG.IFRAME_ID}] Error al cambiar el modo:`, error);
            notificarError('cambio_modo', error);
          }
        }
      });
      
      // ...existing code...
    </script>
    <style>
    /* Contenedor principal */
    #zona-boton-casa {
      position: relative;
      width: 100%;
      height: 60px;
    }
    
    /* Botón GPS: medidas y estilos del primer código */
    #gps-casa-btn {
      position: absolute;
      top: 5px;
      left: 5px;
      width: 50px;
      height: 50px;
      min-width: 50px;
      min-height: 50px;
      border-radius: 4px;
      border: 1px solid #fff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      padding: 0;
      margin: 0 0 0 10px;
      position: relative;
      z-index: 10002;
      cursor: pointer;
      font-size: 16px;
      /* Estado inicial (OFF) */
      background-color: #f44336;
      border-color: #d32f2f;
    }
    
    /* Estado ON - Verde */
    #gps-casa-btn.on {
      background-color: #4CAF50 !important;
      border-color: #45a049 !important;
    }
    
    /* Estado OFF - Rojo */
    #gps-casa-btn.off {
      background-color: #f44336 !important;
      border-color: #d32f2f !important;
    }
    #gps-casa-btn:hover {
      opacity: 0.9;
      transform: scale(1.05);
    }
    #gps-casa-btn:active {
      transform: scale(0.95);
    }
    .button-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      line-height: 1;
    }
    .satellite-emoji {
      font-size: 35px;
      line-height: 1;
      margin-bottom: 2px;
      display: block;
    }
    .gps-label {
      font-size: 20px;
      font-weight: bold;
      line-height: 1;
      margin: 0;
      padding: 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    /* Ventana de paradas: estética y medidas del segundo código */
    #paradas-window {
      position: absolute;
      top: 0;
      left: 75px; 
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      display: none; /* Se controla desde JavaScript */
      padding: 0;
      border: 1px solid #e0e0e0;
      max-width: 300px;
      min-width: 250px;
      z-index: 10003;
      height: 60px; /* Altura total: 50px botón + 10px margen inferior */
      overflow: visible;
      padding-bottom: 1px; /* 1px de espacio debajo de la barra */
      /* Asegurar que no haya transiciones que interfieran */
      transition: none !important;
      /* Asegurar que no haya estilos en línea que sobrescriban */
      opacity: 1 !important;
      visibility: visible !important;
    }
    /* Clase para mostrar/ocultar la ventana */
    #paradas-window.visible {
      display: flex !important;
    }
    #paradas-window.hidden {
      display: none !important;
    }
    #paradas-list {
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap;
      padding: 8px 12px;
      margin: 0;
      overflow-x: auto;
      overflow-y: hidden;
      height: 100%;
      box-sizing: border-box;
      align-items: center;
      white-space: nowrap;
      -webkit-overflow-scrolling: touch;
      gap: 8px;
      scrollbar-width: thin;
      scrollbar-color: #888 #f1f1f1;
      align-content: center;
    }
    
    /* Estilo para la barra de desplazamiento en WebKit (Chrome, Safari) */
    #paradas-list::-webkit-scrollbar {
      height: 5px;
    }
    
    #paradas-list::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    #paradas-list::-webkit-scrollbar-thumb {
      background: #888;
      border-radius: 3px;
    }
    
    #paradas-list::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    
    /* Hide scrollbar for Webkit browsers */
    #paradas-list::-webkit-scrollbar {
      display: none;
    }
    .parada-tramo-btn {
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 4px 8px;
      margin: 0 2px;
      cursor: pointer;
      font-size: 14px;
      display: inline-block;
      height: 50px;
      white-space: nowrap;
      width: auto;
      min-width: max-content;
    }
    
    .btn-content {
      display: inline-block;
      white-space: nowrap;
    }
    
    .btn-icon {
      margin-right: 4px;
    }
    .parada-btn {
      background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
      color: white;
      min-width: max-content;
      padding: 4px 8px;
      border: none !important;
    }
    .tramo-btn {
      background: linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%);
      color: white;
      border: none !important;
    }
    .inicio-btn {
      background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
      color: white;
      border: none !important;
    }
    .parada-tramo-btn.actual {
      border: 2px solid #ffd700 !important;
      box-shadow: 0 0 0 2px #ffd700, 0 0 15px rgba(255, 215, 0, 0.7) !important;
      transform: scale(1.05);
      font-weight: bold;
      z-index: 2;
      position: relative;
    }
    .btn-icon {
      font-size: 1.5em;
      flex-shrink: 0;
    }
    .btn-title {
      font-weight: 600;
      white-space: nowrap;
      font-size: 0.95em;
      margin-bottom: 2px;
    }
    .btn-desc {
      font-size: 0.85em;
      opacity: 0.9;
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      max-width: 130px;
      font-weight: 500;
      line-height: 1.2;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2; /* Standard property */
      -webkit-box-orient: vertical;
      text-align: left;
      position: relative;
    }
    
    /* Fallback for Firefox */
    @supports (-moz-appearance: none) {
      .btn-desc {
        display: -moz-box;
        -moz-box-orient: vertical;
      }
    }
    
    /* Estilos para la ventana de paradas */
    #paradas-window {
      position: absolute;
      top: 0;
      left: 60px; /* Alinear con el borde derecho del botón */
      width: 300px; /* Ancho fijo para la ventana */
      background: white;
      border: 1px solid #ddd;
      border-radius: 0 4px 4px 0;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      max-height: 400px;
      overflow-y: auto;
      display: none; /* Inicialmente oculto */
    }
    
    #paradas-list {
      padding: 10px;
    }
    
    /* Asegurar que el contenedor principal tenga posición relativa */
    #zona-boton-casa {
      position: relative;
      display: inline-block;
    }
    
    .parada-tramo-btn {
      display: block;
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      text-align: left;
      border: 1px solid #eee;
      border-radius: 4px;
      background-color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .parada-tramo-btn:hover {
      background-color: #f5f5f5;
    }
    
    .parada-btn {
      border-left: 4px solid #4CAF50;
    }
    
    .tramo-btn {
      border-left: 4px solid #2196F3;
    }
    
    .inicio-btn {
      border-left: 4px solid #FF9800;
    }
    
    .actual {
      font-weight: bold;
      background-color: #e3f2fd;
    }
    
    .badge {
      float: right;
      background-color: #4CAF50;
      color: white;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 0.8em;
    }
  </style>
</head>
<body>
  <div id="zona-boton-casa">
    <button id="gps-casa-btn" class="on" title="Activar GPS" aria-label="Activar GPS">
      <span class="button-content">
        <span class="satellite-emoji">📡</span>
        <span class="gps-label">ON</span>
      </span>
    </button>
    <div id="paradas-container" class="paradas-container">
      <!-- Las paradas y tramos se agregarán aquí dinámicamente -->
    </div>
    <div id="paradas-window">
      <div id="paradas-list"></div>
    </div>
  </div>
  <script>
    // Código de inicialización de la aplicación
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        if (typeof window.mensajeriaInicializada === 'undefined') {
          logger.info('Inicializando sistema de mensajería...');
          await inicializarMensajeria({
            iframeId: CONFIG.IFRAME_ID,
            debug: CONFIG.DEBUG,
            logLevel: CONFIG.LOG_LEVEL
          });
          window.mensajeriaInicializada = true;
          logger.info('Sistema de mensajería inicializado correctamente');
        } else {
          logger.info('El sistema de mensajería ya está inicializado');
        }
      } catch (error) {
        logger.error('Error al inicializar el sistema de mensajería:', error);
        throw new Error(`Error al inicializar el sistema de mensajería: ${error.message}`);
      }
    });
  </script>
</body>
</html>
