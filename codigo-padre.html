<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Aventura 1 - Padre</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='.9em' font-size='90'%3Eüó∫Ô∏è%3C/text%3E%3C/svg%3E">

    <!-- Carga de Leaflet desde CDN con Integrity y Crossorigin -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
            crossorigin=""></script>
    
    <!-- Script para verificar que Leaflet est√° cargado -->
    <script>
        window.addEventListener('load', function() {
            if (typeof L === 'undefined') {
                console.error('‚ùå Leaflet no se ha cargado correctamente. L no est√° definido en window.');
            } else {
                console.log('‚úÖ Leaflet cargado correctamente:', L.version);
            }
        });
    </script>

    <style>
        /* Estilos generales, mapa, debug, logo, iframes, etc. */
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; background: transparent; }
        iframe { background: transparent; border: none; }
        #mapa { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100vw; 
            height: 100vh; 
            z-index: 10; /* Aumentado para asegurar que est√° por encima de otros elementos */
            background-color: #f5f5f5;
            border: 1px solid #ccc;
            visibility: visible !important;
            opacity: 1 !important;
            display: block !important;
            pointer-events: auto !important; /* Ensure map receives mouse events */
            overflow: visible !important; /* Ensure map content is visible */
        }
        /* Asegurar que los contenedores de Leaflet sean visibles */
        .leaflet-container {
            width: 100% !important;
            height: 100% !important;
            z-index: 10 !important;
            visibility: visible !important;
            opacity: 1 !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            background: white !important;
        }
        .leaflet-tile-container {
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 200 !important;
        }
        .leaflet-tile {
            visibility: visible !important;
            opacity: 1 !important;
        }
        .leaflet-map-pane,
        .leaflet-overlay-pane,
        .leaflet-marker-pane,
        .leaflet-shadow-pane,
        .leaflet-tooltip-pane,
        .leaflet-popup-pane {
            z-index: auto !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        #map-debug { position: fixed; top: 10px; left: 10px; background: rgba(255, 255, 255, 0.9); padding: 5px 8px; border-radius: 5px; z-index: 5000; font-size: 12px; font-family: monospace; display: none; transition: opacity 0.5s; }
        #logo-aventura { position: fixed; top: -13px; left: 50%; transform: translateX(-50%); width: 190px; height: 140px; z-index: 3000; object-fit: contain; }
        #fondo-blanco { position: fixed; top: -24px; left: 50%; transform: translateX(-50%); width: 210px; height: 150px; z-index: 2999; background: white; border-bottom-left-radius: 24px; border-bottom-right-radius: 24px; }
        #info-parada { font-weight: bold; margin: 0; padding: 7px 12px; background-color: rgba(255, 255, 255, 0.9); border-radius: 7px; position: fixed; left: 50%; transform: translateX(-50%); z-index: 1201; display: none; color: #333; font-family: sans-serif; text-align: center; bottom: 325px; min-width: 220px; max-width: 90vw; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.10); }
        #hijo4 { position: fixed; top: 10vh; left: 50%; width: 60vw; height: 40vh; transform: translateX(-50%); z-index: 2000; border: 2px solid red; background: transparent; pointer-events: auto; display: none; }
        #media-overlay { display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); z-index: 4000; justify-content: center; align-items: center; backdrop-filter: blur(5px); }
        #media-container { max-width: 90%; max-height: 90%; display: flex; flex-direction: column; align-items: center; position: relative; }
        #close-media { position: absolute; top: 10px; right: 10px; background: #ff5252; color: white; border: none; border-radius: 50%; width: 35px; height: 35px; font-size: 1.2em; cursor: pointer; z-index: 4001; display: flex; justify-content: center; align-items: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        #parada-video, #parada-imagen { max-width: 100%; max-height: calc(100vh - 80px); display: none; border-radius: 5px; }
    </style>

    <!-- Cargar m√≥dulos ES -->
    <script type="module">
    // 1. Configuraci√≥n global de manejo de errores
    window.handleIframeError = function(iframeId, event) {
        const errorMsg = `Error loading ${iframeId}`;
        console.error(errorMsg, event);
        // Si el logger est√° disponible, usarlo tambi√©n
        if (window.logger?.error) {
            window.logger.error(errorMsg, event);
        }
    };
    
    window.handleIframeLoad = function(iframeId) {
        const msg = `${iframeId} loaded successfully`;
        console.debug(msg);
        if (window.logger?.debug) {
            window.logger.debug(msg);
        }
    };

    // 2. Funci√≥n de inicializaci√≥n as√≠ncrona
    async function initializeApp() {
        try {
            console.log('Iniciando aplicaci√≥n...');
            
            // Importar din√°micamente la aplicaci√≥n
            const { inicializar } = await import('./js/app.js');
            
            // Inicializar la aplicaci√≥n
            await inicializar();
            
            console.log('Aplicaci√≥n inicializada correctamente');
            
        } catch (error) {
            console.error('Error cr√≠tico al inicializar la aplicaci√≥n:', error);
            // Mostrar mensaje de error en la interfaz
            const errorDiv = document.createElement('div');
            errorDiv.style.position = 'fixed';
            errorDiv.style.top = '0';
            errorDiv.style.left = '0';
            errorDiv.style.right = '0';
            errorDiv.style.background = '#ffebee';
            errorDiv.style.color = '#c62828';
            errorDiv.style.padding = '1rem';
            errorDiv.style.zIndex = '9999';
            errorDiv.style.fontFamily = 'Arial, sans-serif';
            errorDiv.style.fontSize = '14px';
            errorDiv.style.whiteSpace = 'pre';
            errorDiv.style.overflow = 'auto';
            errorDiv.style.maxHeight = '50vh';
            errorDiv.textContent = `Error al inicializar la aplicaci√≥n:\n\n${error.message}\n\n${error.stack || ''}`;
            document.body.prepend(errorDiv);
        }
    }

    // 3. Inicializar cuando el DOM est√© listo
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp();
    }
    </script>
</head>
<body>
    <!-- Debug overlay -->
    <div id="debug-overlay" style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; z-index: 9999; max-width: 300px; max-height: 80vh; overflow: auto; font-family: monospace; font-size: 12px;">
        <h3 style="margin: 0 0 10px 0;">Debug Info</h3>
        <div id="debug-content">Initializing...</div>
    </div>
    
    <script>
    // Debug logging function
    function debugLog(message, data) {
        const now = new Date().toISOString().substr(11, 12);
        const logLine = document.createElement('div');
        logLine.textContent = `[${now}] ${message}`;
        if (data) {
            try {
                logLine.textContent += ' ' + JSON.stringify(data);
            } catch (e) {
                logLine.textContent += ' [Object]';
            }
        }
        const debugContent = document.getElementById('debug-content');
        debugContent.prepend(logLine);
        console.log(`[DEBUG] ${message}`, data || '');
    }
    
    // Make it globally available
    window.debugLog = debugLog;
    
    // Log initial load
    debugLog('Parent page loading...');
    </script>
    <!-- Script para verificar Leaflet despu√©s de cargar DOM y crear mapa directo si es necesario -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üîç DOM completamente cargado, verificando Leaflet...');
            if (typeof L === 'undefined') {
                console.error('‚ùå ERROR: Leaflet (L) no est√° definido en DOMContentLoaded');
                document.getElementById('map-debug').textContent = 'ERROR: Leaflet no est√° disponible';
                document.getElementById('map-debug').style.display = 'block';
                document.getElementById('map-debug').style.color = 'red';
                document.getElementById('map-debug').style.backgroundColor = 'white';
                document.getElementById('map-debug').style.padding = '10px';
            } else {
                console.log('‚úÖ Leaflet disponible en DOMContentLoaded, versi√≥n:', L.version);
                
                // Reemplazar con la inicializaci√≥n adecuada del mapa
                async function initializeMap() {
                    try {
                        const mapContainer = document.getElementById('mapa');
                        
                        // Asegurarse de que el contenedor est√© correctamente visible y dimensionado
                        if (mapContainer) {
                            mapContainer.style.width = '100%';
                            mapContainer.style.height = '100%';
                            mapContainer.style.display = 'block';
                            mapContainer.style.position = 'relative';
                            mapContainer.style.zIndex = '1';
                        }
                        
                        // Limpiar cualquier instancia de mapa existente para evitar duplicados
                        if (window.mapa && typeof window.mapa.remove === 'function') {
                            console.log('Removing existing map instance');
                            window.mapa.remove();
                            window.mapa = null;
                        }
                        
                        // Crear el mapa con opciones expl√≠citas para asegurar una inicializaci√≥n correcta
                        console.log('Creating new Leaflet map instance');
                        window.mapa = L.map('mapa', {
                            center: [39.4699, -0.3763], // Valencia
                            zoom: 16,
                            minZoom: 12,
                            maxZoom: 18,
                            zoomControl: true,
                            attributionControl: true
                        });
                        
                        // A√±adir capa de mosaico de OpenStreetMap
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                            maxZoom: 19,
                            tileSize: 256
                        }).addTo(window.mapa);
                        
                        // Verificar que el mapa se haya inicializado correctamente
                        if (typeof window.mapa.getCenter === 'function') {
                            console.log('‚úÖ Map initialized successfully at center:', window.mapa.getCenter());
                            return true;
                        } else {
                            console.error('‚ùå Map initialization failed - map methods not available');
                            return false;
                        }
                    } catch (error) {
                        console.error('‚ùå Error initializing map:', error);
                        return false;
                    }
                }

                // Reemplazar el c√≥digo de inicializaci√≥n del mapa en su flujo de inicializaci√≥n principal
                async function initializeApp() {
                    // ...c√≥digo existente...
                    
                    // Reemplazar la inicializaci√≥n del mapa con nuestra nueva funci√≥n
                    const mapInitialized = await initializeMap();
                    if (mapInitialized) {
                        console.log('Map component initialized successfully');
                    } else {
                        console.warn('Map initialization failed, application may have limited functionality');
                    }
                    
                    // ...c√≥digo existente...
                }

                // Iniciar la aplicaci√≥n
                initializeApp();
            }
        });
    </script>
    
    <!-- Contenedores de la UI -->
    <div id="mapa"></div>
    <div id="map-debug"></div>
    <iframe id="fondo-blanco" tabindex="-1" aria-hidden="true"></iframe>
    <img id="logo-aventura" src="fotos_Av1/LOGO LETRAS FINAL transparente recorte.png" alt="Logo" />
    <div id="info-parada"></div>

    <!-- IFrames de los Hijos -->
    <iframe id="hijo1-hamburguesa" src="botones-y-subfunciones-hamburguesa.html"
        title="Men√∫ Hamburguesa"
        aria-label="Men√∫ de navegaci√≥n hamburguesa"
        style="position:fixed; left:1vw; bottom:0vw; height: 290px; width:60px; z-index:1005; pointer-events:auto;"
        onerror="handleIframeError('hijo1-hamburguesa', event)"></iframe>
    <iframe id="hijo1-opciones" src="botones-y-subfunciones-opciones.html"
        title="Opciones de usuario"
        aria-label="Opciones y configuraci√≥n"
        style="position:fixed; right:1vw; bottom:0vw; height: 290px; width:60px; z-index:1005; pointer-events:auto;"
        onerror="handleIframeError('hijo1-opciones', event)"></iframe>
    <iframe id="hijo5-casa" src="Av1-boton-casa.html"
        title="Bot√≥n Casa"
        aria-label="Bot√≥n para cambiar entre modo Casa y Aventura"
        style="position:fixed; left:10px; top:10px; height:100px; width:350px; z-index:1005; pointer-events:auto; transition:width 0.3s; display:block;"
        onload="handleIframeLoad('hijo5-casa'); if(window.debugLog) window.debugLog('hijo5-casa iframe loaded');" 
        onerror="handleIframeError('hijo5-casa', event)"></iframe>
    <iframe id="hijo3" src="Av1_audio_esp.html"
        title="Audio de la aventura"
        aria-label="Reproductor de audio de la aventura"
        style="position:fixed; bottom:-6px; left:50%; transform:translateX(-50%); height:165px; width:310px; z-index:1000; display:block; pointer-events:auto;"
        onerror="handleIframeError('hijo3-audio', event)"></iframe>
    <iframe id="hijo2" src="Av1-botones-coordenadas.html"
        title="Botones de coordenadas"
        aria-label="Botones de navegaci√≥n y coordenadas"
        style="position:fixed; bottom:151px; left:50%; transform:translateX(-50%); height:165px; width:310px; z-index:1001; pointer-events:auto; display:block;"
        allow="geolocation" onerror="handleIframeError('hijo2-coordenadas', event)"></iframe>
    <iframe id="hijo4" src="Av1-esp-retos-preguntas.html"
        title="Retos y preguntas"
        aria-label="Ventana de retos y preguntas"
        style="display:none;" onload="handleIframeLoad('hijo4-retos')" onerror="handleIframeError('hijo4-retos', event)"></iframe>

    <!-- Overlay para Media -->
    <div id="media-overlay">
        <div id="media-container">
            <button id="close-media">X</button>
            <video id="parada-video" controls></video>
            <img id="parada-imagen">
        </div>
    </div>

    <!-- SCRIPT PRINCIPAL UNIFICADO DE LA APLICACI√ìN -->
    <script type="module">
    // Log module initialization
    window.debugLog('ES Module initializing...');
    
    // Configurar manejador global de errores no capturados
    window.addEventListener('error', (event) => {
        console.error('Error no capturado:', event.error || event.message, event);
        window.debugLog && window.debugLog(`Error no capturado: ${event.error || event.message}`);
    });

    // Configurar manejador para promesas no manejadas
    window.addEventListener('unhandledrejection', (event) => {
        console.error('Promesa rechazada no manejada:', event.reason);
        window.debugLog && window.debugLog(`Promesa rechazada: ${event.reason}`);
    });

    // Mejorar el sistema de mensajer√≠a con mejor logging y validaci√≥n
    window.validateMessageFormat = function(msg, source) {
        if (!msg) return false;
        
        // Filtrar mensajes de extensiones externas como Grammarly
        if (msg && (msg.__grammarly || msg._grammarly || msg.grammarly_report || msg.ext_id || msg.extension_id)) {
            console.debug('[Mensajer√≠a] Ignorando mensaje de extensi√≥n externa');
            return false;
        }
        
        // Verificar estructura b√°sica
        if (typeof msg !== 'object') {
            console.warn(`[Mensajer√≠a] Mensaje recibido de ${source || 'desconocido'} no es un objeto:`, msg);
            return false;
        }
        
        // Verificar campos requeridos
        const requiredFields = ['tipo', 'datos'];
        const missingFields = requiredFields.filter(field => !msg.hasOwnProperty(field));
        
        if (missingFields.length > 0) {
            console.warn(`[Mensajer√≠a] Mensaje de ${source || 'desconocido'} con campos requeridos faltantes: ${missingFields.join(', ')}`, msg);
            return false;
        }
        
        return true;
    };

    // Definir primero algunas funciones globales cr√≠ticas
    window.updateMapDebug = function(mensaje) {
        const debugElement = document.getElementById('map-debug');
        if (debugElement) {
            debugElement.textContent = mensaje;
            debugElement.style.display = 'block';
            
            // Ocultar autom√°ticamente despu√©s de unos segundos si no es un mensaje de error
            if (!mensaje.toLowerCase().includes('error')) {
                setTimeout(() => {
                    debugElement.style.opacity = '0';
                    setTimeout(() => {
                        debugElement.style.display = 'none';
                        debugElement.style.opacity = '1';
                    }, 500);
                }, 3000);
            }
        }
        
        // Registrar tambi√©n en la consola
        console.debug('[Map Debug]', mensaje);
    };
    
    // Variable global para rastrear inicializaci√≥n
    window.appInitStatus = {
        started: false,
        completed: false,
        errors: [],
        modules: {},
        timestamp: Date.now()
    };
    
    // Verificamos si ya se ha iniciado la aplicaci√≥n para evitar inicializaciones m√∫ltiples
    if (!window.appInitialized) { // Cambiado a negaci√≥n para evitar return en m√≥dulo de nivel superior
        // Marcar como inicializado
        window.appInitialized = true;
    } else {
        console.warn('‚ö†Ô∏è [PADRE] La aplicaci√≥n ya fue inicializada anteriormente. Evitando inicializaci√≥n duplicada.');
        // No usar return, solo continuamos pero no ejecutaremos el c√≥digo de inicializaci√≥n de nuevo
        window.appInitStatus.duplicateInitAttempt = true;
        window.debugLog && window.debugLog('Se detect√≥ un intento de inicializaci√≥n duplicada');
    }
    
    // Validar que no tengamos m√∫ltiples ejecuciones
    if (window.appInitStatus && window.appInitStatus.iifePrincipalIniciada) {
        console.warn('‚ö†Ô∏è [PADRE] La funci√≥n principal IIFE ya se ha iniciado anteriormente');
        // No usamos return aqu√≠, ya que estamos en un contexto de m√≥dulo de nivel superior
        window.appInitStatus.abortInitialization = true;
    }
    
    // Definir funci√≥n de utilidad para manejo centralizado de errores
    window.handleApplicationError = function(error, phase) {
        console.error(`‚ùå [PADRE] Error en ${phase || 'fase desconocida'}:`, error);
        if (window.debugLog) window.debugLog(`Error cr√≠tico en ${phase || 'aplicaci√≥n'}: ${error.message}`);
        if (window.updateMapDebug) window.updateMapDebug(`Error: ${error.message}`);
    };
    
    // IIFE principal con estructura simplificada
    (async () => {
        try {
            // Verificar si debemos abortar la inicializaci√≥n
            if (window.appInitStatus && window.appInitStatus.abortInitialization) {
                console.warn('‚ö†Ô∏è [PADRE] Abortando inicializaci√≥n debido a inicializaci√≥n previa');
                return; // Es seguro usar return dentro de la funci√≥n IIFE
            }
            
            // Marcar el inicio de la inicializaci√≥n
            window.appInitStatus = window.appInitStatus || {};
            window.appInitStatus.iifePrincipalIniciada = true;
            window.appInitStatus.startTimestamp = Date.now();
            window.appInitStatus.initStarted = true;
                
            console.log('üîç [PADRE] IIFE principal iniciada - Timestamp:', window.appInitStatus.startTimestamp);
            console.log('üöÄ [PADRE] Comenzando inicializaci√≥n de la aplicaci√≥n...');
            window.debugLog && window.debugLog('Inicializando aplicaci√≥n...');
            window.appInitStatus.started = true;
            window.updateMapDebug && window.updateMapDebug('Iniciando carga de m√≥dulos principales...');
            
            // Importar m√≥dulos
            window.debugLog('Importando m√≥dulos...');
            
            // Verificar que no haya imports previos
            if (window.appModulesLoaded) {
                console.warn('‚ö†Ô∏è [PADRE] Los m√≥dulos ya fueron importados anteriormente');
            } else {
                console.log('üì¶ [PADRE] Importando m√≥dulos por primera vez...');
                window.appModulesLoaded = true;
            }
                // FIX: Import modules individually to avoid naming conflicts
                const appModule = await import('./js/app.js');
                console.log('‚úÖ [PADRE] M√≥dulo app.js cargado');
                const mapaModule = await import('./js/funciones-mapa.js');
                console.log('‚úÖ [PADRE] M√≥dulo funciones-mapa.js cargado');
                const mensajeriaModule = await import('./js/mensajeria.js');
                console.log('‚úÖ [PADRE] M√≥dulo mensajeria.js cargado');
                const constantsModule = await import('./js/constants.js');
                console.log('‚úÖ [PADRE] M√≥dulo constants.js cargado');
                const configModule = await import('./js/config.js');
                console.log('‚úÖ [PADRE] M√≥dulo config.js cargado');
                const loggerModule = await import('./js/logger.js');
                console.log('‚úÖ [PADRE] M√≥dulo logger.js cargado');
                
                // Destructure with aliases to avoid naming conflicts
                const { 
                    estado: appEstado,
                    notificarError,
                    enviarCambioModo
                } = appModule;
            
                const {
                    inicializarMapa,
                    inicializarModuloMapa
                } = mapaModule;
                
                const {
                    inicializarMensajeria,
                    registrarControlador,
                    enviarMensaje
                } = mensajeriaModule;
                
                const { TIPOS_MENSAJE } = constantsModule;
                const { CONFIG } = configModule;
                const logger = loggerModule.default; // FIX: Get logger properly
            
                // Make available globally
                window.logger = logger; // FIX: Make logger available globally
                
                // Usar HIJOS de la configuraci√≥n centralizada
                const { HIJOS } = CONFIG;
                
                const MAP_CONFIG = {
                    center: [39.4699, -0.3763], zoom: 13, minZoom: 12, maxZoom: 18, zoomControl: false
                };

                // FIX: Use the imported state rather than creating a duplicate
                const estadoApp = appEstado;
                window.estadoApp = estadoApp;
            
            // Definir funciones de utilidad globalmente
            window.ocultarMedios = function() {
                const mediaOverlay = document.getElementById('media-overlay');
                const videoElement = document.getElementById('parada-video');
                
                if (mediaOverlay) {
                    mediaOverlay.style.display = 'none';
                }
                
                if (videoElement) {
                    videoElement.pause();
                    videoElement.currentTime = 0;
                }
            };
            
            // Agregar nueva utilidad para promesas con timeout
            window.createTimeoutPromise = function(ms, message) {
                return new Promise((_, reject) => {
                    setTimeout(() => reject(new Error(message || `Operaci√≥n excedi√≥ el l√≠mite de tiempo (${ms}ms)`)), ms);
                });
            };
            
            // Agregar funci√≥n para ejecutar con timeout
            window.executeWithTimeout = async function(promise, timeoutMs, errorMessage) {
                return Promise.race([
                    promise,
                    window.createTimeoutPromise(timeoutMs, errorMessage)
                ]);
            };

            // 3. DATOS DE LA AVENTURA
            const AVENTURA_PARADAS = [
                { padreid: "padre-P-0", tipo: "inicio", parada_id: 'P-0', audio_id: "audio-P-0", reto_id: "R-2" },
                { padreid: "padre-TR-1", tipo: "tramo", tramo_id: 'TR-1', audio_id: "audio-TR-1" },
                { padreid: "padre-P-1", tipo: "parada", parada_id: 'P-1', audio_id: "audio-P-1", reto_id: "R-3" },
                { padreid: "padre-TR-2", tipo: "tramo", tramo_id: 'TR-2', audio_id: "audio-TR-2" },
                { padreid: "padre-P-2", tipo: "parada", parada_id: 'P-2', audio_id: "audio-P-2", reto_id: "R-4" },
                { padreid: "padre-TR-3", tipo: "tramo", tramo_id: 'TR-3', audio_id: "audio-TR-3" },
                { padreid: "padre-P-3", tipo: "parada", parada_id: 'P-3', audio_id: "audio-P-3", reto_id: "R-5" },
                { padreid: "padre-TR-4", tipo: "tramo", tramo_id: 'TR-4', audio_id: "audio-TR-4" },
                { padreid: "padre-P-4", tipo: "parada", parada_id: 'P-4', audio_id: "audio-P-4", reto_id: "R-6" },
                { padreid: "padre-P-5", tipo: "parada", parada_id: 'P-5', audio_id: "audio-P-5", retos: [{ tipo: "reto", id: "R-7" },{ tipo: "puzzle", id: "PZ-8" }] },
                { padreid: "padre-TR-5", tipo: "tramo", tramo_id: 'TR-5', audio_id: "audio-TR-5" },
                { padreid: "padre-P-6", tipo: "parada", parada_id: 'P-6', audio_id: "audio-P-6", reto_id: "R-9" },
                { padreid: "padre-P-7", tipo: "parada", parada_id: 'P-7', audio_id: "audio-P-7", reto_id: "R-10" },
                { padreid: "padre-P-8", tipo: "parada", parada_id: 'P-8', audio_id: "audio-P-8", reto_id: "R-11" },
                { padreid: "padre-P-9", tipo: "parada", parada_id: 'P-9', audio_id: "audio-P-9" },
                { padreid: "padre-P-10", tipo: "parada", parada_id: 'P-10', audio_id: "audio-P-10", reto_id: "R-12"  },
                { padreid: "padre-TR-6", tipo: "tramo", tramo_id: 'TR-6', audio_id: "audio-TR-6" },
                { padreid: "padre-P-11", tipo: "parada", parada_id: 'P-11', audio_id: "audio-P-11", reto_id: "R-13" },
                { padreid: "padre-P-12", tipo: "parada", parada_id: 'P-12', audio_id: "audio-P-12" },
                { padreid: "padre-P-13", tipo: "parada", parada_id: 'P-13', audio_id: "audio-P-13", reto_id: "R-14" },
                { padreid: "padre-TR-7", tipo: "tramo", tramo_id: 'TR-7', audio_id: "audio-TR-7" },
                { padreid: "padre-P-14", tipo: "parada", parada_id: 'P-14', audio_id: "audio-P-14", reto_id: "R-15" },
                { padreid: "padre-P-15", tipo: "parada", parada_id: 'P-15', audio_id: "audio-P-15" },
                { padreid: "padre-TR-8", tipo: "tramo", tramo_id: 'TR-8', audio_id: "audio-TR-8" },
                { padreid: "padre-P-16", tipo: "parada", parada_id: 'P-16', audio_id: "audio-P-16" },
                { padreid: "padre-TR-9", tipo: "tramo", tramo_id: 'TR-9', audio_id: "audio-TR-9" },
                { padreid: "padre-P-17", tipo: "parada", parada_id: 'P-17', audio_id: "audio-P-17", reto_id: "R-16" },
                { padreid: "padre-P-18", tipo: "parada", parada_id: 'P-18', audio_id: "audio-P-18" },
                { padreid: "padre-TR-10", tipo: "tramo", tramo_id: 'TR-10', audio_id: "audio-TR-10" },
                { padreid: "padre-P-19", tipo: "parada", parada_id: 'P-19', audio_id: "audio-P-19", retos: [{ tipo: "reto", id: "R-17" },{ tipo: "puzzle", id: "PZ-18" }] },
                { padreid: "padre-TR-11", tipo: "tramo", tramo_id: 'TR-11', audio_id: "audio-TR-11" },
                { padreid: "padre-TR-12", tipo: "tramo", tramo_id: 'TR-12', audio_id: "audio-TR-12" },
                { padreid: "padre-P-20", tipo: "parada", parada_id: 'P-20', audio_id: "audio-P-20", reto_id: "R-19" },
                { padreid: "padre-P-21", tipo: "parada", parada_id: 'P-21', audio_id: "audio-P-21" },
                { padreid: "padre-TR-13", tipo: "tramo", tramo_id: 'TR-13', audio_id: "audio-TR-13" },
                { padreid: "padre-P-22", tipo: "parada", parada_id: 'P-22', audio_id: "audio-P-22", retos: ["R-20", "R-21"] },
                { padreid: "padre-P-23", tipo: "parada", parada_id: 'P-23', audio_id: "audio-P-23", reto_id: "R-21" },
                { padreid: "padre-TR-14", tipo: "tramo", tramo_id: 'TR-14', audio_id: "audio-TR-14" },
                { padreid: "padre-P-24", tipo: "parada", parada_id: 'P-24', audio_id: "audio-P-24", reto_id: "R-22" },
                { padreid: "padre-TR-15", tipo: "tramo", tramo_id: 'TR-15', audio_id: "audio-TR-15" },
                { padreid: "padre-P-25", tipo: "parada", parada_id: 'P-25', audio_id: "audio-P-25" },
                { padreid: "padre-TR-16", tipo: "tramo", tramo_id: 'TR-16', audio_id: "audio-TR-16" },
                { padreid: "padre-P-26", tipo: "parada", parada_id: 'P-26', audio_id: "audio-P-26", reto_id: "R-23" },
                { padreid: "padre-TR-17", tipo: "tramo", tramo_id: 'TR-17', audio_id: "audio-TR-17" },
                { padreid: "padre-P-27", tipo: "parada", parada_id: 'P-27', audio_id: "audio-P-27", reto_id: "R-24" },
                { padreid: "padre-P-28", tipo: "parada", parada_id: 'P-28', audio_id: "audio-P-28", reto_id: "R-25" },
                { padreid: "padre-TR-18", tipo: "tramo", tramo_id: 'TR-18', audio_id: "audio-TR-18" },
                { padreid: "padre-P-29", tipo: "parada", parada_id: 'P-29', audio_id: "audio-P-29", reto_id: "R-27" },
                { padreid: "padre-P-30", tipo: "parada", parada_id: 'P-30', audio_id: "audio-P-30", reto_id: "R-28" },
                { padreid: "padre-TR-19", tipo: "tramo", tramo_id: 'TR-19', audio_id: "audio-TR-19" },
                { padreid: "padre-P-31", tipo: "parada", parada_id: 'P-31', audio_id: "audio-P-31", reto_id: "R-29" },
                { padreid: "padre-P-32", tipo: "parada", parada_id: 'P-32', audio_id: "audio-P-32", reto_id: "R-30" },
                { padreid: "padre-P-33", tipo: "parada", parada_id: 'P-33', audio_id: "audio-P-33", retos: [ { tipo: "reto", id: "R-31" }, { tipo: "puzzle", id: "PZ-26" } ] },
                { padreid: "padre-TR-20", tipo: "tramo", tramo_id: 'TR-20', audio_id: "audio-TR-20" },
                { padreid: "padre-TR-21", tipo: "tramo", tramo_id: 'TR-21', audio_id: "audio-TR-21" },
                { padreid: "padre-P-34", tipo: "parada", parada_id: 'P-34', audio_id: "audio-P-34", reto_id: "R-32" },
                { padreid: "padre-TR-22", tipo: "tramo", tramo_id: 'TR-22', audio_id: "audio-TR-22" },
                { padreid: "padre-P-35", tipo: "parada", parada_id: 'P-35', audio_id: "audio-P-35" },
                { padreid: "padre-TR-23", tipo: "tramo", tramo_id: 'TR-23', audio_id: "audio-TR-23" },
                { padreid: "padre-P-36", tipo: "parada", parada_id: 'P-36', audio_id: "audio-P-36" }
            ];

            // 4. L√ìGICA DE ARRANQUE
            // Crear variable para controlar si el evento DOMContentLoaded ya se proces√≥
            window.domContentLoadedProcessed = false;
            
            document.addEventListener('DOMContentLoaded', async () => {
                // Evitar m√∫ltiples ejecuciones del mismo evento
                if (window.domContentLoadedProcessed) {
                    console.warn('‚ö†Ô∏è [PADRE] DOMContentLoaded ya fue procesado anteriormente. Evitando inicializaci√≥n duplicada.');
                    return;
                }
                
                window.domContentLoadedProcessed = true;
                console.log('üîÑ [PADRE] Procesando evento DOMContentLoaded...');
                
                const logger = {
                    info: (msg, ...args) => console.log(`[INFO] ${msg}`, ...args),
                    error: (msg, ...args) => console.error(`[ERROR] ${msg}`, ...args),
                    warn: (msg, ...args) => console.warn(`[WARN] ${msg}`, ...args),
                    debug: (msg, ...args) => console.debug(`[DEBUG] ${msg}`, ...args)
                };

                // Funci√≥n para actualizar el tama√±o del mapa
                const updateMapSize = () => {
                    if (window.mapa) {
                        window.mapa.invalidateSize();
                        logger.debug('Map size updated');
                    }
                };

                try {
                    logger.info('Iniciando inicializaci√≥n de la aplicaci√≥n...');
                    
                    // 1. Inicializar mensajer√≠a primero
                    await inicializarSistemaMensajeria();
                    logger.debug('Sistema de mensajer√≠a inicializado');
                    
                    // 2. Registrar manejadores de mensajes
                    registrarControladoresTotales();
                    logger.debug('Manejadores de mensajes registrados');
                    
                    // 3. Inicializar el mapa
                    const mapaContainer = document.getElementById('mapa');
                    if (!mapaContainer) {
                        throw new Error('No se encontr√≥ el contenedor del mapa');
                    }
                    
                    // Preparar expl√≠citamente el contenedor para asegurar que est√© visible y correctamente dimensionado
                    mapaContainer.style.display = 'block';
                    mapaContainer.style.visibility = 'visible';
                    mapaContainer.style.width = '100vw';
                    mapaContainer.style.height = '100vh';
                    mapaContainer.style.backgroundColor = '#f5f5f5'; // Fondo visible para debug
                    
                    console.log('üîç [PADRE] Contenedor del mapa preparado:', 
                                mapaContainer.offsetWidth + 'x' + mapaContainer.offsetHeight);
                    
                    // Peque√±o retraso para asegurar que el DOM est√© completamente listo
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    // Inicializar el mapa con la funci√≥n mejorada
                    const mapaInstance = await iniciarSistemaMapa();
                    if (!mapaInstance) {
                        throw new Error('No se pudo inicializar el mapa');
                    }
                    
                    logger.info('Sistema de mapa inicializado correctamente');
                    console.log('‚úÖ [PADRE] Sistema de mapa inicializado correctamente');
                    
                    // 4. Configurar actualizaci√≥n de tama√±o del mapa con m√∫ltiples intentos
                    setTimeout(updateMapSize, 100);
                    setTimeout(updateMapSize, 500);
                    setTimeout(updateMapSize, 1000);
                    window.addEventListener('resize', () => setTimeout(updateMapSize, 100));
                    
                    // 5. Notificar que la aplicaci√≥n est√° lista
                    if (typeof enviarMensaje === 'function') {
                        await enviarMensaje('*', TIPOS_MENSAJE.SISTEMA.LISTO, {
                            modulo: 'app',
                            estado: 'listo',
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    // 6. Notificar inicializaci√≥n a los hijos
                    try {
                        // Implementamos la funci√≥n de notificaci√≥n directamente aqu√≠ para evitar problemas de hoisting
                        // y referencias
                        logger.info('Notificando inicializaci√≥n a los hijos...');
                        
                        // Preparar el array de paradas adaptado para cada tipo de hijo
                        const arrayParadasSimplificado = AVENTURA_PARADAS.map(parada => ({
                            id: parada.padreid,
                            tipo: parada.tipo,
                            parada_id: parada.parada_id,
                            tramo_id: parada.tramo_id,
                            audio_id: parada.audio_id,
                            reto_id: parada.reto_id || (parada.retos && parada.retos.length > 0 ? 
                                        (typeof parada.retos[0] === 'string' ? 
                                        parada.retos[0] : parada.retos[0].id) : null)
                        }));
                        
                        const promesas = Object.values(HIJOS).map(hijo => {
                            // Dependiendo del tipo de hijo, enviar los datos que necesita
                            let datosEspecificos = { aventuraParadas: AVENTURA_PARADAS };
                            
                            // Para el mapa y componentes visuales, enviar datos simplificados
                            if (hijo.id === HIJOS.CASA.id || hijo.id === HIJOS.COORDENADAS.id) {
                                datosEspecificos = { 
                                    aventuraParadas: arrayParadasSimplificado,
                                    modoActual: estadoApp.modo.actual
                                };
                            }
                            
                            // Para el componente de audio, enviar solo IDs de audio
                            if (hijo.id === HIJOS.AUDIO.id) {
                                datosEspecificos = { 
                                    audios: AVENTURA_PARADAS.map(p => ({
                                        id: p.audio_id,
                                        tipo: p.tipo,
                                        padreid: p.padreid
                                    }))
                                };
                            }
                            
                            // Para el componente de retos, enviar solo IDs de retos
                            if (hijo.id === HIJOS.RETOS.id) {
                                const retos = [];
                                AVENTURA_PARADAS.forEach(p => {
                                    if (p.reto_id) {
                                        retos.push({
                                            id: p.reto_id,
                                            padreid: p.padreid,
                                            tipo: 'reto'
                                        });
                                    }
                                    if (p.retos && Array.isArray(p.retos)) {
                                        p.retos.forEach(r => {
                                            const retoId = typeof r === 'string' ? r : r.id;
                                            const retoTipo = typeof r === 'string' ? 'reto' : r.tipo;
                                            retos.push({
                                                id: retoId,
                                                padreid: p.padreid,
                                                tipo: retoTipo
                                            });
                                        });
                                    }
                                });
                                datosEspecificos = { retos };
                            }
                            
                            return enviarMensaje(hijo.id, TIPOS_MENSAJE.SISTEMA.INICIALIZACION, datosEspecificos)
                                .catch(err => logger.warn(`No se pudo notificar a ${hijo.nombre}:`, err.message));
                        });
                        
                        await Promise.allSettled(promesas);
                        logger.info('Notificaci√≥n a hijos completada desde flujo principal');
                    } catch (error) {
                        logger.error("Error al notificar a los hijos:", error);
                        updateMapDebug("Error al notificar a los hijos: " + error.message);
                    }
                    
                    // 7. Configurar cierre del overlay de medios
                    const closeMediaBtn = document.getElementById('close-media');
                    if (closeMediaBtn) {
                        console.log('üîç [PADRE] Configurando bot√≥n de cierre del overlay de medios');
                        
                        // Eliminar listeners anteriores si existen para evitar duplicados
                        closeMediaBtn.removeEventListener('click', window.ocultarMedios);
                        
                        // Agregar nuevo listener
                        closeMediaBtn.addEventListener('click', window.ocultarMedios);
                        console.log('‚úÖ [PADRE] Bot√≥n de cierre configurado correctamente');
                    } else {
                        console.warn('‚ö†Ô∏è [PADRE] No se encontr√≥ el bot√≥n de cierre del overlay de medios');
                    }
                    
                    logger.info('Aplicaci√≥n inicializada correctamente');
                    
                } catch (error) {
                    const errorMsg = `Error al inicializar la aplicaci√≥n: ${error.message}`;
                    logger.error(errorMsg, error);
                    
                    // Notificar error al sistema
                    if (typeof enviarMensaje === 'function') {
                        await enviarMensaje('*', TIPOS_MENSAJE.SISTEMA.ERROR, {
                            tipo: 'inicializacion',
                            mensaje: error.message,
                            stack: error.stack,
                            timestamp: new Date().toISOString()
                        }).catch(e => console.error('Error al notificar error:', e));
                    }
                    
                    // Mostrar mensaje de error al usuario
                    alert('Error cr√≠tico al inicializar la aplicaci√≥n. Por favor, recarga la p√°gina.');
                    
                    // Mostrar el contenedor del mapa si existe
                    if (mapaContainer) {
                        mapaContainer.style.visibility = 'visible';
                    }
                    
                    // Actualizar el estado de depuraci√≥n
                    if (typeof updateMapDebug === 'function') {
                        updateMapDebug(`Error: ${error.message}`);
                    }
                    
                    // Registrar el error
                    if (typeof crearObjetoError === 'function') {
                        crearObjetoError('inicializacion', error);
                    }
                }
            });

            // 5. FUNCIONES PRINCIPALES
            // Variable para controlar la inicializaci√≥n del sistema de mensajer√≠a
            window._mensajeriaInicializandose = false;
            
            async function inicializarSistemaMensajeria() {
                try {
                    console.log('üîÑ [PADRE] Iniciando inicializaci√≥n del sistema de mensajer√≠a');
                    
                    // Verificar si el sistema ya est√° inicializado
                    if (estadoApp.mensajeriaInicializada) {
                        console.log('‚úÖ [PADRE] Sistema de mensajer√≠a ya inicializado');
                        return true;
                    }
                    
                    // Verificar si hay una inicializaci√≥n en curso
                    if (window._mensajeriaInicializandose) {
                        console.log('‚è≥ [PADRE] Sistema de mensajer√≠a ya est√° inicializ√°ndose. Esperando...');
                        // Esperar a que termine la inicializaci√≥n en curso
                        let intentos = 0;
                        while (window._mensajeriaInicializandose && intentos < 10) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            intentos++;
                        }
                        
                        if (estadoApp.mensajeriaInicializada) {
                            console.log('‚úÖ [PADRE] Sistema de mensajer√≠a inicializado por otro proceso');
                            return true;
                        }
                    }
                    
                    // Marcar como en proceso de inicializaci√≥n
                    window._mensajeriaInicializandose = true;
                    
                    // Confirmar que tenemos las funciones necesarias
                    if (typeof inicializarMensajeria !== 'function') {
                        throw new Error('La funci√≥n inicializarMensajeria no est√° disponible');
                    }
                    
                    console.log('üîÑ [PADRE] Llamando a inicializarMensajeria con:', { 
                        iframeId: CONFIG.ID_PADRE, 
                        logLevel: CONFIG.LOG_LEVEL 
                    });
                    
                    await inicializarMensajeria({ 
                        iframeId: CONFIG.ID_PADRE, 
                        logLevel: CONFIG.LOG_LEVEL 
                    });
                    
                    estadoApp.mensajeriaInicializada = true;
                    window._mensajeriaInicializandose = false; // Liberar flag de inicializaci√≥n
                    logger.info('Sistema de mensajer√≠a inicializado correctamente');
                    console.log('‚úÖ [PADRE] Sistema de mensajer√≠a inicializado correctamente');
                    
                    return true;
                } catch (error) {
                    const errorMsg = `Error al inicializar sistema de mensajer√≠a: ${error.message}`;
                    console.error('‚ùå [PADRE] ' + errorMsg, error);
                    logger.error(errorMsg, error);
                    updateMapDebug(`Error: No se pudo inicializar el sistema de mensajer√≠a - ${error.message}`);
                    
                    // Si hay un error al inicializar la mensajer√≠a, intentar configurar un respaldo b√°sico
                    console.warn('‚ö†Ô∏è [PADRE] Intentando configurar sistema de mensajer√≠a de respaldo');
                    window.addEventListener('message', function(event) {
                        try {
                            const data = event.data;
                            console.debug('[RESPALDO] Mensaje recibido:', data);
                        } catch (e) {
                            console.error('[RESPALDO] Error al procesar mensaje:', e);
                        }
                    });
                    
                    throw error;
                }
            }

            async function iniciarSistemaMapa() {
                try {
                    logger.info('Iniciando sistema de mapa...');
                    console.log('üó∫Ô∏è [PADRE] Inicializando mapa Leaflet...');
                    
                    // Verificar que el contenedor del mapa existe y est√° visible
                    const mapaContainer = document.getElementById('mapa');
                    if (!mapaContainer) {
                        console.error('‚ùå [PADRE] Contenedor del mapa no encontrado, creando uno nuevo...');
                        // Crear el contenedor si no existe
                        const nuevoContenedor = document.createElement('div');
                        nuevoContenedor.id = 'mapa';
                        document.body.appendChild(nuevoContenedor);
                        console.log('‚úÖ [PADRE] Contenedor del mapa creado din√°micamente');
                    }
                    
                    // Siempre obtenemos la referencia despu√©s de posiblemente crearlo
                    const contenedor = document.getElementById('mapa');
                    
                    // A√±adir borde temporal para diagn√≥stico visual
                    contenedor.style.border = '5px solid red';
                    console.log('üîç [PADRE] Borde rojo a√±adido para diagn√≥stico visual');
                    
                    // AJUSTE: Asegurarse de que el contenedor est√© visible con todas las propiedades correctas
                    contenedor.style.display = 'block';
                    contenedor.style.visibility = 'visible';
                    contenedor.style.opacity = '1';
                    contenedor.style.width = '100vw';
                    contenedor.style.height = '100vh';
                    contenedor.style.position = 'fixed';
                    contenedor.style.zIndex = '10'; // Prioridad alta
                    contenedor.style.backgroundColor = '#f5f5f5';
                    
                    // Verificar dimensiones y hacer diagn√≥stico completo
                    if (contenedor.offsetWidth < 50 || contenedor.offsetHeight < 50) {
                        console.warn('‚ö†Ô∏è [PADRE] El contenedor del mapa tiene dimensiones insuficientes');
                        // Forzar dimensiones m√≠nimas para garantizar visibilidad
                        contenedor.style.width = '100vw';
                        contenedor.style.height = '100vh';
                        // Forzar reflow del DOM para aplicar cambios
                        contenedor.offsetHeight;
                        
                        console.log('üîÑ [PADRE] Dimensiones del contenedor ajustadas forzosamente:', 
                                    contenedor.offsetWidth + 'x' + contenedor.offsetHeight);
                    }
                    
                    // Diagn√≥stico del mapa (DOM)
                    console.log('DIAGN√ìSTICO DEL CONTENEDOR:');
                    console.log('- Display:', window.getComputedStyle(contenedor).display);
                    console.log('- Visibility:', window.getComputedStyle(contenedor).visibility);
                    console.log('- Z-index:', window.getComputedStyle(contenedor).zIndex);
                    console.log('- Position:', window.getComputedStyle(contenedor).position);
                    console.log('- Dimensiones:', contenedor.offsetWidth + 'x' + contenedor.offsetHeight);
                    
                    // Peque√±a pausa para permitir que el DOM se actualice completamente
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Si por alguna raz√≥n ya existe un mapa, destruirlo
                    if (window.mapa && typeof window.mapa.remove === 'function') {
                        console.log('üóëÔ∏è [PADRE] Eliminando instancia anterior del mapa');
                        window.mapa.remove();
                        window.mapa = null;
                    }
                    
                    // Verificar que Leaflet est√© disponible
                    if (!window.L) {
                        console.error('‚ùå [PADRE] Leaflet no est√° disponible (L no definido)');
                        // Intentar cargar Leaflet din√°micamente como √∫ltimo recurso
                        await new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';
                            script.integrity = 'sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=';
                            script.crossOrigin = '';
                            script.onload = () => {
                                console.log('‚úÖ [PADRE] Leaflet cargado din√°micamente');
                                resolve();
                            };
                            script.onerror = () => reject(new Error('No se pudo cargar Leaflet din√°micamente'));
                            document.head.appendChild(script);
                        });
                        
                        // Verificar de nuevo despu√©s de intentar cargar
                        if (!window.L) {
                            throw new Error('Leaflet no est√° disponible en window.L');
                        }
                    }
                    
                    // Crear el mapa directamente con opciones expl√≠citas
                    console.log('üó∫Ô∏è [PADRE] Creando instancia de mapa con configuraci√≥n:', MAP_CONFIG);
                    const directMapInstance = L.map('mapa', {
                        center: MAP_CONFIG.center,
                        zoom: MAP_CONFIG.zoom,
                        minZoom: MAP_CONFIG.minZoom,
                        maxZoom: MAP_CONFIG.maxZoom,
                        zoomControl: MAP_CONFIG.zoomControl,
                        attributionControl: true,
                        fadeAnimation: true
                    });
                    
                    // A√±adir capa base de OpenStreetMap con opciones completas para mejor visibilidad
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                        tileSize: 256,
                        maxNativeZoom: 19,
                        maxZoom: 19,
                        minZoom: 1,
                        crossOrigin: true,
                        opacity: 1.0,
                        detectRetina: true,
                        updateWhenIdle: false,
                        updateWhenZooming: true,
                        updateInterval: 200
                    }).addTo(directMapInstance);
                    
                    console.log('‚úÖ [PADRE] Mapa creado directamente:', directMapInstance);
                    
                    // Quitar borde de diagn√≥stico despu√©s de un tiempo
                    setTimeout(() => {
                        contenedor.style.border = '1px solid #ccc';
                    }, 3000);
                    
                    // Invalidar tama√±o expl√≠citamente para garantizar renderizado correcto
                    if (directMapInstance && typeof directMapInstance.invalidateSize === 'function') {
                        directMapInstance.invalidateSize(true);
                        console.log('üîÑ [PADRE] Tama√±o del mapa actualizado forzosamente');
                    }

                    window.mapa = directMapInstance;
                    logger.info('Mapa inicializado correctamente');
                    estadoApp.mapaInicializado = true;
                    
                    // Force map to update its size after a short delay
                    const updateMapSize = () => {
                        if (window.mapa) {
                            window.mapa.invalidateSize();
                            logger.debug('Map size updated');
                            console.log('üîÑ [PADRE] Tama√±o del mapa actualizado');
                        }
                    };
                    
                    // Actualizar tama√±o inmediatamente y despu√©s de un corto delay
                    updateMapSize();
                    setTimeout(updateMapSize, 100);
                    setTimeout(updateMapSize, 500);
                    setTimeout(updateMapSize, 1000);
                    window.addEventListener('resize', () => setTimeout(updateMapSize, 100));
                    
                    return directMapInstance;
                } catch (error) {
                    logger.error('Error al inicializar el mapa:', error);
                    console.error('‚ùå [PADRE] Error al inicializar el mapa:', error);
                    
                    // √öltimo intento: crear un mapa simple en caso de error
                    try {
                        console.log('üîÑ [PADRE] Intentando crear mapa simple como √∫ltimo recurso...');
                        const fallbackMap = L.map('mapa').setView([39.4699, -0.3763], 13);
                        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                        }).addTo(fallbackMap);
                        window.mapa = fallbackMap;
                        return fallbackMap;
                    } catch (fallbackError) {
                        console.error('‚ùå [PADRE] Fallo en la creaci√≥n del mapa de respaldo:', fallbackError);
                        throw error; // Lanzar el error original
                    }
                }
            }

            async function notificarInicializacionAHijos() {
                logger.info('Notificando inicializaci√≥n a los hijos...');
                
                // Preparar el array de paradas adaptado para cada tipo de hijo
                const arrayParadasSimplificado = AVENTURA_PARADAS.map(parada => ({
                    id: parada.padreid,
                    tipo: parada.tipo,
                    parada_id: parada.parada_id,
                    tramo_id: parada.tramo_id,
                    audio_id: parada.audio_id,
                    reto_id: parada.reto_id || (parada.retos && parada.retos.length > 0 ? 
                                (typeof parada.retos[0] === 'string' ? 
                                parada.retos[0] : parada.retos[0].id) : null)
                }));
                
                const promesas = Object.values(CONFIG.HIJOS).map(hijo => {
                    // Dependiendo del tipo de hijo, enviar los datos que necesita
                    let datosEspecificos = { aventuraParadas: AVENTURA_PARADAS };
                    
                    // Para el mapa y componentes visuales, enviar datos simplificados
                    if (hijo.id === CONFIG.HIJOS.CASA.id || hijo.id === CONFIG.HIJOS.COORDENADAS.id) {
                        datosEspecificos = { 
                            aventuraParadas: arrayParadasSimplificado,
                            modoActual: estadoApp.modo.actual
                        };
                    }
                    
                    // Para el componente de audio, enviar solo IDs de audio
                    if (hijo.id === CONFIG.HIJOS.AUDIO.id) {
                        datosEspecificos = { 
                            audios: AVENTURA_PARADAS.map(p => ({
                                id: p.audio_id,
                                tipo: p.tipo,
                                padreid: p.padreid
                            }))
                        };
                    }
                    
                    // Para el componente de retos, enviar solo IDs de retos
                    if (hijo.id === CONFIG.HIJOS.RETOS.id) {
                        const retos = [];
                        AVENTURA_PARADAS.forEach(p => {
                            if (p.reto_id) {
                                retos.push({
                                    id: p.reto_id,
                                    padreid: p.padreid,
                                    tipo: 'reto'
                                });
                            }
                            if (p.retos && Array.isArray(p.retos)) {
                                p.retos.forEach(r => {
                                    const retoId = typeof r === 'string' ? r : r.id;
                                    const retoTipo = typeof r === 'string' ? 'reto' : r.tipo;
                                    retos.push({
                                        id: retoId,
                                        padreid: p.padreid,
                                        tipo: retoTipo
                                    });
                                });
                            }
                        });
                        datosEspecificos = { retos };
                    }
                    
                    return enviarMensaje(hijo.id, TIPOS_MENSAJE.SISTEMA.INICIALIZACION, datosEspecificos)
                        .catch(err => logger.warn(`No se pudo notificar a ${hijo.nombre}:`, err.message));
                });
                
                await Promise.allSettled(promesas);
                logger.info('Notificaci√≥n a hijos completada.');
            }

            // 6. REGISTRO DE CONTROLADORES DE MENSAJES
            async function registrarControladoresTotales() {
                console.log('üìù [PADRE] Registrando controladores de mensajes...');

                // Remover cualquier manejador existente para evitar duplicaciones
                if (window.handleHijo5CasaMessages) {
                    window.removeEventListener('message', window.handleHijo5CasaMessages);
                    console.log('üîÑ [PADRE] Manejador anterior de mensajes hijo5-casa eliminado');
                }
                
                // Define a global handler for hijo5-casa messages
                window.handleHijo5CasaMessages = function(event) {
                    try {
                        // Only process messages that might be from hijo5-casa
                        if (event.source === document.getElementById('hijo5-casa')?.contentWindow) {
                            // Ignore Grammarly messages immediately
                            const data = event.data;
                            if (data && (data.__grammarly || data._grammarly || data.grammarly_report || data.ext_id || data.extension_id)) {
                                console.debug('[DEBUG] Ignorando mensaje de Grammarly desde hijo5-casa');
                                return;
                            }
                            
                            console.log('[DEBUG] Mensaje recibido de hijo5-casa:', data);
                            
                            // Check if the message has the required fields
                            const requiredFields = ['tipo', 'datos'];
                            const missingFields = requiredFields.filter(field => !data || !data.hasOwnProperty(field));
                            
                            if (missingFields.length > 0) {
                                console.warn(`[DEBUG] Mensaje de hijo5-casa con campos requeridos faltantes: ${missingFields.join(', ')}`, data);
                                
                                // Log extra details to help debug
                                if (data) {
                                    console.log('[DEBUG] Tipo de mensaje:', typeof data);
                                    console.log('[DEBUG] Keys disponibles:', Object.keys(data));
                                }
                            } else {
                                // Valid message, try to handle it directly if possible
                                console.log('[DEBUG] Mensaje v√°lido de hijo5-casa:', data.tipo);
                                if (data.tipo === 'SISTEMA.CAMBIO_MODO' && typeof manejarCambioModo === 'function') {
                                    console.log('[DEBUG] Procesando mensaje de cambio de modo');
                                    try {
                                        manejarCambioModo({origen: 'hijo5-casa', datos: data.datos});
                                    } catch (e) {
                                        console.error('[DEBUG] Error al manejar cambio de modo:', e);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error('[DEBUG] Error al procesar mensaje de hijo5-casa:', error);
                    }
                };
                
                // Add the debug handler
                // Eliminar manejador anterior si existe y a√±adir el nuevo
            if (window._hijo5CasaMessageHandlerRegistered) {
                console.log('üîÑ [PADRE] Evitando registro duplicado del manejador de hijo5-casa');
            } else {
                window.addEventListener('message', window.handleHijo5CasaMessages);
                window._hijo5CasaMessageHandlerRegistered = true;
                console.log('‚úÖ [PADRE] Manejador global para hijo5-casa registrado');
            }

                // Registrar cada controlador con nombre directo para evitar problemas de referencia
                const controladores = {};
                
                // Registrar controladores del sistema
                controladores[TIPOS_MENSAJE.SISTEMA.ERROR] = manejarErrorSistema;
                controladores[TIPOS_MENSAJE.SISTEMA.INICIALIZACION_COMPLETADA] = manejarHijoInicializado;
                controladores[TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO] = manejarCambioModo;
                
                // Registrar controladores de datos
                controladores[TIPOS_MENSAJE.DATOS.SOLICITAR_PARADAS] = manejarSolicitudArrayParadas;
                
                // Registrar controladores de navegaci√≥n (Ver js/comunicacion-componentes.md)
                controladores[TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA] = manejarSeleccionPuntoCasa;
                console.log(`üéØ [PADRE] Registrando controlador para cambio de parada: ${TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA}`);
                
                // Registrar controladores de audio
                controladores[TIPOS_MENSAJE.AUDIO.FINALIZADO] = manejarAudioFinalizado;
                console.log(`üîä [PADRE] Registrando controlador para audio finalizado: ${TIPOS_MENSAJE.AUDIO.FINALIZADO}`);
                
                // Registrar controladores de retos
                controladores[TIPOS_MENSAJE.RETO.MOSTRAR] = manejarMostrarReto;
                controladores[TIPOS_MENSAJE.RETO.OCULTAR] = manejarOcultarReto;
                controladores[TIPOS_MENSAJE.RETO.COMPLETADO] = manejarRetoCompletado;
                
                // Otros controladores
                controladores['MAPA.ACTUALIZAR'] = manejarActualizacionMapa;
                controladores[TIPOS_MENSAJE.MEDIOS.EVENTO] = manejarEventosMedios;

                console.log('üéØ [PADRE] Controladores a registrar:', Object.keys(controladores));
                console.log('üîç [PADRE] Verificando registro de NAVEGACION.CAMBIO_PARADA:', TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA);

                // Registro individual de controladores para mayor control
                Object.entries(controladores).forEach(([tipo, handler]) => {
                    try {
                        console.log(`üìå [PADRE] Registrando controlador para: ${tipo}`);
                        registrarControlador(tipo, handler);
                        console.log(`‚úÖ [PADRE] Controlador para ${tipo} registrado correctamente`);
                    } catch (error) {
                        console.error(`‚ùå [PADRE] Error al registrar controlador para ${tipo}:`, error);
                        logger.error(`Error al registrar controlador para ${tipo}:`, error);
                    }
                });
                console.log('‚úÖ [PADRE] Controladores de mensajes registrados correctamente.');
                logger.info('Controladores de mensajes registrados.');
            }

            // 7. IMPLEMENTACI√ìN DE MANEJADORES
            function manejarErrorSistema(msg) { 
                const { codigo, mensaje, stack } = msg.datos || {};
                const errorMsg = `[${codigo || 'SIN_CODIGO'}] ${mensaje || 'Error desconocido'}`;
                logger.error(`Error de ${msg.origen || 'origen_desconocido'}:`, errorMsg);
                if (stack) logger.debug('Stack trace:', stack);
                updateMapDebug(`Error de ${msg.origen || 'sistema'}: ${errorMsg}`);
            }
            
            function manejarHijoInicializado(msg) { 
                const { idIframe, estado } = msg.datos || {};
                if (idIframe && estado === 'listo') {
                    logger.info(`Hijo ${idIframe} inicializado correctamente.`);
                    estadoApp.hijosInicializados.add(idIframe);
                } else {
                    logger.warn(`Inicializaci√≥n incompleta de ${idIframe || 'hijo_desconocido'}:`, msg.datos);
                }
            }
            
            /**
             * Maneja las solicitudes de datos de paradas desde los hijos
             * @param {Object} msg - Mensaje de solicitud de paradas
             * @returns {Object} - Respuesta con los datos solicitados
             */
            function manejarSolicitudArrayParadas(msg) { 
                const { origen, puntoId, paradaId, tramoId, timestamp } = msg.datos || {};
                logger.info(`Solicitud de datos de paradas desde ${origen}`, { puntoId, paradaId, tramoId, timestamp });
                
                // 1. Solicitud de todas las paradas (comportamiento predeterminado)
                if (!puntoId && !paradaId && !tramoId) {
                    return { 
                        exito: true, 
                        paradas: AVENTURA_PARADAS,
                        timestamp: Date.now(),
                        totalParadas: AVENTURA_PARADAS.length
                    }; 
                }
                
                // 2. Solicitud de una parada espec√≠fica
                let idBuscado = puntoId || paradaId || tramoId;
                if (idBuscado) {
                    // Buscar la parada solicitada
                    const parada = buscarParada(idBuscado);
                    
                    if (parada) {
                        // Extraer los medios si existen (implementaci√≥n ejemplo, adaptar seg√∫n estructura real)
                        const datosPunto = {
                            id: parada.padreid,
                            tipo: parada.tipo,
                            titulo: `${parada.tipo === 'parada' ? 'Parada' : 'Tramo'} ${parada.parada_id || parada.tramo_id}`,
                            // Los campos imagen y video deber√≠an venir de alguna parte, 
                            // posiblemente CONFIG o de alg√∫n otro array con esa informaci√≥n
                            imagen: parada.imagen || null,
                            video: parada.video || null
                        };
                        
                        return {
                            exito: true,
                            parada,
                            datosPunto,
                            timestamp: Date.now()
                        };
                    }
                    
                    // No se encontr√≥ la parada
                    return {
                        exito: false,
                        error: `No se encontr√≥ parada con ID: ${idBuscado}`,
                        timestamp: Date.now()
                    };
                }
                
                // Solicitud inv√°lida
                return { 
                    exito: false, 
                    error: 'Solicitud de parada inv√°lida',
                    timestamp: Date.now()
                };
            }
            /**
             * Maneja el cambio de modo (casa/aventura) solicitado por un hijo
             * @param {Object} msg - Mensaje de cambio de modo
             * @returns {Promise<Object>} Resultado de la operaci√≥n
             */
            async function manejarCambioModo(msg) {
                const { modo, origen, razon } = msg.datos || {};
                
                // Validar el mensaje recibido
                if (!modo || !origen) {
                    const errorMsg = 'Mensaje de cambio de modo inv√°lido: falta modo u origen';
                    logger.error(errorMsg, msg);
                    await enviarMensaje(msg.origen || 'todos', TIPOS_MENSAJE.SISTEMA.ERROR, {
                        codigo: 'ERROR_CAMBIO_MODO_INVALIDO',
                        mensaje: errorMsg,
                        origen: 'padre',
                        timestamp: Date.now()
                    });
                    return { exito: false, error: errorMsg };
                }
                
                // Verificar si ya estamos en el modo solicitado
                if (modo === estadoApp.modo.actual) {
                    logger.info(`Solicitud de cambio a modo ${modo} ignorada (ya en este modo)`, { origen, razon });
                    return { 
                        exito: true, 
                        mensaje: 'Ya en este modo',
                        modoActual: estadoApp.modo.actual
                    };
                }
                
                logger.info(`Iniciando cambio a modo: ${modo}${razon ? ` (${razon})` : ''}`, { origen });
                
                // Notificar a todos los hijos del cambio de modo
                try {
                    // Primero deshabilitar controles temporalmente
                    await enviarMensaje('todos', TIPOS_MENSAJE.CONTROL.DESHABILITAR, {
                        motivo: `Cambiando a modo ${modo}`,
                        timestamp: Date.now()
                    });
                    
                    // Actualizar el estado local
                    const modoAnterior = estadoApp.modo.actual;
                    estadoApp.modo.anterior = modoAnterior;
                    estadoApp.modo.actual = modo;
                    
                    // Asegurar que el mapa est√© visible y actualizado
                    const mapaDiv = document.getElementById('mapa');
                    if (mapaDiv) {
                        // Asegurar que el mapa est√© siempre visible
                        mapaDiv.style.display = 'block';
                        
                        // Si el mapa ya est√° creado, actualizarlo
                        if (window.mapa) {
                            // Forzar actualizaci√≥n del tama√±o
                            setTimeout(() => {
                                window.mapa.invalidateSize();
                                
                                // Centrar en la ubicaci√≥n actual si est√° disponible
                                if (estadoApp.ubicacionActual) {
                                    window.mapa.setView(
                                        [estadoApp.ubicacionActual.latitud, estadoApp.ubicacionActual.longitud],
                                        window.mapa.getZoom() || MAP_CONFIG.zoom
                                    );
                                }
                            }, 100);
                        } else {
                            // Inicializar el mapa si no est√° creado
                            iniciarSistemaMapa().catch(error => {
                                console.error('Error al iniciar el mapa:', error);
                            });
                        }
                    }
                    
                    // Notificar a todos los hijos del cambio de modo, incluyendo gpsActivo
                    await enviarMensaje('todos', TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO, {
                        modo,
                        gpsActivo: modo === 'aventura',
                        origen: 'padre',
                        razon: `Cambio solicitado por ${origen}${razon ? `: ${razon}` : ''}`,
                        timestamp: Date.now()
                    });
                    
                    // Actualizar la interfaz
                    document.body.classList.toggle('modo-aventura', modo === 'aventura');
                    document.body.classList.toggle('modo-casa', modo === 'casa');
                    
                    logger.info(`Cambio a modo ${modo} completado`, { 
                        modoAnterior,
                        origenSolicitud: origen,
                        timestamp: Date.now()
                    });
                    
                    // Re-habilitar controles
                    await enviarMensaje('todos', TIPOS_MENSAJE.CONTROL.HABILITAR, {
                        modo,
                        timestamp: Date.now()
                    });
                    
                    return { 
                        exito: true, 
                        modoAnterior,
                        modoActual: modo,
                        timestamp: Date.now()
                    };
                } catch (error) {
                    const errorMsg = `Error al cambiar a modo ${modo}: ${error.message}`;
                    logger.error(errorMsg, error);
                    
                    // Notificar del error
                   
                    await enviarMensaje('todos', TIPOS_MENSAJE.SISTEMA.ERROR, {
                        codigo: 'ERROR_CAMBIO_MODO',
                        mensaje: errorMsg,
                        origen: 'padre',
                        stack: error.stack,
                        timestamp: Date.now()
                    });
                    
                    // Revertir cambios si es necesario
                    if (estadoApp.modo.actual !== modo) {
                        document.body.classList.toggle('modo-aventura', estadoApp.modo.actual === 'aventura');
                        document.body.classList.toggle('modo-casa', estadoApp.modo.actual === 'casa');
                    }
                    
                    return { 
                        exito: false, 
                        error: errorMsg,
                        modoActual: estadoApp.modo.actual,
                        timestamp: Date.now()
                    };
                }
            }

            /**
             * Busca una parada completa en el array AVENTURA_PARADAS por cualquiera de sus IDs
             * @param {Object} criterio - Criterio de b√∫squeda (padreid, parada_id, tramo_id, etc)
             * @returns {Object|null} La parada encontrada o null si no existe

             */
            function buscarParada(criterio) {
                if (!criterio) return null;
                
                // Si nos pasan un objeto punto, extraemos los ids principales
                if (typeof criterio === 'object') {
                    const { padreid, parada_id, tramo_id } = criterio;
                    
                    // Buscar primero por padreid (identificador interno)
                    if (padreid) {
                        const porPadreId = AVENTURA_PARADAS.find(p => p.padreid === padreid);
                        if (porPadreId) return porPadreId;
                    }
                    
                    // Luego buscar por los ids espec√≠ficos de tipo
                    if (parada_id) {
                        const porParadaId = AVENTURA_PARADAS.find(p => p.parada_id === parada_id);
                        if (porParadaId) return porParadaId;
                    }
                    
                    if (tramo_id) {
                        const porTramoId = AVENTURA_PARADAS.find(p => p.tramo_id === tramo_id);
                        if (porTramoId) return porTramoId;
                    }
                    
                    return null;
                }
                
                // Si es un string, intentar buscar en todos los campos de id
                if (typeof criterio === 'string') {
                    return AVENTURA_PARADAS.find(p => 
                        p.padreid === criterio || 
                        p.parada_id === criterio || 
                        p.tramo_id === criterio || 
                        p.audio_id === criterio || 
                        p.reto_id === criterio
                    );
                }
                
                return null;
            }
            
            /**
             * Maneja la selecci√≥n de un punto en el mapa con orquestaci√≥n completa y respuestas de componentes
             * Ver js/comunicacion-componentes.md para documentaci√≥n detallada del flujo
             * @param {Object} msg - Mensaje con los datos del punto seleccionado
             * @returns {Promise<Object>} Resultado de la operaci√≥n con todas las respuestas
             */
            async function manejarSeleccionPuntoCasa(msg) {
                console.log('üéØ [PADRE] manejarSeleccionPuntoCasa INVOCADO con:', msg);
                console.log('üìã [PADRE] Datos del mensaje:', msg.datos);
                console.log('üîç [PADRE] Punto recibido:', msg.datos?.punto);
                console.log('üì° [PADRE] Origen del mensaje:', msg.origen);

                // Crear un objeto para almacenar el estado y respuestas de cada componente
                const orquestacion = {
                    timestamp: Date.now(),
                    punto: null,
                    origen: msg.origen,
                    respuestas: {
                        mapa: { exito: false, mensaje: null, error: null },
                        audio: { exito: false, mensaje: null, error: null },
                        reto: { exito: false, mensaje: null, error: null },
                        medios: { exito: false, mensaje: null, error: null }
                    },
                    completado: false
                };

                try {
                    const { punto, origen, timestamp } = msg.datos || {};

                    if (!punto) {
                        const errorMsg = 'Datos de punto inv√°lidos o faltantes';
                        console.error('‚ùå [PADRE] Error de validaci√≥n:', errorMsg);
                        
                        // Notificar error al origen
                        await enviarMensaje(origen || 'todos', TIPOS_MENSAJE.SISTEMA.ERROR, {
                            codigo: 'PUNTO_INVALIDO',
                            mensaje: errorMsg,
                            origen: 'padre',
                            timestamp: Date.now()
                        });
                        
                        return {
                            exito: false,
                            error: errorMsg,
                            timestamp: Date.now(),
                            orquestacion
                        };
                    }

                    // 1. Buscar la informaci√≥n completa de la parada
                    const paradaCompleta = buscarParada(punto);
                    const puntoNormalizado = paradaCompleta || punto;
                    orquestacion.punto = puntoNormalizado;
                    
                    const idLog = paradaCompleta?.padreid || punto.padreid || punto.parada_id || punto.tramo_id || 'desconocido';
                    logger.info(`Recibida selecci√≥n de punto: ${idLog} desde ${origen}`);

                    // 2. ORQUESTACI√ìN DEL MAPA - con tiempo l√≠mite de 3 segundos
                    console.log('üó∫Ô∏è [PADRE] Paso 1: Enviando ESTABLECER_DESTINO al mapa');
                    try {
                        const respuestaMapa = await window.executeWithTimeout(
                            enviarMensaje('mapa', TIPOS_MENSAJE.NAVEGACION.ESTABLECER_DESTINO, { punto: puntoNormalizado }),
                            3000,
                            'Tiempo excedido esperando respuesta del mapa'
                        );
                        
                        orquestacion.respuestas.mapa = {
                            exito: true,
                            mensaje: 'Mapa actualizado correctamente',
                            datos: respuestaMapa
                        };
                        console.log('‚úÖ [PADRE] Mapa actualizado correctamente:', respuestaMapa);
                    } catch (mapError) {
                        orquestacion.respuestas.mapa = {
                            exito: false,
                            mensaje: 'Error al actualizar mapa',
                            error: mapError.message
                        };
                        console.error('‚ùå [PADRE] Error al actualizar mapa:', mapError);
                    }

                    // 3. ORQUESTACI√ìN DEL AUDIO - con tiempo l√≠mite de 3 segundos
                    const audioId = puntoNormalizado.audio_id;
                    if (audioId) {
                        console.log('üéµ [PADRE] Paso 2: Enviando REPRODUCIR al audio:', audioId);
                        try {
                            const respuestaAudio = await window.executeWithTimeout(
                                reproducirAudio(audioId, puntoNormalizado.tipo),
                                3000,
                                'Tiempo excedido esperando respuesta del componente de audio'
                            );
                            
                            orquestacion.respuestas.audio = {
                                exito: true,
                                mensaje: 'Audio enviado correctamente',
                                datos: respuestaAudio,
                                audioId
                            };
                            console.log('‚úÖ [PADRE] Audio enviado correctamente:', respuestaAudio);
                        } catch (audioError) {
                            orquestacion.respuestas.audio = {
                                exito: false,
                                mensaje: 'Error al enviar audio',
                                error: audioError.message,
                                audioId
                            };
                            console.error('‚ùå [PADRE] Error al enviar audio:', audioError);
                        }
                    } else {
                        orquestacion.respuestas.audio = {
                            exito: true,
                            mensaje: 'No hay audio asociado a este punto',
                            audioId: null
                        };
                        console.log('üîá [PADRE] Paso 2: No hay audio_id, saltando audio');
                    }

                    // 4. ORQUESTACI√ìN DE RETOS - con tiempo l√≠mite de 3 segundos
                    const retoId = await extraerRetoId(puntoNormalizado);
                    
                    if (retoId) {
                        console.log('üéÆ [PADRE] Paso 3: Enviando MOSTRAR_RETO:', retoId);
                        try {
                            const respuestaReto = await window.executeWithTimeout(
                                manejarMostrarReto({ datos: { retoId } }),
                                3000,
                                'Tiempo excedido esperando respuesta del componente de retos'
                            );
                            
                            orquestacion.respuestas.reto = {
                                exito: true,
                                mensaje: 'Reto mostrado correctamente',
                                datos: respuestaReto,
                                retoId
                            };
                            console.log('‚úÖ [PADRE] Reto mostrado correctamente:', respuestaReto);
                        } catch (retoError) {
                            orquestacion.respuestas.reto = {
                                exito: false,
                                mensaje: 'Error al mostrar reto',
                                error: retoError.message,
                                retoId
                            };
                            console.error('‚ùå [PADRE] Error al mostrar reto:', retoError);
                        }
                    } else {
                        console.log('üéÆ [PADRE] Paso 3: No hay reto_id, ocultando retos');
                        try {
                            await manejarOcultarReto();
                            orquestacion.respuestas.reto = {
                                exito: true,
                                mensaje: 'No hay reto asociado, interfaz ocultada',
                                retoId: null
                            };
                        } catch (ocultarError) {
                            orquestacion.respuestas.reto = {
                                exito: true,
                                mensaje: 'Error al ocultar interfaz de retos',
                                error: ocultarError.message,
                                retoId: null
                            };
                        }
                    }

                    // 5. ORQUESTACI√ìN DE MEDIOS - con tiempo l√≠mite de 3 segundos
                    try {
                        console.log('üì∏ [PADRE] Paso 4: Solicitando medios para el punto');
                        const medios = await window.executeWithTimeout(
                            obtenerMediosParaPunto(puntoNormalizado),
                            3000,
                            'Tiempo excedido esperando respuesta de medios'
                        );
                        
                        // Mostrar medios si se encontraron
                        if (medios) {
                            const mostradoExitosamente = await mostrarMedios(medios);
                            orquestacion.respuestas.medios = {
                                exito: true,
                                mensaje: mostradoExitosamente ? 'Medios mostrados correctamente' : 'No se pudieron mostrar los medios',
                                datos: medios
                            };
                            console.log('‚úÖ [PADRE] Medios procesados:', mostradoExitosamente ? 'mostrados' : 'no mostrados');
                        } else {
                            orquestacion.respuestas.medios = {
                                exito: true,
                                mensaje: 'No se encontraron medios para este punto',
                                datos: null
                            };
                            console.log('‚ÑπÔ∏è [PADRE] No se encontraron medios para el punto');
                        }
                    } catch (mediosError) {
                        orquestacion.respuestas.medios = {
                            exito: false,
                            mensaje: 'Error al obtener/mostrar medios',
                            error: mediosError.message
                        };
                        console.error('‚ùå [PADRE] Error al obtener/mostrar medios:', mediosError);
                    }

                    // 6. AGREGACI√ìN DE RESULTADOS Y RESPUESTA FINAL
                    orquestacion.completado = true;
                    orquestacion.exito = orquestacion.respuestas.mapa.exito || 
                                        orquestacion.respuestas.audio.exito || 
                                        orquestacion.respuestas.reto.exito;
                    
                    const exitoTotal = Object.values(orquestacion.respuestas).every(r => r.exito);
                    console.log('üéâ [PADRE] Orquestaci√≥n completada ' + (exitoTotal ? 'exitosamente' : 'con errores') + ' para:', idLog);
                    
                    // 7. ENV√çO DE RESPUESTA AL COMPONENTE ORIGEN
                    // Devolver informaci√≥n detallada al componente que solicit√≥ la orquestaci√≥n
                    const resultadoOrquestacion = {
                        exito: exitoTotal,
                        mensaje: exitoTotal ? 
                            `Orquestaci√≥n completa para ${idLog}` : 
                            `Orquestaci√≥n parcial para ${idLog} (algunos componentes fallaron)`,
                        punto: puntoNormalizado,
                        paradaCompleta: paradaCompleta || punto,
                        audio: audioId ? { 
                            id: audioId, 
                            exito: orquestacion.respuestas.audio.exito 
                        } : null,
                        reto: retoId ? { 
                            id: retoId, 
                            exito: orquestacion.respuestas.reto.exito 
                        } : null,
                        orquestacion: {
                            completado: orquestacion.completado,
                            componentes: {
                                mapa: orquestacion.respuestas.mapa.exito,
                                audio: orquestacion.respuestas.audio.exito,
                                reto: orquestacion.respuestas.reto.exito,
                                medios: orquestacion.respuestas.medios.exito
                            }
                        },
                        timestamp: Date.now()
                    };

                    console.log('üì§ [PADRE] Enviando respuesta detallada al origen:', resultadoOrquestacion);

                    // Enviar respuesta de vuelta al componente que solicit√≥ la orquestaci√≥n
                    try {
                        await enviarMensaje(origen, TIPOS_MENSAJE.SISTEMA.ESTADO, {
                            tipo: 'orquestacion_completada',
                            resultado: resultadoOrquestacion,
                            timestamp: Date.now()
                        });
                    } catch (error) {
                        console.error('‚ùå [PADRE] Error al enviar respuesta de orquestaci√≥n:', error);
                    }

                    return resultadoOrquestacion;
                    
                } catch (error) {
                    // En caso de error general, asegurarnos de enviar una respuesta
                    console.error('‚ùå [PADRE] Error general en la orquestaci√≥n:', error);
                    
                    orquestacion.error = error.message;
                    orquestacion.completado = false;
                    
                    // Notificar error al origen
                    try {
                        await enviarMensaje(orquestacion.origen, TIPOS_MENSAJE.SISTEMA.ERROR, {
                            codigo: 'ERROR_ORQUESTACION',
                            mensaje: `Error en la orquestaci√≥n: ${error.message}`,
                            origen: 'padre',
                            detalles: orquestacion,
                            timestamp: Date.now()
                        });
                    } catch (envioError) {
                        console.error('‚ùå [PADRE] Error al notificar fallo en orquestaci√≥n:', envioError);
                    }
                    
                    return {
                        exito: false,
                        error: error.message,
                        orquestacion,
                        timestamp: Date.now()
                    };
                }
            }
            
            /**
             * Funci√≥n auxiliar para enviar un mensaje estandarizado al componente de audio
             * con manejo bidireccional completo
             * @param {string} audioId - ID del audio a reproducir
             * @param {string} tipo - Tipo de audio (parada, tramo, etc.)
             * @returns {Promise<Object>} Resultado de la operaci√≥n
             */
            async function reproducirAudio(audioId, tipo = 'desconocido') {
                if (!audioId) {
                    logger.warn('Se intent√≥ reproducir un audio sin ID');
                    return { exito: false, error: 'ID de audio no proporcionado' };
                }
                
                console.log(`üéµ [PADRE] Enviando reproducir audio: ${audioId} (${tipo})`);
                
                try {
                    // Usar el ID del componente de audio desde CONFIG para garantizar consistencia
                    const hijoAudioId = CONFIG.HIJOS.AUDIO.id;
                    
                    // Enviar mensaje con solicitud de confirmaci√≥n
                    const respuesta = await enviarMensaje(hijoAudioId, TIPOS_MENSAJE.AUDIO.REPRODUCIR, {
                        audioId,
                        id: audioId, // Mantener compatibilidad con implementaciones anteriores
                        tipo,
                        requireConfirmation: true, // Flag para solicitar confirmaci√≥n
                        timestamp: Date.now()
                    });
                    
                    // Verificar si hay respuesta y si fue exitosa
                    if (!respuesta) {
                        logger.warn(`No se recibi√≥ respuesta al enviar comando de reproducci√≥n para ${audioId}`);
                        return { 
                            exito: false, 
                            error: 'No se recibi√≥ respuesta del componente de audio',
                            audioId,
                            tipo
                        };
                    }
                    
                    logger.info(`Audio ${audioId} enviado para reproducci√≥n`, { 
                        exito: respuesta.exito || false, 
                        respuesta 
                    });
                    
                    return {
                        exito: true,
                        audioId,
                        tipo,
                        respuesta,
                        timestamp: Date.now()
                    };
                } catch (error) {
                    const errorMsg = `Error al reproducir audio ${audioId}: ${error.message}`;
                    logger.error(errorMsg, { audioId, tipo, error });
                    return { exito: false, error: errorMsg, audioId, tipo };
                }
            }

            // Agregar funci√≥n para diagnosticar la comunicaci√≥n
            window.diagnosticarComunicacion = async function(componenteId) {
                console.log(`üìä [PADRE] Diagn√≥stico de comunicaci√≥n para ${componenteId || 'todos'}`);
                
                try {
                    // Si no se especifica componente, probar con todos
                    const componentes = componenteId ? 
                        [componenteId] : 
                        Object.values(CONFIG.HIJOS).map(h => h.id);
                    
                    const resultados = {};
                    
                    for (const id of componentes) {
                        console.log(`üîÑ [PADRE] Probando comunicaci√≥n con: ${id}`);
                        try {
                            // Enviar ping con timeout de 2 segundos
                            const respuesta = await window.executeWithTimeout(
                                enviarMensaje(id, TIPOS_MENSAJE.SISTEMA.PING, {
                                    timestamp: Date.now(),
                                    origen: 'padre_diagnostico'
                                }),
                                2000,
                                `Timeout esperando respuesta de ${id}`
                            );
                            
                            resultados[id] = {
                                exito: true,
                                respuesta,
                                latencia: Date.now() - (respuesta.timestamp || 0)
                            };
                            console.log(`‚úÖ [PADRE] Comunicaci√≥n exitosa con ${id}:`, resultados[id]);
                        } catch (error) {
                            resultados[id] = {
                                exito: false,
                                error: error.message
                            };
                            console.error(`‚ùå [PADRE] Error de comunicaci√≥n con ${id}:`, error.message);
                        }
                    }
                    
                    return {
                        timestamp: Date.now(),
                        resultados
                    };
                } catch (error) {
                    console.error('‚ùå [PADRE] Error en diagn√≥stico de comunicaci√≥n:', error);
                    return {
                        exito: false,
                        error: error.message,
                        timestamp: Date.now()
                    };
                }
            };

            // 6. REGISTRO DE CONTROLADORES DE MENSAJES
            async function registrarControladoresTotales() {
                console.log('üìù [PADRE] Registrando controladores de mensajes...');

                // Remover cualquier manejador existente para evitar duplicaciones
                if (window.handleHijo5CasaMessages) {
                    window.removeEventListener('message', window.handleHijo5CasaMessages);
                    console.log('üîÑ [PADRE] Manejador anterior de mensajes hijo5-casa eliminado');
                }
                
                // Define a global handler for hijo5-casa messages
                window.handleHijo5CasaMessages = function(event) {
                    try {
                        // Only process messages that might be from hijo5-casa
                        if (event.source === document.getElementById('hijo5-casa')?.contentWindow) {
                            // Ignore Grammarly messages immediately
                            const data = event.data;
                            if (data && (data.__grammarly || data._grammarly || data.grammarly_report || data.ext_id || data.extension_id)) {
                                console.debug('[DEBUG] Ignorando mensaje de Grammarly desde hijo5-casa');
                                return;
                            }
                            
                            console.log('[DEBUG] Mensaje recibido de hijo5-casa:', data);
                            
                            // Check if the message has the required fields
                            const requiredFields = ['tipo', 'datos'];
                            const missingFields = requiredFields.filter(field => !data || !data.hasOwnProperty(field));
                            
                            if (missingFields.length > 0) {
                                console.warn(`[DEBUG] Mensaje de hijo5-casa con campos requeridos faltantes: ${missingFields.join(', ')}`, data);
                                
                                // Log extra details to help debug
                                if (data) {
                                    console.log('[DEBUG] Tipo de mensaje:', typeof data);
                                    console.log('[DEBUG] Keys disponibles:', Object.keys(data));
                                }
                            } else {
                                // Valid message, try to handle it directly if possible
                                console.log('[DEBUG] Mensaje v√°lido de hijo5-casa:', data.tipo);
                                if (data.tipo === 'SISTEMA.CAMBIO_MODO' && typeof manejarCambioModo === 'function') {
                                    console.log('[DEBUG] Procesando mensaje de cambio de modo');
                                    try {
                                        manejarCambioModo({origen: 'hijo5-casa', datos: data.datos});
                                    } catch (e) {
                                        console.error('[DEBUG] Error al manejar cambio de modo:', e);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.error('[DEBUG] Error al procesar mensaje de hijo5-casa:', error);
                    }
                };
                
                // Add the debug handler
                // Eliminar manejador anterior si existe y a√±adir el nuevo
            if (window._hijo5CasaMessageHandlerRegistered) {
                console.log('üîÑ [PADRE] Evitando registro duplicado del manejador de hijo5-casa');
            } else {
                window.addEventListener('message', window.handleHijo5CasaMessages);
                window._hijo5CasaMessageHandlerRegistered = true;
                console.log('‚úÖ [PADRE] Manejador global para hijo5-casa registrado');
            }

                // Registrar cada controlador con nombre directo para evitar problemas de referencia
                const controladores = {};
                
                // Registrar controladores del sistema
                controladores[TIPOS_MENSAJE.SISTEMA.ERROR] = manejarErrorSistema;
                controladores[TIPOS_MENSAJE.SISTEMA.INICIALIZACION_COMPLETADA] = manejarHijoInicializado;
                controladores[TIPOS_MENSAJE.SISTEMA.CAMBIO_MODO] = manejarCambioModo;
                
                // Registrar controladores de datos
                controladores[TIPOS_MENSAJE.DATOS.SOLICITAR_PARADAS] = manejarSolicitudArrayParadas;
                
                // Registrar controladores de navegaci√≥n (Ver js/comunicacion-componentes.md)
                controladores[TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA] = manejarSeleccionPuntoCasa;
                console.log(`üéØ [PADRE] Registrando controlador para cambio de parada: ${TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA}`);
                
                // Registrar controladores de audio
                controladores[TIPOS_MENSAJE.AUDIO.FINALIZADO] = manejarAudioFinalizado;
                console.log(`üîä [PADRE] Registrando controlador para audio finalizado: ${TIPOS_MENSAJE.AUDIO.FINALIZADO}`);
                
                // Registrar controladores de retos
                controladores[TIPOS_MENSAJE.RETO.MOSTRAR] = manejarMostrarReto;
                controladores[TIPOS_MENSAJE.RETO.OCULTAR] = manejarOcultarReto;
                controladores[TIPOS_MENSAJE.RETO.COMPLETADO] = manejarRetoCompletado;
                
                // Otros controladores
                controladores['MAPA.ACTUALIZAR'] = manejarActualizacionMapa;
                controladores[TIPOS_MENSAJE.MEDIOS.EVENTO] = manejarEventosMedios;

                // Agregar nuevo controlador para mensajes PING (diagn√≥stico de comunicaci√≥n)
                controladores[TIPOS_MENSAJE.SISTEMA.PING] = manejarPing;

                console.log('üéØ [PADRE] Controladores a registrar:', Object.keys(controladores));
                console.log('üîç [PADRE] Verificando registro de NAVEGACION.CAMBIO_PARADA:', TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA);

                // Registro individual de controladores para mayor control
                Object.entries(controladores).forEach(([tipo, handler]) => {
                    try {
                        console.log(`üìå [PADRE] Registrando controlador para: ${tipo}`);
                        registrarControlador(tipo, handler);
                        console.log(`‚úÖ [PADRE] Controlador para ${tipo} registrado correctamente`);
                    } catch (error) {
                        console.error(`‚ùå [PADRE] Error al registrar controlador para ${tipo}:`, error);
                        logger.error(`Error al registrar controlador para ${tipo}:`, error);
                    }
                });
                console.log('‚úÖ [PADRE] Controladores de mensajes registrados correctamente.');
                logger.info('Controladores de mensajes registrados.');
            }
            
            /**
             * Maneja los mensajes de PING (diagn√≥stico de comunicaci√≥n)
             * @param {Object} msg - Mensaje de ping recibido
             * @returns {Object} Respuesta con el timestamp
             */
            function manejarPing(msg) {
                console.log('üì° [PADRE] Ping recibido de:', msg.origen);
                // Simplemente respondemos con un timestamp para medir latencia
                return {
                    exito: true,
                    mensaje: 'Pong desde padre',
                    timestamp: Date.now(),
                    origen: 'padre',
                    timestampOriginal: msg.datos?.timestamp
                };
            }

            // Marcar la aplicaci√≥n como completamente inicializada
            window.appInitStatus = window.appInitStatus || {};
            window.appInitStatus.completed = true;
            window.appInitStatus.completedTimestamp = Date.now();
            window.appInitStatus.iifePrincipalFinalizada = true;
            
            console.log('‚úÖ [PADRE] Inicializaci√≥n de la aplicaci√≥n completada - Total tiempo:', 
                       (window.appInitStatus.completedTimestamp - window.appInitStatus.startTimestamp) + 'ms');
            window.debugLog && window.debugLog('Aplicaci√≥n completamente inicializada');
        } catch (error) {
            console.error('‚ùå [PADRE] Error en ejecuci√≥n de la IIFE:', error);
            window.debugLog && window.debugLog(`Error en ejecuci√≥n de IIFE: ${error.message}`);
            window.handleApplicationError(error, 'ejecucion_IIFE');
        }
    })().catch(error => {
        console.error('‚ùå [PADRE] Error as√≠ncrono no capturado:', error);
        window.debugLog && window.debugLog(`Error as√≠ncrono no capturado: ${error.message}`);
        window.handleApplicationError(error, 'error_asincrono');
    });
    
    // Agregar un manejador global para capturar errores as√≠ncronos
    window.addEventListener('error', function(event) {
        console.error('‚ùå [PADRE] Error global no capturado:', event.error || event.message);
        window.handleApplicationError(event.error || new Error(event.message), 'error_global');
    });
    
    // Capturar promesas rechazadas no manejadas
    window.addEventListener('unhandledrejection', function(event) {
        console.error('‚ùå [PADRE] Promesa rechazada no manejada:', event.reason);
        window.handleApplicationError(event.reason, 'promesa_rechazada');
    });
        </script>
</body>
</html>
                // Ocultar el reto despu√©s de completarse
                await manejarOcultarReto();
                
                return { 
                    exito: true, 
                    retoId,
                    timestamp: Date.now()
                };
            }
            
            /**
             * Maneja la finalizaci√≥n de la reproducci√≥n de un audio
             * @param {Object} msg - Mensaje con los datos del audio finalizado
             * @returns {Promise<Object>} Resultado de la operaci√≥n
             */
            window.manejarAudioFinalizado = window.manejarAudioFinalizado || async function(msg) {
                console.log('üîä [PADRE] manejarAudioFinalizado llamado con:', msg);
                try {
                    const { audioId, id, tipo, exito, origen, timestamp } = msg?.datos || {};
                    console.log('üîä [PADRE] Audio finalizado:', { audioId, id, tipo, exito, origen });
                    
                    // Usar cualquiera de los dos IDs que podr√≠an venir en el mensaje
                    const audioIdFinal = audioId || id;
                    
                    if (!audioIdFinal) {
                        console.warn('‚ö†Ô∏è [PADRE] Recibida finalizaci√≥n de audio sin ID');
                        logger.warn('Recibida finalizaci√≥n de audio sin ID');
                        return { 
                            exito: false, 
                            error: 'ID de audio no proporcionado',
                            timestamp: Date.now()
                        };
                    }
                    
                    logger.info(`Audio ${audioIdFinal} finalizado`, { tipo, exito, origen });
                    
                    // Si se requiere alguna acci√≥n despu√©s de que un audio finalice,
                    // como mostrar un reto o avanzar autom√°ticamente, se har√≠a aqu√≠
                    
                    // Por ejemplo, se podr√≠a buscar si hay alguna parada con ese audio_id
                    // y verificar si tiene un reto asociado para mostrarlo autom√°ticamente
                    const paradaAsociada = AVENTURA_PARADAS.find(p => p.audio_id === audioIdFinal);
                    if (paradaAsociada) {
                        console.log(`üéß [PADRE] Audio ${audioIdFinal} asociado a parada ${paradaAsociada.padreid}`);
                        logger.debug(`Audio ${audioIdFinal} asociado a parada ${paradaAsociada.padreid}`);
                        
                        // Verificar si hay un reto asociado que podr√≠a mostrarse autom√°ticamente
                        const retoId = extraerRetoId(paradaAsociada);
                        if (retoId) {
                            console.log(`üéÆ [PADRE] Audio finalizado - Parada tiene reto: ${retoId}`);
                            
                            // Si estamos en modo casa y se quiere mostrar autom√°ticamente
                            // (descomentar este bloque para activar mostrar retos autom√°ticamente)
                            /*
                            if (estadoApp.modo.actual === 'casa') {
                                const retoElement = document.getElementById('hijo4');
                                if (retoElement && retoElement.style.display === 'none') {
                                    await manejarMostrarReto({ datos: { retoId } });
                                }
                            }
                            */
                        }
                    } else {
                        console.log(`üîç [PADRE] No se encontr√≥ parada asociada al audio ${audioIdFinal}`);
                    }
                    
                    // Si hay alguna acci√≥n personalizada para audios espec√≠ficos
                    switch (audioIdFinal) {
                        case 'audio-bienvenida':
                            console.log('üéµ [PADRE] Audio de bienvenida finalizado, mostrando instrucciones');
                            // Acci√≥n espec√≠fica para el audio de bienvenida
                            break;
                            
                        case 'audio-instrucciones':
                            console.log('üéµ [PADRE] Audio de instrucciones finalizado');
                            // Acci√≥n espec√≠fica para el audio de instrucciones
                            break;
                            
                        // A√±adir m√°s casos espec√≠ficos aqu√≠
                    }
                    
                    return { 
                        exito: true, 
                        audioId: audioIdFinal,
                        paradaId: paradaAsociada?.padreid || null,
                        timestamp: Date.now()
                    };
                } catch (error) {
                    console.error('‚ùå [PADRE] Error al manejar audio finalizado:', error);
                    logger.error('Error al manejar audio finalizado:', error);
                    return {
                        exito: false,
                        error: `Error al manejar audio finalizado: ${error.message}`,
                        timestamp: Date.now()
                    };
                }
            }
            
            // La funci√≥n updateMapDebug ya est√° definida globalmente arriba
            
            // Marcar la aplicaci√≥n como completamente inicializada
            window.appInitStatus = window.appInitStatus || {};
            window.appInitStatus.completed = true;
            window.appInitStatus.completedTimestamp = Date.now();
            window.appInitStatus.iifePrincipalFinalizada = true;
            
            console.log('‚úÖ [PADRE] Inicializaci√≥n de la aplicaci√≥n completada - Total tiempo:', 
                       (window.appInitStatus.completedTimestamp - window.appInitStatus.startTimestamp) + 'ms');
            window.debugLog && window.debugLog('Aplicaci√≥n completamente inicializada');
        } catch (error) {
            console.error('‚ùå [PADRE] Error en ejecuci√≥n de la IIFE:', error);
            window.debugLog && window.debugLog(`Error en ejecuci√≥n de IIFE: ${error.message}`);
            window.handleApplicationError(error, 'ejecucion_IIFE');
        }
    })().catch(error => {
        console.error('‚ùå [PADRE] Error as√≠ncrono no capturado:', error);
        window.debugLog && window.debugLog(`Error as√≠ncrono no capturado: ${error.message}`);
        window.handleApplicationError(error, 'error_asincrono');
    });
    
    // Agregar un manejador global para capturar errores as√≠ncronos
    window.addEventListener('error', function(event) {
        console.error('‚ùå [PADRE] Error global no capturado:', event.error || event.message);
        window.handleApplicationError(event.error || new Error(event.message), 'error_global');
    });
    
    // Capturar promesas rechazadas no manejadas
    window.addEventListener('unhandledrejection', function(event) {
        console.error('‚ùå [PADRE] Promesa rechazada no manejada:', event.reason);
        window.handleApplicationError(event.reason, 'promesa_rechazada');
    });
        </script>
</body>
</html>
</html>
