<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Padre - Coordinador Central</title>
    
    <!-- Estilos CSS para el mapa -->
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #mapa {
            width: 100%;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background-color: #f0f0f0;
        }
        
        /* Loading indicator */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
        }
        
        /* Estilos para los iframes hijos */
        .iframe-hijo {
            border: none;
            position: fixed;
            z-index: 1000;
            pointer-events: auto;
            background: transparent;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        /* Estilos espec√≠ficos para cada iframe */
        #hijo1-hamburguesa {
            left: 10px;
            bottom: 10px;
            width: 50px;
            height: 50px;
            z-index: 3001;
        }
        
        #hijo1-opciones {
            right: 10px;
            bottom: 10px;
            width: 50px;
            height: 50px;
            z-index: 3001;
        }
        
        #hijo2 {
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            height: 70px;
            z-index: 2000;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        #hijo3 {
            right: 20px;
            top: 100px;
            width: 300px;
            height: 80px;
            z-index: 2000;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        #hijo4 {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            height: 70vh;
            max-height: 600px;
            z-index: 2000;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.3);
            display: none; /* Inicialmente oculto */
        }
        
        /* Hijo 5 - Bot√≥n casa */
        #hijo5-casa {
            top: 70px;
            right: 0;
            width: 99%;
            height: 85px;
            z-index: 10000;
            border: 1px solid red;
            margin: 0;
            padding: 0;
            border-radius: 0;
        }
        
        /* Estilos para los marcadores */
        .marcador {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            text-align: center;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        
        .marcador-inicio {
            background-color: #4CAF50; /* Verde para el inicio */
            border: 2px solid #388E3C;
            width: 36px;
            height: 36px;
            font-size: 14px;
        }
        
        .marcador-parada {
            background-color: #2196F3; /* Azul para las paradas */
            border: 2px solid #1976D2;
            width: 32px;
            height: 32px;
            font-size: 12px;
        }
        
        .marcador-destacado {
            animation: pulse 1.5s infinite;
            transform: scale(1.1);
            z-index: 1000 !important;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        /* Estilos para los popups */
        .popup-parada {
            padding: 10px;
            text-align: center;
        }
        
        .popup-parada h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }
        
        .popup-parada p {
            margin: 5px 0;
            font-size: 14px;
            color: #666;
        }
        
        .btn-navegar {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 8px 15px;
            margin-top: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        .btn-navegar:hover {
            background-color: #1976D2;
        }
        
        /* Ajustes para los controles del mapa */
        .leaflet-control-zoom {
            margin-top: 60px !important; /* Para dejar espacio para el logo */
        }
        
        .leaflet-control-attribution {
            font-size: 10px;
            padding: 2px 5px;
            background: rgba(255, 255, 255, 0.8);
        }
        
        .leaflet-container {
            background: #f8f9fa;
        }
        
        /* Estilos para los marcadores personalizados */
        .marcador {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .marcador:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            z-index: 1000 !important;
        }
        
        .marcador-inicio {
            background-color: #28a745; /* Verde para el punto de inicio */
            width: 36px;
            height: 36px;
            margin-top: -18px !important;
            margin-left: -18px !important;
        }
        
        .marcador-parada {
            background-color: #007bff; /* Azul para las paradas normales */
            width: 32px;
            height: 32px;
            margin-top: -16px !important;
            margin-left: -16px !important;
        }
        
        .marcador-contenido {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Ajustes para el contenedor del mapa */
        #mapa {
            z-index: 1;
        }
    </style>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
</head>

<body>
    <!-- Contenedor del mapa -->
    <div id="mapa" style="width: 100%; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1;"></div>

    <!-- Logo de la aplicaci√≥n -->
    <img id="logo-aventura" 
         src="https://valenciavguides.github.io/Aventura-1-esp-padre-con-hijos/fotos_Av1/LOGO%20LETRAS%20FINAL%20transparente%20recorte.png" 
         alt="Logo" 
         style="position: fixed; top: -32px; left: 50%; transform: translateX(-50%); z-index: 3000; width: 360px; height: 140px;" />

    <!-- Mensaje de informaci√≥n -->
    <div id="info-parada"></div>
    
    <!-- Fondo blanco para el logo con borde naranja -->
    <div style="position: fixed; top: 0; left: 0; right: 0; width: 99%; margin: 0 auto; height: 80px; background: white; z-index: 2999; border: 2px solid #ec7c26; border-top: none; border-bottom-left-radius: 15px; border-bottom-right-radius: 15px;"></div>

    <!-- Contenedores para los iframes hijos -->
    <iframe id="hijo1-hamburguesa" class="iframe-hijo" src="./botones-y-subfunciones-hamburguesa.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo1-opciones" class="iframe-hijo" src="./botones-y-subfunciones-opciones.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo5-casa" class="iframe-hijo" src="./Av1-boton-casa.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo3" class="iframe-hijo" src="./Av1_audio_esp.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo2" class="iframe-hijo" src="./Av1-botones-coordenadas.html" allow="geolocation" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo4" class="iframe-hijo" src="./Av1-esp-retos-preguntas.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>

    <!-- Script principal -->
    <script type="module">
        // ================== IMPORTACI√ìN DE M√ìDULOS ==================
        import { Mensajeria, TIPOS_MENSAJE } from './mensajeria.js';
        
        // Variables globales
        let estadoGlobal = {
            mapa: null,
            modo: 'inactivo',
            paradaActual: null,
            tramoActual: null,
            gpsActivo: false,
            audioReproduciendo: false,
            retoActivo: null,
            config: {
                debug: true,
                maxReintentos: 3,
                tiempoEsperaInicial: 1000
            },
            coordenadasParadas: new Map(),
            marcadores: new Map(),
            rutas: new Map(),
            hijosConectados: new Map(),
            metricas: {
                mensajesEnviados: 0,
                mensajesRecibidos: 0,
                errores: 0
            },
            errores: []
        };
        
        // Mostrar indicador de carga
        const loadingEl = document.createElement('div');
        loadingEl.className = 'loading';
        loadingEl.textContent = 'Cargando mapa...';
        document.body.appendChild(loadingEl);
        
        // Estado global
        const estadoGlobal = {
            mapa: null,
            modo: 'inactivo',
            gpsActivo: false,
            config: {
                debug: true,
                maxReintentos: 3,
                tiempoEsperaInicial: 1000
            }
        };
        
        // ================== CONFIGURACI√ìN GLOBAL ==================
        const CONFIG = {
            iframeId: 'padre',
            debug: true,
            logLevel: 1
        };

        // ================== ESTADO GLOBAL MEJORADO ==================
        const estadoGlobal = {
            // Estado de la aplicaci√≥n
            modo: 'casa',
            gpsActivo: false,
            paradaActual: 0,
            tramoActual: 0,
            
            // Gesti√≥n de hijos
            hijosListos: new Set(),
            hijosConectados: new Map(), // Mapa de estado de conexi√≥n de hijos
            
            // Componentes
            mapa: null,
            audioReproduciendo: false,
            retoActivo: null,
            
            // Datos
            coordenadasParadas: new Map(),
            marcadores: new Map(),
            rutas: new Map(),
            
            // Estado del sistema
            errores: [],
            ultimaActualizacion: null,
            version: '2.0.0',
            
            // Rendimiento
            metricas: {
                mensajesEnviados: 0,
                mensajesRecibidos: 0,
                ultimaComprobacion: Date.now()
            },
            
            // Configuraci√≥n
            config: {
                maxReintentos: 3,
                tiempoEsperaInicial: 1000,
                debug: true,
                tiempoEsperaHijos: 10000, // 10 segundos para que los hijos se conecten
                intervaloMonitoreo: 30000, // Verificar estado de hijos cada 30 segundos
                maxReintentosConexion: 3
            }
        };

        // Lista de hijos conocidos con sus configuraciones
        const HIJOS_SISTEMA = [
            { id: 'hijo1-hamburguesa', tipo: 'menu', requerido: false },
            { id: 'hijo1-opciones', tipo: 'menu', requerido: false },
            { id: 'hijo2', tipo: 'navegacion', requerido: true },
            { id: 'hijo3', tipo: 'audio', requerido: true },
            { id: 'hijo4', tipo: 'retos', requerido: true },
            { id: 'hijo5-casa', tipo: 'ui', requerido: true }
        ];
        
        // Mapa de tipos de mensajes que cada hijo debe manejar
        const MENSAJES_POR_TIPO = {
            audio: [
                TIPOS_MENSAJE.AUDIO.REPRODUCIR,
                TIPOS_MENSAJE.AUDIO.PAUSAR,
                TIPOS_MENSAJE.AUDIO.DETENER,
                TIPOS_MENSAJE.AUDIO.ESTADO
            ],
            navegacion: [
                TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA,
                TIPOS_MENSAJE.NAVEGACION.CAMBIO_TRAMO,
                TIPOS_MENSAJE.NAVEGACION.ESTADO,
                TIPOS_MENSAJE.GPS.ESTADO
            ],
            retos: [
                TIPOS_MENSAJE.RETOS.ABRIR,
                TIPOS_MENSAJE.RETOS.CERRAR,
                TIPOS_MENSAJE.RETOS.COMPLETADO,
                TIPOS_MENSAJE.RETOS.VALIDAR
            ],
            ui: [
                TIPOS_MENSAJE.UI.ACTUALIZAR,
                TIPOS_MENSAJE.UI.MOSTRAR_IMAGEN,
                TIPOS_MENSAJE.UI.MOSTRAR_VIDEO,
                TIPOS_MENSAJE.UI.CERRAR_MEDIA
            ]
        };

        // ================== DATOS DE PARADAS ==================
        const AVENTURA_PARADAS = [
            // Parada 0 ‚Äì INICIO (Torres de Serranos start) reto 2 (223, 226, 228, 229)
            { padreid: "padre-P-0", tipo: "inicio", parada_id: 'P-0', audio_id: "audio-P-0", reto_id: "R-2" },
            // tramo 1 (Torres de Serranos ‚Üí Plaza de la crida) (2, 126,)
            { padreid: "padre-TR-1", tipo: "tramo", tramo_id: 'TR-1', audio_id: "audio-TR-1" },
            // Parada 1 - Plaza de la crida (Puente de Serranos) Reto 3 (233) //
            { padreid: "padre-P-1", tipo: "parada", parada_id: 'P-1', audio_id: "audio-P-1", reto_id: "R-3" },
            // tramo 2 (Plaza de la crida ‚Üí Calle Muro de Santa Ana) (81) //
            { padreid: "padre-TR-2", tipo: "tramo", tramo_id: 'TR-2', audio_id: "audio-TR-2" },
            // Parada 2 (Calle Muro de Santa Ana) Reto 4 (68) //
            { padreid: "padre-P-2", tipo: "parada", parada_id: 'P-2', audio_id: "audio-P-2", reto_id: "R-4" },
            // tramo 3 (Calle Muro de Santa Ana ‚Üí Palacio de los Borgia) (52) //
            { padreid: "padre-TR-3", tipo: "tramo", tramo_id: 'TR-3', audio_id: "audio-TR-3" },
            // Parada 3 (Iglesia de San Lorenzo) Reto 5 (686, 682-B, 462, 683, 684) //
            { padreid: "padre-P-3", tipo: "parada", parada_id: 'P-3', audio_id: "audio-P-3", reto_id: "R-5" },
            // tramo 4 (Iglesia de San Lorenzo ‚Üí Plaza de la Virgen) (465-B) //
            { padreid: "padre-TR-4", tipo: "tramo", tramo_id: 'TR-4', audio_id: "audio-TR-4" },
            // Parada 4 (Plaza de la Virgen) Reto 6 (466, 467) //
            { padreid: "padre-P-4", tipo: "parada", parada_id: 'P-4', audio_id: "audio-P-4", reto_id: "R-6" },
            // Parada 5 (Plaza de la Virgen) Reto 7, 8 Puzzle plaza de la virgen (468)  //
            { 
                padreid: "padre-P-5",
                tipo: "parada", 
                parada_id: 'P-5', 
                audio_id: "audio-P-5", 
                retos: [
                    { tipo: "reto", id: "R-7" },
                    { tipo: "puzzle", id: "PZ-8" }
                ] 
            },
            // tramo 5 (Plaza de la Virgen ‚Üí Plaza de la Almo√≠na) (477-B, 479, 141, 83, 8-C) //
            { padreid: "padre-TR-5", tipo: "tramo", tramo_id: 'TR-5', audio_id: "audio-TR-5" },
            // Parada 6 (Panel cer√°mico muro Catedral) Reto 9 (434, 440, 441, 442) //
            { padreid: "padre-P-6", tipo: "parada", parada_id: 'P-6', audio_id: "audio-P-6", reto_id: "R-9" },
            // Parada 7 (Capilla exterior catedral) Reto 10 (443, 444, 445) //
            { padreid: "padre-P-7", tipo: "parada", parada_id: 'P-7', audio_id: "audio-P-7", reto_id: "R-10" },
            // Parada 8 (Capilla exterior catedral) Reto 11 (445) //
            { padreid: "padre-P-8", tipo: "parada", parada_id: 'P-8', audio_id: "audio-P-8", reto_id: "R-11" },
            // Parada 9 (Arco Novo Catedral y Puerta Negra Bas√≠lica) (446, 355, 447, 11-B, 451, 452) //
            { padreid: "padre-P-9", tipo: "parada", parada_id: 'P-9', audio_id: "audio-P-9" },
            // Parada 10 (Casa del Punt de Gantxo) Reto 12 (51-C, 454, 455, 455-B, 456, 148) //
            { padreid: "padre-P-10", tipo: "parada", parada_id: 'P-10', audio_id: "audio-P-10", reto_id: "R-12"  },
            // tramo 6 (Plaza de la Almo√≠na (casa del punt de Gantxo) ‚Üí Plaza Decimo Junio Bruto) (457, 10-B)//
            { padreid: "padre-TR-6", tipo: "tramo", tramo_id: 'TR-6', audio_id: "audio-TR-6" },
            // Parada 11 (Museo arqueol√≥gico La Almo√≠na) Reto 13 (458) //
            { padreid: "padre-P-11", tipo: "parada", parada_id: 'P-11', audio_id: "audio-P-11", reto_id: "R-13" },
            // Parada 12 (Museo arqueol√≥gico La Almo√≠na 2) (459, 460, 461) //
            { padreid: "padre-P-12", tipo: "parada", parada_id: 'P-12', audio_id: "audio-P-12" },
            // Parada 13 (Vista de la Catedral, Cimborrio) Reto 14 (8-C, 464) //
            { padreid: "padre-P-13", tipo: "parada", parada_id: 'P-13', audio_id: "audio-P-13", reto_id: "R-14" },
            // tramo 7 (Museo arqueol√≥gico La Almo√≠na ‚Üí Palacio Arzobispal) (85) //
            { padreid: "padre-TR-7", tipo: "tramo", tramo_id: 'TR-7', audio_id: "audio-TR-7" },
            // Parada 14 (Palacio Arzobispal y Puerta Rom√°nica de la Catedral) Reto 15 (673, 86, 426-B, 141, 437, 438) //
            { padreid: "padre-P-14", tipo: "parada", parada_id: 'P-14', audio_id: "audio-P-14", reto_id: "R-15" },
            // Parada 15 (Puerta Rom√°nica de la Catedral) (439) //
            { padreid: "padre-P-15", tipo: "parada", parada_id: 'P-15', audio_id: "audio-P-15" },
            // tramo 8 (Puerta Rom√°nica de la Catedral ‚Üí Plaza del Ayuntamiento) (125) //
            { padreid: "padre-TR-8", tipo: "tramo", tramo_id: 'TR-8', audio_id: "audio-TR-8" },
            // Parada 16 (Plaza del Ayuntamiento) (13-B, 263, 332, 14-C) //
            { padreid: "padre-P-16", tipo: "parada", parada_id: 'P-16', audio_id: "audio-P-16" },
            // tramo 9 (Plaza del Ayuntamiento ‚Üí Edificio del Ayuntamiento) (334, 335) //
            { padreid: "padre-TR-9", tipo: "tramo", tramo_id: 'TR-9', audio_id: "audio-TR-9" },
            // Parada 17 (Edificio del Ayuntamiento) Reto 16 (336, 337, 338) //
            { padreid: "padre-P-17", tipo: "parada", parada_id: 'P-17', audio_id: "audio-P-17", reto_id: "R-16" },
            // Parada 18 (Edificio del Ayuntamiento, leyenda del murci√©lago) (339, 340, 341, 54) //
            { padreid: "padre-P-18", tipo: "parada", parada_id: 'P-18', audio_id: "audio-P-18" },
            // tramo 10 (Edificio del Ayuntamiento ‚Üí Estaci√≥n del Norte) (87, 15-C) //
            { padreid: "padre-TR-10", tipo: "tramo", tramo_id: 'TR-10', audio_id: "audio-TR-10" },
            // Parada 19 (Estaci√≥n del Norte) Reto 17, 18 Puzzle Estaci√≥n del Norte (326) //
            { 
                padreid: "padre-P-19",
                tipo: "parada", 
                parada_id: 'P-19', 
                audio_id: "audio-P-19", 
                retos: [
                    { tipo: "reto", id: "R-17" },
                    { tipo: "puzzle", id: "PZ-18" }
                ] 
            },
            // tramo 11 (Estaci√≥n del Norte ‚Üí Plaza de Toros) (20-C, 323-B, 88) //
            { padreid: "padre-TR-11", tipo: "tramo", tramo_id: 'TR-11', audio_id: "audio-TR-11" },
            // Tramo 12 (Plaza de Toros ‚Üí Casa estilo √Årabe) (89, 3-D) //
            { padreid: "padre-TR-12", tipo: "tramo", tramo_id: 'TR-12', audio_id: "audio-TR-12" },
            // Parada 20 (Casa estilo √Årabe) Reto 19 (99) //
            { padreid: "padre-P-20", tipo: "parada", parada_id: 'P-20', audio_id: "audio-P-20", reto_id: "R-19" },
            // Parada 21 (Casa estilo √Årabe, mitad Aventura) (100) //
            { padreid: "padre-P-21", tipo: "parada", parada_id: 'P-21', audio_id: "audio-P-21" },
            // tramo 13 (Casa estilo √Årabe ‚Üí Palacio de Comunicaciones) (21-B) //
            { padreid: "padre-TR-13", tipo: "tramo", tramo_id: 'TR-13', audio_id: "audio-TR-13" },
            // Parada 22 (Palacio de Comunicaciones) Reto 20 y Reto 21 (700, 343, 344) //
            { padreid: "padre-P-22", tipo: "parada", parada_id: 'P-22', audio_id: "audio-P-22", retos: ["R-20", "R-21"] },
            // Parada 23 (Edificio Suay) Reto 21 (693, 693-B) //
            { padreid: "padre-P-23", tipo: "parada", parada_id: 'P-23', audio_id: "audio-P-23", reto_id: "R-21" },
            // tramo 14 (Palacio de Comunicaciones, edificio Suay ‚Üí Banco de Val√®ncia) (345, 347, 348, 22, 109) //
            { padreid: "padre-TR-14", tipo: "tramo", tramo_id: 'TR-14', audio_id: "audio-TR-14" },
            // Parada 24 (Banco de Valencia) Reto 22 (349, 350) //
            { padreid: "padre-P-24", tipo: "parada", parada_id: 'P-24', audio_id: "audio-P-24", reto_id: "R-22" },
            // tramo 15 (Banco de Val√®ncia ‚Üí Palacio del Marqu√©s de Dos Aguas) (351, 23-B, 352, 354) //
            { padreid: "padre-TR-15", tipo: "tramo", tramo_id: 'TR-15', audio_id: "audio-TR-15" },
            // Parada 25 (Palacio del Marqu√©s de Dos Aguas) (356, 357)//
            { padreid: "padre-P-25", tipo: "parada", parada_id: 'P-25', audio_id: "audio-P-25" },
            // tramo 16 (Palacio del Marqu√©s ‚Üí Mercado Central) (358, 359-B, 101) //
            { padreid: "padre-TR-16", tipo: "tramo", tramo_id: 'TR-16', audio_id: "audio-TR-16" },
            // Parada 26 (Mercado central) Reto23 (701, 24-D, 361, 362, 363, 364) //
            { padreid: "padre-P-26", tipo: "parada", parada_id: 'P-26', audio_id: "audio-P-26", reto_id: "R-23" },
            // tramo 17 (Mercado Central ‚Üí Iglesia de los Santos Juanes) (274, 27-C) //
            { padreid: "padre-TR-17", tipo: "tramo", tramo_id: 'TR-17', audio_id: "audio-TR-17" },
            // Parada 27 (Iglesia de los Santos Juanes) Reto 24) (365, 366) //
            { padreid: "padre-P-27", tipo: "parada", parada_id: 'P-27', audio_id: "audio-P-27", reto_id: "R-24" },
            // Parada 28 (Iglesia de los Santos Juanes reto 25) (367) //
            { padreid: "padre-P-28", tipo: "parada", parada_id: 'P-28', audio_id: "audio-P-28", reto_id: "R-25" },
            // tramo 18 (Iglesia Santos Juanes ‚Üí Lonja de Val√®ncia) (368, 369, 28, 370, 371, 372, 373, 374, 375, 376, 377) //
            { padreid: "padre-TR-18", tipo: "tramo", tramo_id: 'TR-18', audio_id: "audio-TR-18" },
            // Parada 29 (Lonja Puerta de Los Pecados barquero) Reto 27 (378, 379) //
            { padreid: "padre-P-29", tipo: "parada", parada_id: 'P-29', audio_id: "audio-P-29", reto_id: "R-27" },
            // Parada 30 (Lonja Puerta de Los Pecados √°rbol muerto) Reto 28 (380, 381) //
            { padreid: "padre-P-30", tipo: "parada", parada_id: 'P-30', audio_id: "audio-P-30", reto_id: "R-28" },
            // tramo 19 (Lonja G√°rgolas) (383) //
            { padreid: "padre-TR-19", tipo: "tramo", tramo_id: 'TR-19', audio_id: "audio-TR-19" },
            // Parada 31 (Lonja G√°rgolas √°ngel vasija) Reto 29 (384) //
            { padreid: "padre-P-31", tipo: "parada", parada_id: 'P-31', audio_id: "audio-P-31", reto_id: "R-29" },
            // Parada 32 (Lonja G√°rgolas barbudo y le√≥n) Reto 30 (385) //
            { padreid: "padre-P-32", tipo: "parada", parada_id: 'P-32', audio_id: "audio-P-32", reto_id: "R-30" },
            // Parada 33 (Lonja G√°rgolas fornicador ventana) Reto 31, Puzzle 26 ) (386) //
            { padreid: "padre-P-33", tipo: "parada", parada_id: 'P-33', audio_id: "audio-P-33", retos: [ { tipo: "reto", id: "R-31" }, { tipo: "puzzle", id: "PZ-26" } ] },
            // tramo 20 (Lonja ‚Üí Plaza del Doctor Collado) (388, 389, 390, 391, 392) //
            { padreid: "padre-TR-20", tipo: "tramo", tramo_id: 'TR-20', audio_id: "audio-TR-20" },
            // tramo 21 (Plaza del Doctor Collado ‚Üí Plaza del Negrito) (333, 397, 41, 398, 198, 671, 522, 32-C) //
            { padreid: "padre-TR-21", tipo: "tramo", tramo_id: 'TR-21', audio_id: "audio-TR-21" },
            // Parada 34 (Fuente del Negrito) Reto 32 (382, 501) //
            { padreid: "padre-P-34", tipo: "parada", parada_id: 'P-34', audio_id: "audio-P-34", reto_id: "R-32" },
            // tramo 22 (Plaza del Negrito ‚Üí Calle Caballeros) (33-B, 486, 480-B) //
            { padreid: "padre-TR-22", tipo: "tramo", tramo_id: 'TR-22', audio_id: "audio-TR-22" },
            // Parada 35 (Palau de la Generalitat) (481-B, 482-B, 2-D) //
            { padreid: "padre-P-35", tipo: "parada", parada_id: 'P-35', audio_id: "audio-P-35" },
            // tramo 23 (Palacio de la Generalitat ‚Üí Calle de los Serranos - FINAL)  //
            { padreid: "padre-TR-23", tipo: "tramo", tramo_id: 'TR-23', audio_id: "audio-TR-23" },
            // Parada 36 (Torres de Serranos Final) //
            { padreid: "padre-P-36", tipo: "parada", parada_id: 'P-36', audio_id: "audio-P-36" }
        ];

        // ================== INICIALIZACI√ìN DE COORDENADAS ==================
        
        /**
         * Inicia el mapa de coordenadas de las paradas solicitando los datos al hijo2
         * @returns {Promise<boolean>} True si se solicitaron las coordenadas correctamente
         */
        async function inicializarCoordenadasParadas() {
            try {
                console.log('üîÑ Solicitando coordenadas al hijo2...');
                
                // Asegurarse de que el mapa de coordenadas est√© inicializado
                if (!estadoGlobal.coordenadasParadas) {
                    estadoGlobal.coordenadasParadas = new Map();
                }
                
                // Solicitar coordenadas al hijo2
                const respuesta = await Mensajeria.enviarMensaje('hijo2', {
                    tipo: 'solicitar_coordenadas_paradas',
                    timestamp: Date.now()
                });
                
                if (respuesta && respuesta.coordenadas) {
                    console.log('‚úÖ Coordenadas recibidas del hijo2:', respuesta.coordenadas);
                    // Actualizar el estado global con las coordenadas recibidas
                    estadoGlobal.coordenadasParadas = new Map(Object.entries(respuesta.coordenadas));
                    return true;
                } else {
                    console.error('‚ùå No se recibieron coordenadas del hijo2');
                    throw new Error('No se pudieron obtener las coordenadas del componente de mapa');
                }
                
            } catch (error) {
                console.error('‚ùå Error al obtener coordenadas del hijo2:', error);
                throw error; // Propagar el error para que el sistema lo maneje
            }
        }
        
        // ================== FUNCIONES AUXILIARES DE MARCADORES ==================
        
        /**
         * Crea los marcadores iniciales para todas las paradas
         */
        function crearMarcadoresIniciales() {
            if (!estadoGlobal.mapa) {
                console.warn('No se pueden crear marcadores: el mapa no est√° inicializado');
                return;
            }
            
            // Inicializar el grupo de marcadores si no existe
            if (!estadoGlobal.grupoMarcadores) {
                estadoGlobal.grupoMarcadores = L.layerGroup().addTo(estadoGlobal.mapa);
            } else {
                // Limpiar marcadores existentes
                estadoGlobal.grupoMarcadores.clearLayers();
            }
            
            // Inicializar el mapa de marcadores si no existe
            if (!estadoGlobal.marcadoresParadas) {
                estadoGlobal.marcadoresParadas = new Map();
            } else {
                estadoGlobal.marcadoresParadas.clear();
            }
            
            // Contadores para estad√≠sticas
            let marcadoresCreados = 0;
            let errores = 0;
            
            // Recorrer todas las paradas y crear marcadores
            AVENTURA_PARADAS.forEach(parada => {
                // Solo procesar paradas e inicio, no tramos
                if (parada.tipo !== 'parada' && parada.tipo !== 'inicio') {
                    return;
                }
                
                try {
                    const marcador = crearMarcadorParada(parada);
                    if (marcador) {
                        estadoGlobal.marcadoresParadas.set(parada.parada_id, marcador);
                        marcadoresCreados++;
                    }
                } catch (error) {
                    console.error(`Error al crear marcador para ${parada.parada_id}:`, error);
                    errores++;
                }
            });
            
            console.log(`‚úÖ ${marcadoresCreados} marcadores creados, ${errores} errores`);
        }
        
        /**
         * Crea un marcador para una parada espec√≠fica
         * @param {Object} parada - Objeto con los datos de la parada
         * @returns {L.Marker} Marcador de Leaflet
         */
        function crearMarcadorParada(parada) {
            const paradaId = parada.parada_id;
            const coords = estadoGlobal.coordenadasParadas.get(paradaId);
            
            if (!coords) {
                throw new Error(`Coordenadas no encontradas para la parada ${paradaId}`);
            }
            
            // Determinar la clase CSS seg√∫n el tipo de parada
            const esInicio = parada.tipo === 'inicio';
            const claseIcono = esInicio ? 'marcador-inicio' : 'marcador-parada';
            const numeroParada = paradaId.replace('P-', '');
            
            // Crear icono personalizado
            const icono = L.divIcon({
                className: `marcador ${claseIcono}`,
                html: `<div class="marcador-contenido">${numeroParada}</div>`,
                iconSize: esInicio ? [36, 36] : [32, 32],
                iconAnchor: esInicio ? [18, 36] : [16, 32],
                popupAnchor: [0, -32]
            });
            
            // Crear marcador
            const marcador = L.marker(coords, { 
                icon: icono,
                title: `Parada ${numeroParada}${esInicio ? ' (Inicio)' : ''}`,
                alt: `Marcador de ${esInicio ? 'inicio' : 'parada'} ${numeroParada}`,
                zIndexOffset: esInicio ? 1000 : 500, // Asegurar que el inicio est√© por encima
                riseOnHover: true
            });
            
            // Configurar popup
            const popupContent = `
                <div class="popup-parada">
                    <h4>${esInicio ? 'Punto de Inicio' : 'Parada ' + numeroParada}</h4>
                    <p>ID: ${paradaId}</p>
                    ${parada.reto_id ? `<p><strong>Reto:</strong> ${parada.reto_id}</p>` : ''}
                    <button class="btn-navegar" data-parada="${paradaId}">
                        Navegar aqu√≠
                    </button>
                </div>
            `;
            
            // A√±adir popup con contenido HTML
            marcador.bindPopup(popupContent, {
                maxWidth: 250,
                minWidth: 180,
                className: 'popup-parada-estilo',
                closeButton: true,
                autoClose: false,
                closeOnClick: false
            });
            
            // Manejar eventos del marcador
            marcador.on('click', function(e) {
                console.log(`Marcador de ${paradaId} clickeado`);
                // Centrar el mapa en el marcador con zoom
                estadoGlobal.mapa.setView(coords, 18);
            });
            
            // A√±adir al grupo de marcadores
            marcador.addTo(estadoGlobal.grupoMarcadores);
            
            return marcador;
        }
        
        /**
         * Muestra u oculta los marcadores de las paradas
         * @param {boolean} mostrar - Indica si mostrar u ocultar los marcadores
         */
        function mostrarMarcadoresParadas(mostrar = true) {
            if (!estadoGlobal.grupoMarcadores) return;
            
            if (mostrar) {
                estadoGlobal.mapa.addLayer(estadoGlobal.grupoMarcadores);
            } else {
                estadoGlobal.mapa.removeLayer(estadoGlobal.grupoMarcadores);
            }
        }
        
        /**
         * Mueve el mapa a la ubicaci√≥n de una parada espec√≠fica
         * @param {string} paradaId - ID de la parada
         * @param {number} zoom - Nivel de zoom (opcional)
         */
        function centrarEnParada(paradaId, zoom = 18) {
            const marcador = estadoGlobal.marcadoresParadas.get(paradaId);
            if (marcador) {
                const coords = marcador.getLatLng();
                estadoGlobal.mapa.setView(coords, zoom);
                
                // Abrir el popup del marcador
                marcador.openPopup();
                
                // Destacar temporalmente el marcador
                const icon = marcador.getElement();
                if (icon) {
                    icon.classList.add('marcador-destacado');
                    setTimeout(() => {
                        icon.classList.remove('marcador-destacado');
                    }, 2000);
                }
            } else {
                console.warn(`No se encontr√≥ el marcador para la parada ${paradaId}`);
            }
        }
        
        // ================== FUNCIONES DE RUTAS ==================
        
        /**
         * Dibuja una ruta entre dos paradas
         * @param {string} desdeId - ID de la parada de origen
         * @param {string} hastaId - ID de la parada de destino
         * @param {Object} opciones - Opciones para la ruta
         * @returns {L.Polyline} L√≠nea de la ruta
         */
        function dibujarRuta(desdeId, hastaId, opciones = {}) {
            if (!estadoGlobal.mapa) {
                console.warn('No se puede dibujar la ruta: el mapa no est√° inicializado');
                return null;
            }
            
            // Obtener coordenadas de las paradas
            const desdeCoords = estadoGlobal.coordenadasParadas.get(desdeId);
            const hastaCoords = estadoGlobal.coordenadasParadas.get(hastaId);
            
            if (!desdeCoords || !hastaCoords) {
                console.warn('No se encontraron coordenadas para una o ambas paradas');
                return null;
            }
            
            // Opciones por defecto
            const opcionesRuta = {
                color: '#3f51b5',
                weight: 5,
                opacity: 0.8,
                dashArray: '10, 10',
                lineCap: 'round',
                ...opciones
            };
            
            // Crear la ruta
            const ruta = L.polyline([desdeCoords, hastaCoords], opcionesRuta).addTo(estadoGlobal.mapa);
            
            // Almacenar referencia a la ruta
            if (!estadoGlobal.rutas) {
                estadoGlobal.rutas = [];
            }
            estadoGlobal.rutas.push(ruta);
            
            // Ajustar la vista para mostrar toda la ruta
            const bounds = L.latLngBounds([desdeCoords, hastaCoords]);
            estadoGlobal.mapa.fitBounds(bounds, { padding: [50, 50] });
            
            return ruta;
        }
        
        /**
         * Limpia todas las rutas dibujadas en el mapa
         */
        function limpiarRutas() {
            if (!estadoGlobal.rutas || estadoGlobal.rutas.length === 0) return;
            
            estadoGlobal.rutas.forEach(ruta => {
                if (ruta && estadoGlobal.mapa.hasLayer(ruta)) {
                    estadoGlobal.mapa.removeLayer(ruta);
                }
            });
            
            estadoGlobal.rutas = [];
            console.log('‚úÖ Rutas limpiadas');
        }
        
        /**
         * Navega a la siguiente parada desde la actual
         * @param {string} paradaActualId - ID de la parada actual
         * @returns {boolean} True si se pudo navegar a la siguiente parada
         */
        function navegarSiguienteParada(paradaActualId) {
            if (!paradaActualId || !estadoGlobal.coordenadasParadas.has(paradaActualId)) {
                console.warn('ID de parada actual no v√°lido');
                return false;
            }
            
            // Obtener el √≠ndice de la parada actual
            const indiceActual = AVENTURA_PARADAS.findIndex(p => p.parada_id === paradaActualId);
            if (indiceActual === -1 || indiceActual >= AVENTURA_PARADAS.length - 1) {
                console.warn('No hay m√°s paradas disponibles');
                return false;
            }
            
            // Obtener la siguiente parada
            const siguienteParada = AVENTURA_PARADAS[indiceActual + 1];
            if (!siguienteParada || !estadoGlobal.coordenadasParadas.has(siguienteParada.parada_id)) {
                console.warn('No se pudo encontrar la siguiente parada');
                return false;
            }
            
            // Limpiar rutas anteriores
            limpiarRutas();
            
            // Dibujar la ruta
            dibujarRuta(paradaActualId, siguienteParada.parada_id, {
                color: '#ff9800',
                weight: 6,
                dashArray: '15, 10',
                className: 'ruta-activa'
            });
            
            // Centrar en la siguiente parada
            centrarEnParada(siguienteParada.parada_id);
            
            console.log(`üöÄ Navegando a la siguiente parada: ${siguienteParada.parada_id}`);
            return true;
        }
        
        // ================== MANEJADORES DE EVENTOS ==================
        
        /**
         * Inicializa los manejadores de eventos del mapa
         */
        function inicializarManejadoresEventos() {
            if (!estadoGlobal.mapa) return;
            
            // Manejador para clics en el bot√≥n de navegaci√≥n en los popups
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('btn-navegar')) {
                    const paradaId = e.target.dataset.parada;
                    if (paradaId) {
                        centrarEnParada(paradaId);
                        
                        // Desplazar suavemente al mapa
                        const mapaElement = document.getElementById('mapa');
                        if (mapaElement) {
                            mapaElement.scrollIntoView({ behavior: 'smooth' });
                        }
                    }
                }
            });
            
            // Manejador para el evento de cambio de tama√±o de ventana
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (estadoGlobal.mapa) {
                        estadoGlobal.mapa.invalidateSize({ animate: true });
                    }
                }, 250);
            });
            
            console.log('‚úÖ Manejadores de eventos inicializados');
        }
        
        // ================== GESTI√ìN DE HIJOS ==================
        
        /**
         * Inicializa el monitoreo de los componentes hijos
         */
        function inicializarMonitoreoHijos() {
            console.log('üîç Iniciando monitoreo de componentes hijos...');
            
            // Configurar el monitoreo peri√≥dico
            estadoGlobal.intervaloMonitoreo = setInterval(verificarEstadoHijos, 
                estadoGlobal.configuracion.intervaloMonitoreo);
                
            // Configurar un temporizador para detectar hijos que no responden
            setTimeout(() => {
                const hijosInactivos = HIJOS_SISTEMA.filter(hijo => 
                    !estadoGlobal.hijosListos.has(hijo.id) && hijo.requerido
                );
                
                if (hijosInactivos.length > 0) {
                    console.warn('‚ö†Ô∏è Algunos componentes hijos no respondieron a tiempo:', 
                        hijosInactivos.map(h => h.id).join(', '));
                    
                    // Intentar reconexi√≥n con los hijos inactivos
                    hijosInactivos.forEach(hijo => {
                        const reintentos = estadoGlobal.hijosConectados.get(hijo.id)?.reintentos || 0;
                        if (reintentos < estadoGlobal.configuracion.maxReintentosConexion) {
                            console.log(`üîÑ Intentando reconectar con ${hijo.id} (intento ${reintentos + 1})`);
                            enviarMensajeHijo(hijo.id, TIPOS_MENSAJE.SISTEMA.INICIALIZACION, {});
                            
                            // Actualizar contador de reintentos
                            estadoGlobal.hijosConectados.set(hijo.id, { 
                                ...(estadoGlobal.hijosConectados.get(hijo.id) || {}),
                                reintentos: reintentos + 1,
                                ultimoIntento: Date.now()
                            });
                        } else {
                            console.error(`‚ùå Se agotaron los intentos de conexi√≥n con ${hijo.id}`);
                            // Aqu√≠ podr√≠as notificar al usuario o tomar otra acci√≥n
                        }
                    });
                }
            }, estadoGlobal.configuracion.tiempoEsperaHijos);
            
            console.log('‚úÖ Monitoreo de componentes hijos iniciado');
        }
        
        /**
         * Verifica el estado de los componentes hijos
         */
        function verificarEstadoHijos() {
            const ahora = Date.now();
            const umbralInactividad = 60000; // 1 minuto sin actividad
            
            HIJOS_SISTEMA.forEach(hijo => {
                const ultimoMensaje = estadoGlobal.ultimoMensajeRecibido.get(hijo.id);
                const tiempoInactivo = ultimoMensaje ? ahora - ultimoMensaje : Infinity;
                
                if (tiempoInactivo > umbralInactividad) {
                    console.warn(`‚ö†Ô∏è El componente ${hijo.id} no ha enviado mensajes en ${Math.floor(tiempoInactivo/1000)} segundos`);
                    
                    // Intentar reconexi√≥n si es un componente requerido
                    if (hijo.requerido) {
                        const estadoConexion = estadoGlobal.hijosConectados.get(hijo.id) || { reintentos: 0 };
                        if (estadoConexion.reintentos < estadoGlobal.configuracion.maxReintentosConexion) {
                            console.log(`üîÑ Enviando ping a ${hijo.id}`);
                            enviarMensajeHijo(hijo.id, TIPOS_MENSAJE.SISTEMA.INICIALIZACION, {});
                        }
                    }
                }
            });
            
            // Actualizar la hora de la √∫ltima verificaci√≥n
            estadoGlobal.ultimaVerificacionHijos = ahora;
        }
        
        /**
         * Env√≠a un mensaje a un componente hijo
         * @param {string} hijoId - ID del componente hijo
         * @param {string} tipo - Tipo de mensaje
         * @param {Object} datos - Datos del mensaje
         * @returns {Promise} Promesa que se resuelve cuando se env√≠a el mensaje
         */
        function enviarMensajeHijo(hijoId, tipo, datos) {
            return new Promise((resolve, reject) => {
                try {
                    // Verificar si el hijo est√° en la lista de conocidos
                    const hijo = HIJOS_SISTEMA.find(h => h.id === hijoId);
                    if (!hijo) {
                        throw new Error(`Componente hijo desconocido: ${hijoId}`);
                    }
                    
                    // Verificar si el mensaje es compatible con el tipo de hijo
                    if (!esMensajeCompatible(hijo, tipo)) {
                        console.warn(`‚ö†Ô∏è El componente ${hijoId} no est√° configurado para manejar mensajes de tipo ${tipo}`);
                    }
                    
                    // Enviar el mensaje a trav√©s del sistema de mensajer√≠a
                    Mensajeria.enviarMensaje(hijoId, tipo, datos)
                        .then(() => {
                            // Actualizar el estado de conexi√≥n del hijo
                            estadoGlobal.hijosConectados.set(hijoId, {
                                ...(estadoGlobal.hijosConectados.get(hijoId) || {}),
                                ultimoMensajeEnviado: Date.now(),
                                conectado: true,
                                ultimoError: null
                            });
                            resolve();
                        })
                        .catch(error => {
                            console.error(`‚ùå Error al enviar mensaje a ${hijoId}:`, error);
                            
                            // Actualizar el estado de error
                            estadoGlobal.hijosConectados.set(hijoId, {
                                ...(estadoGlobal.hijosConectados.get(hijoId) || {}),
                                conectado: false,
                                ultimoError: error.message,
                                ultimoIntento: Date.now()
                            });
                            
                            reject(error);
                        });
                        
                } catch (error) {
                    console.error(`Error al enviar mensaje a ${hijoId}:`, error);
                    reject(error);
                }
            });
        }
        
        /**
         * Verifica si un mensaje es compatible con un tipo de hijo
         * @param {Object} hijo - Configuraci√≥n del hijo
         * @param {string} tipoMensaje - Tipo de mensaje a verificar
         * @returns {boolean} True si el mensaje es compatible
         */
        function esMensajeCompatible(hijo, tipoMensaje) {
            // Si el hijo no tiene un tipo definido, se asume que maneja todos los mensajes
            if (!hijo.tipo) return true;
            
            // Obtener los tipos de mensaje que el hijo deber√≠a manejar
            const tiposMensajeHijo = MENSAJES_POR_TIPO[hijo.tipo] || [];
            
            // Verificar si el tipo de mensaje est√° en la lista de mensajes que el hijo maneja
            return tiposMensajeHijo.some(tipo => tipo === tipoMensaje);
        }
        
        /**
         * Maneja la notificaci√≥n de que un hijo est√° listo
         * @param {Object} mensaje - Mensaje recibido
         * @returns {Object} Respuesta de confirmaci√≥n
         */
        function manejarHijoListo(mensaje) {
            const { origen, datos = {} } = mensaje;
            const timestamp = Date.now();
            
            try {
                // Validaci√≥n de entrada
                if (!origen) {
                    throw new Error('Mensaje sin origen');
                }
                
                console.log(`‚úÖ Hijo listo: ${origen}`, {
                    version: datos.version,
                    capacidades: datos.capacidades ? datos.capacidades.length : 0,
                    metadata: datos.metadata || {}
                });
                
                // Registrar m√©tricas
                estadoGlobal.metricas.mensajesRecibidos++;
                
                // Actualizar estado del hijo
                const estadoHijo = {
                    id: origen,
                    conectado: true,
                    ultimaConexion: timestamp,
                    ultimaSincronizacion: timestamp,
                    reintentos: 0,
                    version: datos.version || 'desconocida',
                    capacidades: Array.isArray(datos.capacidades) ? datos.capacidades : [],
                    metadata: datos.metadata || {},
                    estado: 'conectado',
                    errores: [],
                    metricas: {
                        mensajesEnviados: 0,
                        mensajesRecibidos: 1,
                        ultimaActividad: timestamp
                    }
                };
                
                // Mantener datos existentes si los hay
                const estadoAnterior = estadoGlobal.hijosConectados.get(origen) || {};
                estadoGlobal.hijosConectados.set(origen, { ...estadoAnterior, ...estadoHijo });
                
                // Notificar a otros componentes
                broadcastMensaje({
                    tipo: 'sistema:hijo_listo',
                    origen: 'sistema',
                    destino: 'todos',
                    datos: { 
                        componente: origen,
                        version: estadoHijo.version,
                        timestamp,
                        // Solo incluir metadatos p√∫blicos
                        metadata: {
                            capacidades: estadoHijo.capacidades,
                            conectado: true
                        }
                    }
                }, [origen]); // Excluir al remitente
                
                // Sincronizar estado con el nuevo hijo
                sincronizarEstadoConHijo(origen);
                
                // Respuesta de confirmaci√≥n
                return {
                    exito: true,
                    mensaje: 'Registro exitoso',
                    timestamp,
                    estado: {
                        modo: estadoGlobal.modo,
                        gpsActivo: estadoGlobal.gpsActivo,
                        paradaActual: estadoGlobal.paradaActual,
                        tramoActual: estadoGlobal.tramoActual,
                        version: estadoGlobal.version,
                        timestamp
                    },
                    config: {
                        debug: estadoGlobal.config.debug,
                        maxReintentos: estadoGlobal.config.maxReintentos,
                        tiempoEspera: estadoGlobal.config.tiempoEsperaInicial
                    }
                };
                
            } catch (error) {
                console.error(`‚ùå Error al procesar notificaci√≥n de hijo listo (${origen}):`, error);
                
                // Registrar error
                if (origen) {
                    const estadoHijo = estadoGlobal.hijosConectados.get(origen) || {
                        id: origen,
                        errores: [],
                        estado: 'error',
                        ultimoError: {
                            tipo: 'registro',
                            mensaje: error.message,
                            codigo: 'ERROR_REGISTRO',
                            timestamp: new Date().toISOString(),
                            stack: error.stack
                        }
                    };
                    
                    estadoHijo.errores = estadoHijo.errores || [];
                    estadoHijo.errores.push({
                        tipo: 'registro',
                        mensaje: error.message,
                        codigo: 'ERROR_REGISTRO',
                        timestamp: new Date().toISOString(),
                        stack: error.stack,
                        datos: datos || {}
                    });
                    
                    estadoGlobal.hijosConectados.set(origen, estadoHijo);
                }
                
                // Devolver error detallado
                return {
                    exito: false,
                    error: {
                        mensaje: error.message || 'Error desconocido',
                        codigo: 'ERROR_REGISTRO',
                        detalle: error.stack ? error.stack.split('\n')[0] : undefined
                    },
                    timestamp: Date.now(),
                    intentarNuevamente: true,
                    tiempoEspera: 5000 // 5 segundos
                };
            }
        }
        
        /**
         * Sincroniza el estado actual con un hijo espec√≠fico
         * @param {string} hijoId - ID del componente hijo
         */
        function sincronizarEstadoConHijo(hijoId) {
            const mensaje = {
                tipo: TIPOS_MENSAJE.SISTEMA.SINCRONIZAR_ESTADO,
                datos: {
                    modo: estadoGlobal.modo,
                    paradaActual: estadoGlobal.paradaActual,
                    tramoActual: estadoGlobal.tramoActual,
                    gpsActivo: estadoGlobal.gpsActivo,
                    audioReproduciendo: estadoGlobal.audioReproduciendo,
                    retoActivo: estadoGlobal.retoActivo,
                    timestamp: Date.now()
                }
            };
            
            enviarMensajeHijo(hijoId, mensaje.tipo, mensaje.datos)
                .then(() => console.log(`‚úÖ Estado sincronizado con ${hijoId}`))
                .catch(error => console.error(`‚ùå Error al sincronizar estado con ${hijoId}:`, error));
        }
        
        // ================== MAPA ==================
        /**
         * Inicializa el mapa de Leaflet
         * @returns {Promise<L.Map>} Instancia del mapa de Leaflet
         */
        async function inicializarMapa() {
            return new Promise((resolve, reject) => {
                try {
                    if (typeof L === 'undefined') {
                        throw new Error('La biblioteca Leaflet no est√° cargada correctamente');
                    }
                    console.log('üåç Iniciando inicializaci√≥n del mapa...');
                    
                    // Coordenadas por defecto (centro de Valencia)
                    const valenciaCoords = [39.44859, -0.37489];
                    const mapContainer = document.getElementById('mapa');
                    
                    if (!mapContainer) {
                        throw new Error('No se encontr√≥ el contenedor del mapa');
                    }
                    
                    mapContainer.style.display = 'block';
                    
                    // Crear instancia del mapa
                    const mapa = L.map('mapa', {
                        center: valenciaCoords,
                        zoom: 14,
                        zoomControl: false,
                        scrollWheelZoom: true,
                        doubleClickZoom: true,
                        boxZoom: true,
                        rotate: false,
                        touchRotate: false,
                        bearing: 0,
                        preferCanvas: true
                    });
                    
                    // A√±adir capa base de OpenStreetMap
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19,
                        attribution: '¬© OpenStreetMap contributors',
                        detectRetina: true
                    }).addTo(mapa);
                    
                    // A√±adir control de zoom personalizado
                    L.control.zoom({
                        position: 'topright'
                    }).addTo(mapa);
                    
                    // Manejar la carga del mapa
                    mapa.whenReady(() => {
                        console.log('‚úÖ Mapa cargado correctamente');
                        
                        // Forzar un redimensionamiento para asegurar que el mapa se renderice correctamente
                        setTimeout(() => {
                            mapa.invalidateSize({ animate: true });
                            
                            try {
                                // Inicializar coordenadas y crear marcadores
                                if (typeof inicializarCoordenadasParadas === 'function') {
                                    inicializarCoordenadasParadas();
                                }
                                
                                if (typeof crearMarcadoresIniciales === 'function') {
                                    crearMarcadoresIniciales();
                                }
                                
                                resolve(mapa);
                            } catch (error) {
                                console.error('Error durante la inicializaci√≥n del mapa:', error);
                                reject(error);
                            }
                            
                        }, 100);
                    });
                    
                    // Manejar errores del mapa
                    mapa.on('error', (error) => {
                        const errorMsg = 'Error en el mapa: ' + (error.message || 'Error desconocido');
                        console.error('‚ùå', errorMsg, error);
                        
                        if (typeof mostrarErrorEnInterfaz === 'function') {
                            mostrarErrorEnInterfaz(errorMsg);
                        }
                        
                        reject(new Error(errorMsg));
                    });
                    
                } catch (error) {
                    console.error('‚ùå Error al inicializar el mapa:', error);
                    const errorMsg = 'Error al cargar el mapa: ' + (error.message || 'Error desconocido');
                    
                    if (typeof mostrarErrorEnInterfaz === 'function') {
                        mostrarErrorEnInterfaz(errorMsg, () => {
                            try {
                                return inicializarMapa();
                            } catch (retryError) {
                                console.error('Error al reintentar la inicializaci√≥n del mapa:', retryError);
                                return null;
                            }
                        });
                    }
                    
                    reject(new Error(errorMsg));
                }
            });
        }
        
        // ================== GESTI√ìN DE HIJOS ==================
        
        /**
         * Inicializa un iframe hijo existente
         * @param {Object} hijo - Configuraci√≥n del hijo
         */
        function inicializarIframeHijo(hijo) {
            const iframe = document.getElementById(hijo.id);
            if (!iframe) {
                console.error(`‚ùå No se encontr√≥ el iframe con ID: ${hijo.id}`);
                if (hijo.requerido) {
                    mostrarErrorEnInterfaz(`No se encontr√≥ el componente requerido: ${hijo.id}`);
                }
                return;
            }
            
            // Configuraci√≥n de atributos para seguridad
            iframe.setAttribute('sandbox', 'allow-same-origin allow-scripts allow-popups allow-forms');
            iframe.setAttribute('allow', 'geolocation; microphone; camera');
            
            // Manejar errores de carga
            iframe.onerror = (error) => {
                console.error(`‚ùå Error al cargar el componente ${hijo.id}:`, error);
                if (hijo.requerido) {
                    mostrarErrorEnInterfaz(`Error al cargar el componente requerido: ${hijo.id}`);
                }
            };
            
            // Manejar carga exitosa
            iframe.onload = () => {
                console.log(`‚úÖ Componente ${hijo.id} cargado correctamente`);
                
                // Actualizar el estado del hijo
                const estadoHijo = estadoGlobal.hijosConectados.get(hijo.id) || {};
                estadoHijo.estado = 'cargado';
                estadoHijo.ultimaComunicacion = Date.now();
                estadoGlobal.hijosConectados.set(hijo.id, estadoHijo);
                
                // Notificar al componente que est√° listo
                const mensaje = {
                    tipo: 'sistema:inicializado',
                    origen: 'padre',
                    datos: {
                        id: hijo.id,
                        config: {
                            debug: estadoGlobal.config.debug
                        }
                    }
                };
                
                // Esperar un momento para asegurar que el iframe est√© listo
                setTimeout(() => {
                    try {
                        iframe.contentWindow.postMessage(mensaje, '*');
                        console.log(`üì§ Notificaci√≥n de inicializaci√≥n enviada a ${hijo.id}`);
                    } catch (error) {
                        console.error(`‚ùå Error al notificar a ${hijo.id}:`, error);
                    }
                }, 500);
            };
            
            // Inicializar el estado del hijo si no existe
            if (!estadoGlobal.hijosConectados.has(hijo.id)) {
                estadoGlobal.hijosConectados.set(hijo.id, {
                    id: hijo.id,
                    tipo: hijo.tipo,
                    iframe: iframe,
                    estado: 'inicializando',
                    ultimaComunicacion: null,
                    errores: [],
                    version: '1.0.0',
                    capacidades: []
                });
            }
        }
        
        /**
         * Inicializa todos los componentes hijos
         * @returns {Promise<void>}
         */
        async function inicializarComponentesHijos() {
            console.log('üöÄ Inicializando componentes hijos...');
            
            // Configurar el manejador de mensajes para la comunicaci√≥n con los hijos
            window.addEventListener('message', manejarMensajeHijo);
            
            // Inicializar cada iframe hijo
            HIJOS_SISTEMA.forEach(hijo => {
                try {
                    console.log(`üì¶ Inicializando componente hijo: ${hijo.id}`);
                    inicializarIframeHijo(hijo);
                } catch (error) {
                    console.error(`‚ùå Error al inicializar el componente ${hijo.id}:`, error);
                    if (hijo.requerido) {
                        mostrarErrorEnInterfaz(`Error al inicializar el componente requerido: ${hijo.id}`);
                    }
                }
            });
            
            // Iniciar el monitoreo de estado de los hijos
            iniciarMonitoreoHijos();
            
            // Notificar que la inicializaci√≥n de los hijos ha comenzado
            console.log('‚úÖ Inicializaci√≥n de componentes hijos iniciada');
        }
        
        /**
         * Maneja los mensajes entrantes de los componentes hijos
         * @param {MessageEvent} event - Evento de mensaje
         */
        function manejarMensajeHijo(event) {
            const mensaje = event.data;
            
            // Validar que el mensaje tenga la estructura esperada
            if (!mensaje || typeof mensaje !== 'object' || !mensaje.tipo) {
                return;
            }
            
            // Registrar la comunicaci√≥n
            const ahora = Date.now();
            const origen = mensaje.origen;
            
            // Actualizar el estado del hijo
            if (origen) {
                const estadoHijo = estadoGlobal.hijosConectados.get(origen) || {
                    id: origen,
                    tipo: 'desconocido',
                    estado: 'activo',
                    ultimaComunicacion: ahora,
                    errores: [],
                    version: mensaje.version || '1.0.0',
                    capacidades: mensaje.capacidades || []
                };
                
                // Actualizar informaci√≥n del estado
                estadoHijo.ultimaComunicacion = ahora;
                estadoHijo.estado = 'activo';
                
                // Actualizar versi√≥n y capacidades si est√°n presentes en el mensaje
                if (mensaje.version) estadoHijo.version = mensaje.version;
                if (mensaje.capacidades) estadoHijo.capacidades = mensaje.capacidades;
                
                estadoGlobal.hijosConectados.set(origen, estadoHijo);
                
                // Registrar el mensaje en el historial de comunicaci√≥n
                if (!estadoHijo.historial) estadoHijo.historial = [];
                estadoHijo.historial.push({
                    timestamp: ahora,
                    tipo: mensaje.tipo,
                    datos: mensaje.datos
                });
                
                // Mantener un l√≠mite en el historial
                if (estadoHijo.historial.length > 50) {
                    estadoHijo.historial.shift();
                }
            }
            
            // Registrar el mensaje recibido
            estadoGlobal.metricas.mensajesRecibidos++;
            
            // Procesar el mensaje seg√∫n su tipo
            try {
                const manejador = manejadoresMensajes[mensaje.tipo];
                if (manejador && typeof manejador === 'function') {
                    console.log(`üì® [${mensaje.tipo}] de ${origen || 'origen desconocido'}:`, mensaje.datos || 'Sin datos');
                    manejador(mensaje);
                } else {
                    console.warn(`‚ö†Ô∏è No se encontr√≥ manejador para el tipo de mensaje: ${mensaje.tipo}`, mensaje);
                }
            } catch (error) {
                console.error(`‚ùå Error al procesar mensaje de ${origen || 'origen desconocido'}:`, error);
                
                // Registrar el error en el estado del hijo
                if (origen) {
                    const estadoHijo = estadoGlobal.hijosConectados.get(origen);
                    if (estadoHijo) {
                        estadoHijo.errores = estadoHijo.errores || [];
                        estadoHijo.errores.push({
                            timestamp: ahora,
                            tipo: 'procesamiento_mensaje',
                            mensaje: error.message,
                            stack: error.stack,
                            mensajeOriginal: mensaje
                        });
                        estadoGlobal.hijosConectados.set(origen, estadoHijo);
                    }
                }
            }
        }
        
        /**
         * Inicia el monitoreo del estado de los componentes hijos
         */
        function iniciarMonitoreoHijos() {
            // Verificar estado de los hijos peri√≥dicamente
            setInterval(() => {
                const ahora = Date.now();
                const umbralInactividad = 30000; // 30 segundos sin comunicaci√≥n
                
                estadoGlobal.hijosConectados.forEach((hijo, id) => {
                    const tiempoInactivo = ahora - (hijo.ultimaComunicacion || ahora);
                    
                    if (tiempoInactivo > umbralInactividad && hijo.estado !== 'inactivo') {
                        console.warn(`‚ö†Ô∏è El componente ${id} no ha respondido en ${Math.floor(tiempoInactivo / 1000)} segundos`);
                        
                        // Actualizar estado
                        hijo.estado = 'inactivo';
                        estadoGlobal.hijosConectados.set(id, hijo);
                        
                        // Notificar a la interfaz de usuario
                        mostrarNotificacion(`El componente ${id} no responde`, 'advertencia');
                    }
                });
            }, 10000); // Verificar cada 10 segundos
        }
        
        // ================== MANEJADORES DE MENSAJES ==================
        
        /**
         * Maneja la notificaci√≥n de que un hijo est√° listo
         * @param {Object} mensaje - Mensaje recibido
         * @returns {Object} Respuesta de confirmaci√≥n
         */
        function manejarHijoListo(mensaje) {
            const { origen, datos = {} } = mensaje;
            console.log(`‚úÖ Hijo listo: ${origen}`, datos);
            
            // Actualizar el estado del hijo
            const estadoHijo = estadoGlobal.hijosConectados.get(origen);
            if (estadoHijo) {
                estadoHijo.estado = 'listo';
                estadoHijo.version = datos.version || '1.0.0';
                estadoHijo.capacidades = datos.capacidades || [];
                estadoGlobal.hijosConectados.set(origen, estadoHijo);
                
                // Notificar a la interfaz de usuario
                mostrarNotificacion(`Componente ${origen} listo`, '√©xito');
            }
        }
        
        /**
         * Maneja los errores reportados por los hijos
         * @param {Object} mensaje - Mensaje de error
         */
        function manejarErrorDeHijo(mensaje) {
            const { origen, datos = {} } = mensaje;
            console.error(`‚ùå Error en ${origen}:`, datos);
            
            // Registrar el error
            if (origen) {
                const estadoHijo = estadoGlobal.hijosConectados.get(origen);
                if (estadoHijo) {
                    estadoHijo.errores = estadoHijo.errores || [];
                    estadoHijo.errores.push({
                        codigo: datos.codigo,
                        mensaje: datos.mensaje,
                        timestamp: Date.now(),
                        stack: datos.stack
                    });
                    estadoGlobal.hijosConectados.set(origen, estadoHijo);
                }
            }
            
            // Mostrar notificaci√≥n al usuario
            mostrarNotificacion(`Error en ${origen}: ${datos.mensaje || 'Error desconocido'}`, 'error');
        }
        
        /**
         * Maneja las confirmaciones de los hijos
         * @param {Object} mensaje - Mensaje de confirmaci√≥n
         */
        function manejarConfirmacion(mensaje) {
            const { origen, datos = {} } = mensaje;
            console.log(`‚úÖ Confirmaci√≥n de ${origen}:`, datos);
            
            // Aqu√≠ podr√≠as implementar l√≥gica adicional basada en la confirmaci√≥n
            // Por ejemplo, actualizar la interfaz de usuario o el estado de la aplicaci√≥n
        }
        
        /**
         * Maneja las actualizaciones de estado de los hijos
         * @param {Object} mensaje - Mensaje de estado
         */
        function manejarEstadoHijo(mensaje) {
            const { origen, datos = {} } = mensaje;
            
            if (origen) {
                const estadoHijo = estadoGlobal.hijosConectados.get(origen);
                if (estadoHijo) {
                    // Actualizar el estado del hijo con los nuevos datos
                    Object.assign(estadoHijo, datos);
                    estadoHijo.ultimaActualizacion = Date.now();
                    estadoGlobal.hijosConectados.set(origen, estadoHijo);
                }
            }
        }
        
        // Mapa de manejadores de mensajes
        const manejadoresMensajes = {
            // Mensajes del sistema
            'sistema:listo': manejarHijoListo,
            'sistema:error': manejarErrorDeHijo,
            'sistema:confirmacion': manejarConfirmacion,
            'sistema:estado': manejarEstadoHijo,
            
            // Mensajes de audio
            'audio:reproducir': manejarReproducirAudio,
            'audio:pausar': manejarPausarAudio,
            'audio:detener': manejarDetenerAudio,
            'audio:estado': manejarEstadoAudio,
            
            // Mensajes de navegaci√≥n
            'navegacion:parada': manejarCambioParada,
            'navegacion:tramo': manejarCambioTramo,
            'navegacion:estado': manejarEstadoNavegacion,
            
            // Mensajes de retos
            'reto:iniciar': manejarIniciarReto,
            'reto:completar': manejarCompletarReto,
            'reto:fallar': manejarFallarReto,
            'reto:estado': manejarEstadoReto,
            
            // Mensajes de interfaz de usuario
            'ui:notificacion': manejarNotificacionUI,
            'ui:dialogo': manejarDialogoUI
        };
        
        // ================== FUNCIONES AUXILIARES ==================
        
        /**
         * Muestra un mensaje de error en la interfaz de usuario
         * @param {string} mensaje - Mensaje de error
         * @param {Function} [onRetry] - Funci√≥n a ejecutar al reintentar
         */
        function mostrarErrorEnInterfaz(mensaje, onRetry) {
            console.error('‚ùå ' + mensaje);
            // Aqu√≠ podr√≠as implementar la l√≥gica para mostrar el error en la UI
            // Por ejemplo, mostrando un modal o un mensaje flotante
            
            // Ejemplo b√°sico de notificaci√≥n
            const notificacion = document.createElement('div');
            notificacion.className = 'notificacion-error';
            notificacion.textContent = mensaje;
            
            if (onRetry) {
                const botonReintentar = document.createElement('button');
                botonReintentar.textContent = 'Reintentar';
                botonReintentar.onclick = () => {
                    notificacion.remove();
                    onRetry();
                };
                notificacion.appendChild(botonReintentar);
            }
            
            document.body.appendChild(notificacion);
            
            // Eliminar la notificaci√≥n despu√©s de 5 segundos
            setTimeout(() => {
                if (notificacion.parentNode) {
                    notificacion.remove();
                }
            }, 5000);
        }
        
        /**
         * Muestra una notificaci√≥n en la interfaz de usuario
         * @param {string} mensaje - Mensaje a mostrar
         * @param {string} tipo - Tipo de notificaci√≥n (√©xito, error, advertencia, info)
         */
        function mostrarNotificacion(mensaje, tipo = 'info') {
            console.log(`üì¢ [${tipo.toUpperCase()}] ${mensaje}`);
            // Implementar l√≥gica para mostrar notificaciones en la UI
        }
        
        // ================== INICIALIZACI√ìN ==================
        
        /**
         * Funci√≥n principal de inicializaci√≥n
         */
        async function inicializar() {
            try {
                console.log('üöÄ Inicializando sistema padre...');
                
                // 1. Inicializar el mapa
                console.log('üåç Inicializando mapa...');
                try {
                    estadoGlobal.mapa = await inicializarMapa();
                    console.log('‚úÖ Mapa inicializado correctamente');
                } catch (error) {
                    console.error('‚ùå Error al inicializar el mapa:', error);
                    mostrarErrorEnInterfaz('Error al cargar el mapa. Por favor, recarga la p√°gina.');
                    return;
                }
                
                // 2. Inicializar componentes hijos
                console.log('üë∂ Inicializando componentes hijos...');
                await inicializarComponentesHijos();
                
                // 3. Configurar manejadores de eventos
                console.log('üîß Configurando manejadores de eventos...');
                inicializarManejadoresEventos();
                
                // 4. Iniciar monitoreo del sistema
                console.log('üîç Iniciando monitoreo del sistema...');
                iniciarMonitoreoSistema();
                
                // 5. Notificar que la inicializaci√≥n ha finalizado
                console.log('‚úÖ Sistema padre inicializado correctamente');
                
                // Ocultar indicador de carga
                const loadingEl = document.querySelector('.loading');
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                }
                
                // Notificar a los hijos que el sistema est√° listo
                broadcastMensaje({
                    tipo: 'sistema:inicializacion_completada',
                    origen: 'padre',
                    datos: {
                        timestamp: Date.now(),
                        version: estadoGlobal.version
                    }
                });
                
            } catch (error) {
                console.error('‚ùå Error durante la inicializaci√≥n del sistema:', error);
                mostrarErrorEnInterfaz(
                    'Error al iniciar la aplicaci√≥n. Por favor, recarga la p√°gina.",
                    () => window.location.reload()
                );
                
                // Mostrar error en la consola para depuraci√≥n
                console.error('Stack trace del error:', error.stack);
                
                // Asegurarse de que el indicador de carga se oculte en caso de error
                const loadingEl = document.querySelector('.loading');
                if (loadingEl) {
                    loadingEl.textContent = 'Error al cargar la aplicaci√≥n. Por favor, recarga la p√°gina.';
                    loadingEl.style.backgroundColor = '#f44336';
                }
            }
                
                // Inicializar el estado global
                estadoGlobal = {
                    modo: 'casa',
                    gpsActivo: false,
                    paradaActual: 'P-0',
                    tramoActual: 'TR-1',
                    hijosListos: new Set(),
                    hijosConectados: new Map(),
                    ultimoMensajeRecibido: new Map(),
                    mapa: null,
                    audioReproduciendo: false,
                    retoActivo: null,
                    inicializado: false,
                    marcadoresParadas: new Map(),
                    marcadoresUsuario: new Map(),
                    rutasActivas: new Map(),
                    errores: [],
                    ultimaSincronizacion: null,
                    configuracion: {
                        tiempoEsperaHijos: 10000,
                        intervaloMonitoreo: 30000,
                        maxReintentosConexion: 3
                    }
                };
                
                // 1. Inicializar el mapa
                console.log('üåç Inicializando mapa...');
                estadoGlobal.mapa = await inicializarMapa();
                
                if (!estadoGlobal.mapa) {
                    throw new Error('No se pudo inicializar el mapa');
                }
                
                // Notificar a los hijos que el mapa est√° listo
                broadcastMensaje({
                    tipo: 'sistema:mapa_listo',
                    datos: {
                        mensaje: 'El mapa se ha inicializado correctamente',
                        timestamp: Date.now()
                    }
                });
                
                // 4. Inicializar manejadores de eventos
                console.log('üñ±Ô∏è Inicializando manejadores de eventos...');
                inicializarManejadoresEventos();
                
                // 5. Inicializar la mensajer√≠a
                console.log('üì° Inicializando sistema de mensajer√≠a...');
                await inicializarMensajeria();
                
                // 6. Registrar manejadores de mensajes
                console.log('üì© Registrando manejadores de mensajes...');
                registrarManejadores();
                
                // 7. Inicializar monitoreo de componentes hijos
                console.log('üë• Inicializando monitoreo de componentes hijos...');
                inicializarMonitoreoHijos();
                
                // 8. Inicializar componentes hijos
                console.log('üîÑ Inicializando componentes hijos...');
                await inicializarComponentesHijos();
                
                // 9. Centrar en la primera parada
                const primeraParada = AVENTURA_PARADAS.find(p => p.tipo === 'inicio');
                if (primeraParada) {
                    centrarEnParada(primeraParada.parada_id, 16);
                }
                
                // 10. Marcar como inicializado
                estadoGlobal.inicializado = true;
                estadoGlobal.ultimaSincronizacion = new Date().toISOString();
                
                console.log('‚úÖ Sistema padre inicializado correctamente');
                
                // Notificar a los hijos que el sistema est√° listo
                broadcastMensaje({
                    tipo: TIPOS_MENSAJE.SISTEMA.INICIALIZACION,
                    datos: {
                        estado: 'listo',
                        timestamp: Date.now(),
                        version: '1.0.0'
                    }
                });
                
            } catch (error) {
                console.error('‚ùå Error al inicializar el sistema padre:', error);
                mostrarErrorEnInterfaz(
                    'Error al inicializar la aplicaci√≥n: ' + (error.message || 'Error desconocido'),
                    () => {
                        // Intentar reiniciar la inicializaci√≥n
                        setTimeout(inicializar, 1000);
                    }
                );
            }
        }
        
        /**
         * Inicializa los componentes hijos de forma secuencial con reintentos
         */
        async function inicializarComponentesHijos() {
            console.log('üöÄ Inicializando componentes hijos...');
            
            // Inicializar cada componente hijo con manejo de errores robusto
            for (const hijo of HIJOS_SISTEMA) {
                try {
                    console.log(`üîÑ Inicializando ${hijo.id}...`);
                    
                    // Configurar el estado inicial del hijo
                    estadoGlobal.hijosConectados.set(hijo.id, {
                        conectado: false,
                        ultimoIntento: Date.now(),
                        reintentos: 0,
                        version: 'desconocida',
                        capacidades: [],
                        errores: []
                    });
                    
                    // Intentar inicializar con reintentos
                    await intentarInicializarHijo(hijo);
                    
                } catch (error) {
                    console.error(`‚ùå Error cr√≠tico al inicializar ${hijo.id}:`, error);
                    // Registrar el error pero continuar con los dem√°s componentes
                    const estadoHijo = estadoGlobal.hijosConectados.get(hijo.id) || {};
                    estadoHijo.errores = estadoHijo.errores || [];
                    estadoHijo.errores.push({
                        tipo: 'inicializacion',
                        mensaje: error.message,
                        timestamp: new Date().toISOString()
                    });
                    estadoGlobal.hijosConectados.set(hijo.id, estadoHijo);
                }
            }
            
            console.log('‚úÖ Proceso de inicializaci√≥n de componentes hijos completado');
            
            // Verificar estado de inicializaci√≥n
            const hijosFallidos = Array.from(estadoGlobal.hijosConectados.entries())
                .filter(([_, estado]) => !estado.conectado)
                .map(([id]) => id);
                
            if (hijosFallidos.length > 0) {
                console.warn(`‚ö†Ô∏è Algunos componentes no se inicializaron correctamente: ${hijosFallidos.join(', ')}`);
            }
            
            return {
                exitoso: true,
                total: HIJOS_SISTEMA.length,
                exitosos: HIJOS_SISTEMA.length - hijosFallidos.length,
                fallidos: hijosFallidos.length,
                idsFallidos: hijosFallidos
            };
            
            /**
             * Intenta inicializar un componente hijo con reintentos
             */
            async function intentarInicializarHijo(hijo, intento = 1) {
                const maxReintentos = 3;
                const tiempoEspera = 1000 * intento; // Espera creciente
                
                try {
                    // Enviar mensaje de inicializaci√≥n al hijo
                    await enviarMensajeHijo(hijo.id, 'sistema:inicializacion', {
                        configuracion: {
                            modo: estadoGlobal.modo,
                            version: '1.0.0',
                            timestamp: Date.now(),
                            maxReintentos,
                            tiempoEspera: 5000 // Tiempo de espera para la respuesta
                        }
                    });
                    
                    console.log(`‚úÖ Mensaje de inicializaci√≥n enviado a ${hijo.id}`);
                    
                    // Actualizar estado del hijo
                    const estadoHijo = estadoGlobal.hijosConectados.get(hijo.id);
                    estadoHijo.ultimoIntento = Date.now();
                    estadoHijo.reintentos = intento;
                    estadoGlobal.hijosConectados.set(hijo.id, estadoHijo);
                    
                } catch (error) {
                    if (intento < maxReintentos) {
                        console.warn(`‚ö†Ô∏è Reintentando (${intento}/${maxReintentos}) inicializaci√≥n de ${hijo.id}...`);
                        await new Promise(resolve => setTimeout(resolve, tiempoEspera));
                        return intentarInicializarHijo(hijo, intento + 1);
                    }
                    
                    // Si llegamos aqu√≠, agotamos los reintentos
                    throw new Error(`No se pudo inicializar ${hijo.id} despu√©s de ${maxReintentos} intentos: ${error.message}`);
                }
            }
        }

        // ================== MANEJADORES DE MENSAJES MEJORADOS ==================
        const manejadoresMensajes = {
            // Sistema
            'sistema:listo': manejarHijoListo,
            'sistema:error': manejarErrorDeHijo,
            'sistema:confirmacion': manejarConfirmacion,
            'sistema:ping': manejarPing,
            
            // Datos
            'datos:solicitar_parada': manejarSolicitudDatos,
            'datos:solicitar_estado': manejarSolicitudEstado,
            'datos:actualizar': manejarActualizacionDatos,
            
            // Navegaci√≥n
            'navegacion:cambio_parada': manejarCambioParada,
            'navegacion:llegada_detectada': manejarLlegadaDestino,
            'navegacion:solicitar_destino': manejarSolicitudDestino,
            'navegacion:actualizar_posicion': manejarActualizacionPosicion,
            
            // Audio
            'audio:finalizado': manejarAudioFinalizado,
            'audio:estado': manejarEstadoAudio,
            'audio:error': manejarErrorAudio,
            
            // Retos
            'retos:completado': manejarRetoCompletado,
            'retos:abrir': manejarAbrirReto,
            'retos:estado': manejarEstadoReto,
            
            // GPS
            'gps:estado': manejarEstadoGPS,
            'gps:posicion': manejarPosicionGPS,
            
            // Mensajes espec√≠ficos de componentes
            'hijo5:notificar_punto': manejarNotificacionPunto,
            'hijo5:actualizar_estado': manejarActualizacionEstadoHijo
        };

        /**
         * Registra todos los manejadores de mensajes
         */
        function registrarManejadores() {
            try {
                console.log('üìù Registrando manejadores de mensajes...');
                
                // Registrar todos los manejadores definidos
                Object.entries(manejadoresMensajes).forEach(([tipo, manejador]) => {
                    if (typeof manejador === 'function') {
                        Mensajeria.registrarControlador(tipo, manejador);
                    } else {
                        console.warn(`‚ö†Ô∏è Manejador no encontrado para el tipo: ${tipo}`);
                    }
                });

                console.log(`‚úÖ ${Object.keys(manejadoresMensajes).length} manejadores registrados correctamente`);
                return true;
                
            } catch (error) {
                console.error('‚ùå Error al registrar manejadores:', error);
                throw error; // Relanzar para manejo de errores superior
            }
        }

        // ================== FUNCIONES PRINCIPALES ==================
        
        /**
         * Obtiene los datos de una parada por su ID
         * @param {string} paradaId - ID de la parada
         * @returns {Object|null} Datos de la parada o null si no se encuentra
         */
        function obtenerDatosParada(paradaId) {
            try {
                console.log(`üìç Obteniendo datos para parada: ${paradaId}`);
                
                // Buscar la parada en el array AVENTURA_PARADAS
                const parada = AVENTURA_PARADAS.find(p => p.parada_id === paradaId);
                
                if (!parada) {
                    console.warn(`No se encontr√≥ la parada ${paradaId}`);
                    return null;
                }
                
                // Obtener coordenadas de la parada
                let coordenadas = null;
                if (COORDENADAS_PARADAS && COORDENADAS_PARADAS.get) {
                    coordenadas = COORDENADAS_PARADAS.get(paradaId);
                }
                
                // Construir objeto de datos de la parada
                return {
                    id: paradaId,
                    tipo: parada.tipo || 'parada',
                    nombre: `Parada ${paradaId}`,
                    descripcion: `Descripci√≥n de la parada ${paradaId}`,
                    coordenadas: coordenadas,
                    audio: parada.audio_id ? `audios/${parada.audio_id}.mp3` : null,
                    reto: parada.reto_id ? { id: parada.reto_id, completado: false } : null,
                    propiedadesAdicionales: {
                        visitada: false,
                        timestamp: Date.now()
                    }
                };
                
            } catch (error) {
                console.error(`Error al obtener datos de la parada ${paradaId}:`, error);
                return null;
            }
        }

        // Funci√≥n de inicializaci√≥n del mapa ya existe, no es necesario duplicarla
        
        // Funci√≥n para crear marcadores ya existe, no es necesario duplicarla
        
        /**
         * Maneja las solicitudes de datos de paradas
         */
        function manejarSolicitudDatos(mensaje) {
            try {
                const { tipo, datos, origen } = mensaje;
                console.log(`Solicitud de datos recibida de ${origen}:`, tipo, datos);
                
                if (tipo === TIPOS_MENSAJE.DATOS.SOLICITAR_PARADA) {
                    const { paradaId } = datos;
                    const datosParada = obtenerDatosParada(paradaId);
                    
                    if (datosParada) {
                        return { 
                            exito: true, 
                            datos: datosParada 
                        };
                    } else {
                        return { 
                            exito: false, 
                            error: `No se encontr√≥ la parada ${paradaId}` 
                        };
                    }
                }
                
                return { exito: false, error: 'Tipo de solicitud no reconocido' };
                
            } catch (error) {
                console.error('Error manejando solicitud de datos:', error);
                return { 
                    exito: false, 
                    error: error.message 
                };
            }
        }

        // ================== MANEJO DE MARCADORES ==================
        
        /**
         * Inicializa los marcadores en el mapa
         */
        function inicializarMarcadores() {
            // Aqu√≠ se inicializar√°n los marcadores de las paradas
            console.log('Inicializando marcadores...');
            // Implementaci√≥n pendiente
        }

        // ================== MANEJADORES DE EVENTOS ==================
        
        /**
         * Maneja la notificaci√≥n de que un hijo est√° listo
         * @param {Object} mensaje - Mensaje recibido
         */
        // Funci√≥n para manejar hijo listo ya existe, no es necesario duplicarla
        // El c√≥digo original ha sido movido a la funci√≥n manejarHijoListo

        /**
         * Maneja errores reportados por los hijos
         * @param {Object} mensaje - Mensaje de error
         */
        function manejarErrorDeHijo(mensaje) {
            const { origen, datos } = mensaje;
            console.error(`‚ùå Error reportado por ${origen}:`, datos);
            
            // Registrar el error en el estado global
            if (!estadoGlobal.errores) estadoGlobal.errores = [];
            estadoGlobal.errores.push({
                origen,
                timestamp: new Date().toISOString(),
                error: datos.error || 'Error desconocido'
            });
            
            // Opcional: Notificar a otros componentes sobre el error
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.SISTEMA.ERROR,
                datos: { 
                    origen,
                    mensaje: 'Se ha producido un error en un componente',
                    error: datos.error
                }
            }, [origen]);
        }

        /**
         * Maneja el cambio de parada solicitado por un hijo
         * @param {Object} mensaje - Mensaje de cambio de parada
         * @returns {Object} Resultado de la operaci√≥n
         */
        function manejarCambioParada(mensaje) {
            const { origen, datos } = mensaje;
            const { paradaId } = datos || {};
            
            if (!paradaId) {
                console.warn('Se solicit√≥ cambio de parada sin especificar ID');
                return { exito: false, error: 'ID de parada no especificado' };
            }
            
            console.log(`üîÑ Cambio de parada solicitado por ${origen}: ${paradaId}`);
            
            // Verificar si la parada existe
            const parada = AVENTURA_PARADAS.find(p => p.parada_id === paradaId || p.padreid === paradaId);
            if (!parada) {
                console.warn(`Parada ${paradaId} no encontrada`);
                return { exito: false, error: 'Parada no encontrada' };
            }
            
            try {
                // Actualizar estado global
                estadoGlobal.paradaActual = parada.parada_id || parada.padreid;
                
                // Notificar a todos los hijos sobre el cambio
                broadcastMensaje({
                    tipo: TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA,
                    datos: { 
                        paradaId: estadoGlobal.paradaActual,
                        origen: 'sistema',
                        timestamp: Date.now()
                    }
                });
                
                // Si hay un reto asociado, notificarlo
                if (parada.reto_id) {
                    broadcastMensaje({
                        tipo: TIPOS_MENSAJE.RETOS.ABRIR,
                        datos: { retoId: parada.reto_id }
                    });
                }
                
                return { exito: true };
                
            } catch (error) {
                console.error('Error al manejar cambio de parada:', error);
                return { exito: false, error: error.message };
            }
        }

        /**
         * Maneja la notificaci√≥n de llegada a un destino
         * @param {Object} mensaje - Mensaje de llegada
         */
        function manejarLlegadaDestino(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`üèÅ Llegada a destino reportada por ${origen}:`, datos);
            
            // Actualizar estado
            estadoGlobal.ultimaLlegada = {
                timestamp: Date.now(),
                paradaId: datos.paradaId,
                origen
            };
            
            // Notificar a otros componentes
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.NAVEGACION.LLEGADA_CONFIRMADA,
                datos: {
                    paradaId: datos.paradaId,
                    timestamp: Date.now()
                }
            }, [origen]);
        }

        /**
         * Maneja la solicitud de informaci√≥n de destino
         * @param {Object} mensaje - Mensaje de solicitud
         */
        function manejarSolicitudDestino(mensaje) {
            const { origen } = mensaje;
            console.log(`‚ùì Solicitud de destino desde ${origen}`);
            
            return {
                exito: true,
                datos: {
                    paradaActual: estadoGlobal.paradaActual,
                    modo: estadoGlobal.modo,
                    timestamp: Date.now()
                }
            };
        }

        /**
         * Maneja la notificaci√≥n de finalizaci√≥n de audio
         * @param {Object} mensaje - Mensaje de finalizaci√≥n
         */
        function manejarAudioFinalizado(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`üîä Audio finalizado en ${origen}:`, datos.audioId);
            
            // Actualizar estado de reproducci√≥n
            estadoGlobal.audioReproduciendo = false;
            
            // Notificar a otros componentes
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.AUDIO.FINALIZADO,
                datos: { audioId: datos.audioId }
            }, [origen]);
        }

        /**
         * Maneja actualizaciones de estado de audio
         * @param {Object} mensaje - Mensaje de estado
         */
        function manejarEstadoAudio(mensaje) {
            const { origen, datos } = mensaje;
            estadoGlobal.audioReproduciendo = datos.reproduciendo;
            console.log(`üéµ Estado de audio actualizado por ${origen}:`, 
                datos.reproduciendo ? 'Reproduciendo' : 'Detenido');
        }

        /**
         * Maneja la finalizaci√≥n de un reto
         * @param {Object} mensaje - Mensaje de reto completado
         */
        function manejarRetoCompletado(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`üèÜ Reto completado por ${origen}:`, datos.retoId);
            
            // Actualizar estado de retos completados
            if (!estadoGlobal.retosCompletados) {
                estadoGlobal.retosCompletados = new Set();
            }
            estadoGlobal.retosCompletados.add(datos.retoId);
            
            // Notificar a otros componentes
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.RETOS.COMPLETADO,
                datos: {
                    retoId: datos.retoId,
                    timestamp: Date.now()
                }
            });
        }

        /**
         * Maneja la solicitud de abrir un reto
         * @param {Object} mensaje - Mensaje de apertura de reto
         */
        function manejarAbrirReto(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`üéÆ Abriendo reto solicitado por ${origen}:`, datos.retoId);
            
            // Verificar si el reto est√° disponible
            const paradaActual = AVENTURA_PARADAS.find(p => 
                p.parada_id === estadoGlobal.paradaActual || 
                p.padreid === estadoGlobal.paradaActual
            );
            
            if (!paradaActual || paradaActual.reto_id !== datos.retoId) {
                console.warn(`Intento de abrir reto no v√°lido: ${datos.retoId}`);
                return { exito: false, error: 'Reto no disponible en la parada actual' };
            }
            
            // Notificar a todos los componentes para abrir el reto
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.RETOS.ABRIR,
                datos: { 
                    retoId: datos.retoId,
                    origen: 'sistema',
                    timestamp: Date.now()
                }
            });
            
            return { exito: true };
        }

        /**
         * Maneja actualizaciones de estado del GPS
         * @param {Object} mensaje - Mensaje de estado del GPS
         */
        function manejarEstadoGPS(mensaje) {
            const { origen, datos } = mensaje;
            estadoGlobal.gpsActivo = datos.activo;
            console.log(`üìç Estado GPS actualizado por ${origen}:`, 
                datos.activo ? 'Activo' : 'Inactivo');
            
            // Notificar a otros componentes sobre el cambio de estado del GPS
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.GPS.ESTADO,
                datos: { 
                    activo: datos.activo,
                    precision: datos.precision,
                    timestamp: Date.now()
                }
            }, [origen]);
        }

        /**
         * Transmite un mensaje a todos los hijos excepto a los excluidos
         * @param {Object} mensaje - Mensaje a transmitir
         * @param {Array} [excluir=[]] - Lista de IDs de componentes a excluir
         */
        function broadcastMensaje(mensaje, excluir = []) {
            if (!mensaje.tipo) {
                console.error('Intento de broadcast sin tipo de mensaje');
                return;
            }
            
            HIJOS_SISTEMA.forEach(hijo => {
                if (!excluir.includes(hijo)) {
                    Mensajeria.enviarMensaje(hijo, mensaje.tipo, mensaje.datos || {})
                        .catch(error => {
                            console.error(`Error enviando mensaje a ${hijo}:`, error);
                        });
                }
            });
        }

        /**
         * Sincroniza el estado actual con todos los hijos
         */
        function sincronizarEstadoConHijos() {
            console.log('üîÑ Sincronizando estado con todos los hijos...');
            
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.SISTEMA.SINCRONIZAR_ESTADO,
                datos: {
                    modo: estadoGlobal.modo,
                    paradaActual: estadoGlobal.paradaActual,
                    gpsActivo: estadoGlobal.gpsActivo,
                    audioReproduciendo: estadoGlobal.audioReproduciendo,
                    retosCompletados: Array.from(estadoGlobal.retosCompletados || []),
                    timestamp: Date.now()
                }
            });
        }

        // ================== INICIALIZACI√ìN DE LA APLICACI√ìN ==================
        
        // Mostrar indicador de carga
        const loadingEl = document.createElement('div');
        loadingEl.className = 'loading';
        loadingEl.textContent = 'Inicializando aplicaci√≥n...';
        document.body.appendChild(loadingEl);

        // Funci√≥n para manejar errores de inicializaci√≥n
        function manejarErrorInicializacion(error) {
            console.error('Error de inicializaci√≥n:', error);
            loadingEl.textContent = `Error: ${error.message || 'Error desconocido'}`;
            loadingEl.style.backgroundColor = '#f44336';
            
            // A√±adir bot√≥n de reintento
            const reintentarBtn = document.createElement('button');
            reintentarBtn.textContent = 'Reintentar';
            reintentarBtn.style.marginTop = '10px';
            reintentarBtn.style.padding = '5px 10px';
            reintentarBtn.onclick = () => {
                loadingEl.textContent = 'Reintentando...';
                setTimeout(() => inicializar().catch(manejarErrorInicializacion), 1000);
            };
            loadingEl.appendChild(document.createElement('br'));
            loadingEl.appendChild(reintentarBtn);
        }

        // Iniciar la aplicaci√≥n cuando el DOM est√© listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }

        async function initApp() {
            console.log('üöÄ Iniciando aplicaci√≥n...');
            const loadingEl = document.createElement('div');
            loadingEl.id = 'loading-indicator';
            loadingEl.style.position = 'fixed';
            loadingEl.style.top = '50%';
            loadingEl.style.left = '50%';
            loadingEl.style.transform = 'translate(-50%, -50%)';
            loadingEl.style.padding = '20px';
            loadingEl.style.background = 'rgba(0,0,0,0.8)';
            loadingEl.style.color = 'white';
            loadingEl.style.borderRadius = '5px';
            loadingEl.style.zIndex = '1000';
            loadingEl.textContent = 'Inicializando aplicaci√≥n...';
            document.body.appendChild(loadingEl);
            
            try {
                await inicializar();
                console.log('‚úÖ Aplicaci√≥n iniciada correctamente');
                loadingEl.remove();
            } catch (error) {
                console.error('‚ùå Error al iniciar la aplicaci√≥n:', error);
                loadingEl.textContent = 'Error al iniciar: ' + (error.message || 'Error desconocido');
                loadingEl.style.background = '#f44336';
                
                // Add retry button
                const retryBtn = document.createElement('button');
                retryBtn.textContent = 'Reintentar';
                retryBtn.style.marginTop = '10px';
                retryBtn.style.padding = '5px 10px';
                retryBtn.onclick = () => {
                    loadingEl.textContent = 'Reintentando...';
                    setTimeout(() => initApp(), 1000);
                };
                loadingEl.appendChild(document.createElement('br'));
                loadingEl.appendChild(retryBtn);
            }
        }

    </script>
</body>
</html>
