<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Aventura 1 - Padre</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        /* Estilos del padre original... */
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        #mapa { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        body { margin: 0; padding: 0; background: transparent; }
        iframe { background: transparent; }
        
        /* ================== VARIABLES Y ESTILO HIJO 4 (RETOS) ================== */
        :root {
            --iframe-hijo4-width: 60vw;
            --iframe-hijo4-height: 40vh;
            --iframe-hijo4-top: 10vh;
            --iframe-hijo4-left: 50%;
            --iframe-hijo4-translate-x: -50%;
            --iframe-hijo4-z: 2000;
        }
        #hijo4 {
            position: fixed;
            top: var(--iframe-hijo4-top);
            left: var(--iframe-hijo4-left);
            width: var(--iframe-hijo4-width);
            height: var(--iframe-hijo4-height);
            transform: translateX(var(--iframe-hijo4-translate-x));
            z-index: var(--iframe-hijo4-z);
            border: 2px solid red;
            background: transparent;
            pointer-events: auto;
            display: none;
        }

        /* ESTILO ACTUALIZADO PARA info-parada */
        #info-parada {
            font-weight:bold;
            margin:0;
            padding: 12px 20px;
            background-color: rgba(255,255,255,0.95);
            border-radius: 10px;
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1201;
            display: none;
            color: #2c3e50;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            bottom: 340px;
            min-width: 250px;
            max-width: 90vw;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 4px solid #3498db;
            transition: all 0.3s ease;
        }
        
        /* Estilos para los marcadores personalizados */
        .custom-marker {
            position: relative;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
            text-shadow: 0 0 3px rgba(0,0,0,0.7);
        }
        
        .marker-pin {
            width: 30px;
            height: 30px;
            border-radius: 50% 50% 50% 0;
            background: #e74c3c;
            position: absolute;
            transform: rotate(-45deg);
            left: 0;
            top: 0;
            margin: -15px 0 0 -15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .marker-pin::after {
            content: '';
            width: 24px;
            height: 24px;
            margin: 3px 0 0 3px;
            background: #fff;
            position: absolute;
            border-radius: 50%;
            opacity: 0.3;
        }
        
        .marker-pin.start {
            background: #2ecc71;
        }
        
        .marker-pin.end {
            background: #3498db;
        }
        
        .custom-marker span {
            position: relative;
            top: -10px;
            left: 0;
            width: 100%;
            text-align: center;
            display: inline-block;
            transform: rotate(45deg);
        }
        #info-parada.error {
            background-color: #ffeaea;
            color: #b30000;
            border: 1.5px solid #b30000;
            animation: shake 0.3s;
        }
        @keyframes shake {
            0% { transform: translateX(-50%) translateY(0); }
            25% { transform: translateX(-50%) translateY(-3px); }
            50% { transform: translateX(-50%) translateY(3px); }
            75% { transform: translateX(-50%) translateY(-3px); }
            100% { transform: translateX(-50%) translateY(0); }
        }

        /* ================== ESTILO PARA VIDEO E IMAGEN ================== */
        #media-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 4000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        #media-container {
            width: 70vw; /* 70% del ancho de la ventana */
            height: 70vh; /* 70% de la altura de la ventana */
            max-width: 70vw;
            max-height: 70vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            padding: 15px;
        }

        #close-media {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff5252;
            color: white;
            border: none;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            font-size: 1.2em;
            cursor: pointer;
            z-index: 4001;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        #parada-video, #parada-imagen {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            display: none;
            border-radius: 8px;
            object-fit: contain; /* Mantiene proporci√≥n sin cortar */
        }
    </style>
</head>
<body>

    <img id="logo-aventura" src="https://valenciavguides.github.io/Aventura-1-esp-padre-con-hijos/fotos_Av1/LOGO%20LETRAS%20FINAL%20transparente%20recorte.png" alt="Logo" style="position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 3000; max-width: 300px; height: auto;" />

    <div id="mapa"></div>

    <div id="info-parada"></div>

    <!-- Rutas actualizadas para GitHub Pages -->
    <iframe id="hijo1-hamburguesa" src="./botones-y-subfunciones-hamburguesa.html" style="position:fixed; left:1vw; bottom:0vw; height: 265px; width:57px; z-index:1005; border: transparent; background:transparent; pointer-events:auto;"></iframe>
    <iframe id="hijo1-opciones" src="./botones-y-subfunciones-opciones.html" style="position:fixed; right:1vw; bottom:0vw; height: 265px; width:57px; z-index:1005; border: transparent; background:transparent; pointer-events:auto;"></iframe>
    <iframe id="hijo1-mapa" src="./botones-y-subfunciones-mapa.html" style="position:fixed; right:1vw; top:20vw; height: 200px; width:57px; z-index:1005; border: transparent; background:transparent; pointer-events:auto;"></iframe>
    <iframe id="hijo5-casa" src="./Av1-boton-casa.html" style="position:fixed; left:10px; top:10px; height:350px; width:100px; z-index:1005; border: transparent; background:transparent; pointer-events:auto; transition:width 0.3s;"></iframe>

    <iframe id="hijo3" src="./Av1_audio_esp.html"
            style="position:fixed;
                   bottom:-6px;
                   left:50%;
                   transform:translateX(-50%);
                   height:165px;
                   width:310px;
                   z-index:1000;
                   border: transparent;
                   display:block;
                   pointer-events:auto;"></iframe>

    <iframe id="hijo2" src="./Av1-botones-coordenadas.html"
            style="position:fixed;
                   bottom:151px;
                   left:50%;
                   transform:translateX(-50%);
                   height:165px;
                   width:310px;
                   z-index:1001;
                   border: none !important;
                   background-color: transparent !important;
                   overflow: hidden;
                   pointer-events:auto;"
            allow="geolocation"
            frameborder="0"></iframe>

    <iframe id="hijo4" src="./Av1-esp-retos-preguntas.html" style="display:none;"></iframe>

    <div id="media-overlay">
        <div id="media-container">
            <button id="close-media">X</button>
            <video id="parada-video" controls></video>
            <img id="parada-imagen">
        </div>
    </div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // ================== ESTRUCTURA SIMPLIFICADA ==================
        // Ruta base para los archivos de audio
        const AUDIO_BASE_PATH = './audios/';
        
        const PARADAS = [
            { parada: 0, audio: AUDIO_BASE_PATH + "parada_0_intro.mp3", reto: 2 },
            { tramo: 1, audio: AUDIO_BASE_PATH + "tramo_1_torres_plaza.mp3" },
            { parada: 1, audio: AUDIO_BASE_PATH + "parada_1.mp3", reto: 3 },
            { tramo: 2, audio: AUDIO_BASE_PATH + "tramo_2_plaza_muro.mp3" },
            { parada: 2, audio: AUDIO_BASE_PATH + "parada_2.mp3", reto: 4 },
            { tramo: 3, audio: AUDIO_BASE_PATH + "tramo_3_muro_borgia.mp3" },
            { parada: 3, audio: AUDIO_BASE_PATH + "parada_3.mp3", reto: 5 },
            { tramo: 4, audio: AUDIO_BASE_PATH + "tramo_4_lorenzo_virgen.mp3" },
            { parada: 4, audio: AUDIO_BASE_PATH + "parada_4.mp3", reto: 6 },
            { parada: 5, audio: AUDIO_BASE_PATH + "parada_5.mp3", reto: 7 }, // Puzzle plaza virgen
            { tramo: 5, audio: AUDIO_BASE_PATH + "tramo_5_virgen_almoina.mp3" },
            { parada: 6, audio: AUDIO_BASE_PATH + "parada_6.mp3", reto: 9 },
            { parada: 7, audio: AUDIO_BASE_PATH + "parada_7.mp3", reto: 10 },
            { parada: 8, audio: AUDIO_BASE_PATH + "parada_8.mp3", reto: 11 },
            { parada: 9, audio: AUDIO_BASE_PATH + "parada_9.mp3", reto: 12 },
            { parada: 10, audio: AUDIO_BASE_PATH + "parada_10.mp3", reto: 13 },
            { tramo: 6, audio: AUDIO_BASE_PATH + "tramo_6_almoina_museo.mp3" },
            { parada: 11, audio: AUDIO_BASE_PATH + "parada_11.mp3", reto: 14 },
            { parada: 12, audio: AUDIO_BASE_PATH + "parada_12.mp3", reto: 15 },
            { parada: 13, audio: AUDIO_BASE_PATH + "parada_13.mp3", reto: 16 },
            { tramo: 7, audio: AUDIO_BASE_PATH + "tramo_7_museo_arzobispal.mp3" },
            { parada: 14, audio: AUDIO_BASE_PATH + "parada_14.mp3", reto: 17 },
            { parada: 15, audio: AUDIO_BASE_PATH + "parada_15.mp3", reto: 18 },
            { tramo: 8, audio: AUDIO_BASE_PATH + "tramo_8_catedral_ayuntamiento.mp3" },
            { parada: 16, audio: AUDIO_BASE_PATH + "parada_16.mp3", reto: 19 },
            { tramo: 9, audio: AUDIO_BASE_PATH + "tramo_9_plaza_ayuntamiento.mp3" },
            { parada: 17, audio: AUDIO_BASE_PATH + "parada_17.mp3", reto: 20 },
            { parada: 18, audio: AUDIO_BASE_PATH + "parada_18.mp3", reto: 21 },
            { tramo: 10, audio: AUDIO_BASE_PATH + "tramo_10_ayuntamiento_estacion.mp3" },
            { parada: 19, audio: AUDIO_BASE_PATH + "parada_19.mp3", reto: 22 },
            { tramo: 11, audio: AUDIO_BASE_PATH + "tramo_11_estacion_toros.mp3" },
            { tramo: 12, audio: AUDIO_BASE_PATH + "tramo_12_toros_arabe.mp3" },
            { parada: 20, audio: AUDIO_BASE_PATH + "parada_20.mp3", reto: 23 },
            { parada: 21, audio: AUDIO_BASE_PATH + "parada_21.mp3", reto: 24 }, // Mitad aventura
            { tramo: 13, audio: AUDIO_BASE_PATH + "tramo_13_arabe_correos.mp3" }
        ];

        let paradaActual = 0; // √çndice de la parada actual

        // Mostrar mensaje contextual en la ventana de info
        function mostrarMensajeInfoParada(mensaje, esError = false) {
            const info = document.getElementById('info-parada');
            if (info) {
                info.textContent = mensaje;
                info.style.display = 'block';
                if (esError) {
                    info.classList.add('error');
                } else {
                    info.classList.remove('error');
                }
            }
        }

        // Mostrar la parada actual (nombre y n√∫mero)
        function mostrarParadaActual() {
            if (PARADAS[paradaActual]) {
                mostrarMensajeInfoParada(`Parada ${paradaActual + 1}: ${PARADAS[paradaActual].nombre}`);
            }
        }

        // Ocultar la informaci√≥n de la parada
        function ocultarInfoParada() {
            const info = document.getElementById('info-parada');
            if (info) {
                info.style.display = 'none';
            }
        }

        // ================== MAPA LEAFLET ==================
        let map;
        
        // Inicializar mapa
        document.addEventListener('DOMContentLoaded', function() {
            map = L.map('mapa', {
                center: [39.4622, -0.37802],
                zoom: 14,
                zoomControl: false, // Quitar botones + y -
                rotate: false, // Deshabilitado para mejor compatibilidad m√≥vil
                touchRotate: false, // Deshabilitado para m√≥viles
                shiftKeyRotate: false, // Deshabilitado
                bearing: 0 // Norte arriba por defecto
            });
            L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 40, attribution: ' OpenStreetMap contributors' }).addTo(map);

            setTimeout(() => {
                if (map) {
                    map.invalidateSize();
                    console.log("map.invalidateSize() ejecutado.");
                    console.log(" Mapa inicializado - Compatible con m√≥viles");
                }
            }, 100);
        });

        // --- Estado global del mapa ---
        window.markers = {}; // Almacena todos los marcadores
        window.currentPolyline = null; // Almacena la polyline actual
        let userLocationMarker = null; // Marcador de ubicaci√≥n del usuario
        let markerParada = null; // Marcador de parada actual

        // ================== CONTROL DE VISIBILIDAD HIJO 4 ==================
        const iframeHijo4 = document.getElementById('hijo4');
        function mostrarRetoEnHijo4(index) {
            if (index !== null && index !== undefined && PARADAS[window.paradaActual] && typeof PARADAS[window.paradaActual].reto === 'number') {
                iframeHijo4.contentWindow.postMessage({
                    type: 'mostrarRetoIndex',
                    index: PARADAS[window.paradaActual].reto
                }, '*');
                iframeHijo4.style.display = 'block';
                ocultarInfoParada();
            } else {
                console.warn("No se pudo mostrar el reto: √≠ndice o datos de reto inv√°lidos para la parada actual.");
            }
        }
        function ocultarHijo4() {
            iframeHijo4.style.display = 'none';
        }

        // ================== CONTROL DE VISIBILIDAD DE MEDIOS ==================
        const mediaOverlay = document.getElementById('media-overlay');
        const closeMediaButton = document.getElementById('close-media');
        const paradaVideo = document.getElementById('parada-video');
        const paradaImagen = document.getElementById('parada-imagen');

        function closeMediaOverlay() {
            mediaOverlay.style.display = 'none';
            paradaVideo.pause();
            paradaVideo.currentTime = 0;
            paradaVideo.style.display = 'none';
            paradaImagen.style.display = 'none';
        }

        closeMediaButton.addEventListener('click', closeMediaOverlay);

        function mostrarVideoParada(paradaData) {
            if (paradaData && paradaData.video) {
                paradaVideo.src = paradaData.video;
                paradaVideo.style.display = 'block';
                paradaImagen.style.display = 'none';
                mediaOverlay.style.display = 'flex';
                paradaVideo.play();
                mostrarMensajeInfoParada(`Mostrando video de Parada ${window.paradaActual + 1}: ${PARADAS[window.paradaActual]?.nombre || ''}`);
            }
        }

        function mostrarImagenParada(paradaData) {
            if (paradaData && paradaData.foto) {
                paradaImagen.src = paradaData.foto;
                paradaImagen.style.display = 'block';
                paradaVideo.style.display = 'none';
                mediaOverlay.style.display = 'flex';
                mostrarMensajeInfoParada(`Mostrando imagen de Parada ${window.paradaActual + 1}: ${PARADAS[window.paradaActual]?.nombre || ''}`);
            }
        }

        // ================== GESTI√ìN DE ESTADO ==================
        const navigationState = {
            currentStop: null,
            currentSegment: null,
            isNavigating: false,
            audioPlaying: false,
            activeChallenge: null,
            lastInteraction: null
        };

        // Utilidades de validaci√≥n
        function isValidStopIndex(index) {
            return Number.isInteger(index) && index >= 0 && index < PARADAS.length;
        }

        function isValidSegmentIndex(index) {
            return Number.isInteger(index) && index >= 0 && index < TRAMOS.length;
        }

        // Sistema de acuse de recibo de mensajes
        const pendingAcks = new Map();

        function sendMessageWithAck(iframeId, message, timeout = 5000) {
            return new Promise((resolve, reject) => {
                const iframe = document.getElementById(iframeId);
                if (!iframe || !iframe.contentWindow) {
                    reject(new Error(`Iframe ${iframeId} no encontrado`));
                    return;
                }

                const ackId = `ack_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const timer = setTimeout(() => {
                    pendingAcks.delete(ackId);
                    reject(new Error(`Tiempo de espera agotado para el mensaje ${message.type}`));
                }, timeout);

                pendingAcks.set(ackId, {
                    resolve: (data) => {
                        clearTimeout(timer);
                        resolve(data);
                    },
                    reject: (error) => {
                        clearTimeout(timer);
                        reject(error);
                    }
                });

                iframe.contentWindow.postMessage({ ...message, ackId }, '*');
            });
        }

        // Funci√≥n para manejar acuses de recibo
        function handleAck(message, event) {
            if (message.ackId && pendingAcks.has(message.ackId)) {
                const { resolve } = pendingAcks.get(message.ackId);
                pendingAcks.delete(message.ackId);
                resolve(message.data);
            }
        }

        // ================== MANEJO DE MENSAJES ==================
        // Versi√≥n del protocolo de mensajes
        const MESSAGE_PROTOCOL_VERSION = '1.0';
        
        // Tipos de mensajes soportados
        const MessageType = {
            // Mensajes de navegaci√≥n (Hijo 2)
            NAVEGACION_INICIADA: 'navegacionIniciada',
            NAVEGACION_CANCELADA: 'navegacionCancelada',
            SOLICITAR_SIGUIENTE_PARADA: 'solicitarSiguienteParada',
            SOLICITAR_PARADA_ANTERIOR: 'solicitarParadaAnterior',
            SOLICITAR_IR_A_PARADA: 'solicitarIrAParada',
            
            // Mensajes de audio (Hijo 3)
            AUDIO_TERMINADO: 'audioTerminado',
            AUDIO_ERROR: 'audioError',
            AUDIO_CARGADO: 'audioCargado',
            ESTADO_REPRODUCCION: 'estadoReproduccion',
            
            // Mensajes de retos (Hijo 4)
            RETO_COMPLETADO: 'retoCompletado',
            RETO_FALLIDO: 'retoFallido',
            SOLICITAR_AYUDA: 'solicitarAyuda',
            SOLICITAR_PISTA: 'solicitarPista',
            
            // Mensajes de mapa (Hijo 5)
            UBICACION_SELECCIONADA: 'ubicacionSeleccionada',
            MARCADOR_CLICKEADO: 'marcadorClickeado',
            RUTA_CALCULADA: 'rutaCalculada',
            ERROR_RUTA: 'errorRuta',
            
            // Comandos del padre
            PREPARAR_AUDIO: 'prepararAudio',
            REPRODUCIR_AUDIO: 'reproducirAudio',
            PAUSAR_AUDIO: 'pausarAudio',
            DETENER_AUDIO: 'detenerAudio',
            CAMBIAR_VOLUMEN: 'cambiarVolumen',
            MOSTRAR_RETO: 'mostrarReto',
            OCULTAR_RETO: 'ocultarReto',
            REINICIAR_RETO: 'reiniciarReto',
            ACTUALIZAR_UI: 'actualizarUI',
            DESBLOQUEAR_BOTONES: 'desbloquearBotones',
            BLOQUEAR_BOTONES: 'bloquearBotones'
        };
        
        // Manejadores para los botones de navegaci√≥n
        function handleMostrarPuntoInteres(datos, evento) {
            console.log('Mostrando punto de inter√©s para la parada:', datos.paradaActual);
            // Aqu√≠ puedes implementar la l√≥gica para mostrar el punto de inter√©s
            // Por ejemplo, centrar el mapa en la parada actual
            if (isValidStopIndex(datos.paradaActual)) {
                const parada = PARADAS[datos.paradaActual];
                if (parada && parada.coordenadas) {
                    map.setView([parada.coordenadas.lat, parada.coordenadas.lng], 18);
                    mostrarMensajeInfoParada(`Punto de inter√©s: ${parada.nombre}`);
                }
            }
            return { success: true };
        }

        function handleMostrarRutaCompleta(datos, evento) {
            console.log('Mostrando ruta completa desde la parada:', datos.paradaActual);
            // Aqu√≠ puedes implementar la l√≥gica para mostrar la ruta completa
            // Por ejemplo, mostrar todas las paradas restantes
            if (isValidStopIndex(datos.paradaActual)) {
                // Centrar el mapa en la parada actual
                const parada = PARADAS[datos.paradaActual];
                if (parada && parada.coordenadas) {
                    map.setView([parada.coordenadas.lat, parada.coordenadas.lng], 14);
                }
                // Aqu√≠ podr√≠as mostrar todas las paradas restantes en el mapa
                mostrarMensajeInfoParada('Mostrando ruta completa');
            }
            return { success: true };
        }

        function handleAlternarBrujula(datos, evento) {
            console.log('Modo br√∫jula:', datos.activada ? 'activado' : 'desactivado');
            // Aqu√≠ puedes implementar la l√≥gica para activar/desactivar la br√∫jula
            if (datos.activada) {
                // Activar modo br√∫jula
                mostrarMensajeInfoParada('Modo br√∫jula activado');
                // Aqu√≠ ir√≠a el c√≥digo para activar la br√∫jula
            } else {
                // Desactivar modo br√∫jula
                mostrarMensajeInfoParada('Modo br√∫jula desactivado');
                // Aqu√≠ ir√≠a el c√≥digo para desactivar la br√∫jula
            }
            return { success: true };
        }

        // Mapa de manejadores de mensajes
        const messageHandlers = {
            // Mensajes de navegaci√≥n (Hijo 2)
            'mostrarPuntoInteres': handleMostrarPuntoInteres,
            'mostrarRutaCompleta': handleMostrarRutaCompleta,
            'alternarBrujula': handleAlternarBrujula,
            [MessageType.NAVEGACION_INICIADA]: handleNavegacionIniciada,
            [MessageType.NAVEGACION_CANCELADA]: handleNavegacionCancelada,
            [MessageType.SOLICITAR_SIGUIENTE_PARADA]: handleSolicitarSiguienteParada,
            [MessageType.SOLICITAR_PARADA_ANTERIOR]: handleSolicitarParadaAnterior,
            [MessageType.SOLICITAR_IR_A_PARADA]: handleSolicitarIrAParada,
            'mostrarRutaNavegacion': handleMostrarRutaNavegacion,
            'llegadaParada': handleLlegadaParada,
            'cambioEstadoNavegacion': handleCambioEstadoNavegacion,
            'actualizarFlechaNavegacion': handleActualizarFlechaNavegacion,
            'sincronizarEstado': handleSincronizarEstado,
            'actualizarEstadoNavegacion': handleActualizarEstadoNavegacion,
            
            // Mensajes de audio (Hijo 3)
            [MessageType.AUDIO_TERMINADO]: handleAudioTerminado,
            [MessageType.AUDIO_ERROR]: handleAudioError,
            
            // Mensajes de retos (Hijo 4)
            [MessageType.RETO_COMPLETADO]: handleRetoCompletado,
            [MessageType.RETO_FALLIDO]: handleRetoFallido,
            [MessageType.OCULTAR_RETO]: ocultarHijo4,
            'mostrarReto': handleMostrarReto,
            
            // Mensajes de mapa (Hijo 5)
            [MessageType.UBICACION_SELECCIONADA]: handleUbicacionSeleccionada,
            [MessageType.MARCADOR_CLICKEADO]: handleMarcadorClickeado,
            'seleccionParada': (datos) => {
                if (isValidStopIndex(datos.parada)) {
                    manejarSeleccionParada(datos.parada);
                    // Sincronizar con Child 2
                    enviarMensaje('hijo2', 'ACTUALIZAR_UI', {
                        paradaActual: datos.parada,
                        navegacionActiva: true
                    });
                }
            },
            'seleccionTramo': (datos) => {
                if (isValidSegmentIndex(datos.tramo)) {
                    manejarSeleccionTramo(datos.tramo);
                    // Sincronizar con Child 2
                    enviarMensaje('hijo2', 'ACTUALIZAR_UI', {
                        tramoActual: datos.tramo,
                        navegacionActiva: true
                    });
                }
            },
            
            // Mensajes de contenido multimedia
            'mostrarImagen': handleMostrarImagen,
            'mostrarVideo': handleMostrarVideo,
            'mostrarVideoConZoom': handleMostrarVideoConZoom,
            
            // Mensajes del sistema
            'obtenerEstado': handleObtenerEstado,
            'validarParada': handleValidarParada
        };
        
        // Manejador para sincronizar el estado
        function handleSincronizarEstado() {
            return {
                navigationState,
                paradaActual: window.paradaActual,
                timestamp: Date.now()
            };
        }
        
        // Manejador para actualizar el estado de navegaci√≥n
        function handleActualizarEstadoNavegacion(datos) {
            if (datos.paradaActual !== undefined) {
                navigationState.currentStop = datos.paradaActual;
                window.paradaActual = datos.paradaActual;
            }
            if (datos.navegando !== undefined) {
                navigationState.isNavigating = datos.navegando;
            }
            return { success: true };
        }
        
        // Manejador para obtener el estado actual
        function handleObtenerEstado() {
            return {
                paradaActual: window.paradaActual,
                navigationState,
                version: MESSAGE_PROTOCOL_VERSION
            };
        }
        
        // Manejador para validar una parada
        function handleValidarParada({ paradaIndex }) {
            return verificarContenidoMultimedia(paradaIndex);
        }
        
        // Funci√≥n para verificar el contenido multimedia de una parada
        function verificarContenidoMultimedia(paradaIndex) {
            if (!isValidStopIndex(paradaIndex)) {
                return { valido: false, error: '√çndice de parada no v√°lido' };
            }
            
            const parada = PARADAS[paradaIndex];
            const resultado = { valido: true, advertencias: [] };
            
            // Verificar audio
            if (parada.audio) {
                console.log(`Verificando audio: ${parada.audio}`);
                // Aqu√≠ ir√≠a la l√≥gica para verificar el archivo de audio
            }
            
            // Verificar im√°genes
            if (parada.foto) {
                console.log(`Verificando imagen: ${parada.foto}`);
                // Aqu√≠ ir√≠a la l√≥gica para verificar el archivo de imagen
            }
            
            // Verificar videos
            if (parada.video) {
                console.log(`Verificando video: ${parada.video}`);
                // Aqu√≠ ir√≠a la l√≥gica para verificar el archivo de video
            }
            
            return resultado;
        }
        
        // Sincronizaci√≥n peri√≥dica entre Child 2 y Child 5
        function sincronizarEstadoNavegacion() {
            // Obtener el estado actual de Child 2
            enviarMensaje('hijo2', 'OBTENER_ESTADO_NAVEGACION')
                .then(estado => {
                    if (estado) {
                        // Actualizar el estado local
                        navigationState.currentStop = estado.paradaActual;
                        navigationState.isNavigating = estado.navegando;
                        
                        // Sincronizar con Child 5
                        return enviarMensaje('hijo5', 'ACTUALIZAR_ESTADO_NAVEGACION', {
                            paradaActual: estado.paradaActual,
                            navegando: estado.navegando
                        });
                    }
                })
                .catch(error => {
                    console.error('Error sincronizando estado de navegaci√≥n:', error);
                });
        }
        
        // Iniciar sincronizaci√≥n peri√≥dica cada 3 segundos
        setInterval(sincronizarEstadoNavegacion, 3000);
        
        // Validaci√≥n peri√≥dica del estado
        function validarEstadoNavegacion() {
            // Validar parada actual
            if (navigationState.currentStop !== null && !isValidStopIndex(navigationState.currentStop)) {
                console.error('Estado de navegaci√≥n inv√°lido: parada actual fuera de rango');
                navigationState.currentStop = null;
            }
            
            // Validar segmento actual
            if (navigationState.currentSegment !== null && !isValidSegmentIndex(navigationState.currentSegment)) {
                console.error('Estado de navegaci√≥n inv√°lido: segmento actual fuera de rango');
                navigationState.currentSegment = null;
            }
            
            // Verificar inactividad
            const ahora = Date.now();
            if (navigationState.lastInteraction && (ahora - navigationState.lastInteraction) > 30000) {
                console.log('Restableciendo estado de navegaci√≥n por inactividad');
                // Restablecer estado de navegaci√≥n
                Object.assign(navigationState, {
                    currentStop: null,
                    currentSegment: null,
                    isNavigating: false,
                    audioPlaying: false,
                    activeChallenge: null
                });
            }
        }
        
        // Ejecutar validaci√≥n cada 5 segundos
        setInterval(validarEstadoNavegacion, 5000);
        
        // Funci√≥n para enviar mensajes a los hijos
        function enviarMensaje(iframeId, tipo, datos = {}, opciones = {}) {
            const iframe = document.getElementById(iframeId);
            if (!iframe || !iframe.contentWindow) {
                console.error(`No se pudo encontrar el iframe con ID: ${iframeId}`);
                return false;
            }
            
            const mensaje = {
                version: MESSAGE_PROTOCOL_VERSION,
                tipo,
                timestamp: Date.now(),
                datos,
                ...opciones
            };
            
            if (opciones.secuencial) {
                mensaje.idMensaje = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                // Si se espera una respuesta, configuramos un timeout
                if (opciones.esperarRespuesta) {
                    return new Promise((resolve, reject) => {
                        const timeoutId = setTimeout(() => {
                            console.error(`Timeout esperando respuesta para mensaje ${mensaje.idMensaje}`);
                            reject(new Error('Timeout esperando respuesta'));
                        }, opciones.timeout || 5000);
                        
                        // Almacenamos el resolver para cuando llegue la respuesta
                        const respuestaHandler = (event) => {
                            if (event.data && event.data.idMensaje === mensaje.idMensaje) {
                                window.removeEventListener('message', respuestaHandler);
                                clearTimeout(timeoutId);
                                resolve(event.data);
                            }
                        };
                        
                        window.addEventListener('message', respuestaHandler);
                        iframe.contentWindow.postMessage(mensaje, '*');
                    });
                }
            }
            
            // Env√≠o normal sin esperar respuesta
            iframe.contentWindow.postMessage(mensaje, '*');
            return true;
        }
        
        // Manejador principal de mensajes
        window.addEventListener('message', (event) => {
            const mensaje = event.data;
            if (!mensaje || !mensaje.tipo) return;

            // Manejar acuses de recibo primero
            if (mensaje.tipo === 'ack') {
                handleAck(mensaje, event);
                return;
            }

            if (mensaje.version !== MESSAGE_PROTOCOL_VERSION) {
                console.warn(`Versi√≥n de protocolo no coincidente: ${mensaje.version} (esperado: ${MESSAGE_PROTOCOL_VERSION})`);
            }

            console.debug(`[Padre] Mensaje recibido:`, mensaje);

            // Actualizar √∫ltima interacci√≥n
            navigationState.lastInteraction = Date.now();

            const handler = messageHandlers[mensaje.tipo];
            if (typeof handler === 'function') {
                try {
                    const result = handler(mensaje.datos || {}, event);
                    
                    // Enviar acuse de recibo si se solicit√≥
                    if (mensaje.ackId) {
                        event.source.postMessage({
                            type: 'ack',
                            ackId: mensaje.ackId,
                            data: result
                        }, event.origin);
                    }
                } catch (error) {
                    console.error(`Error en el manejador para ${mensaje.tipo}:`, error);
                    if (mensaje.ackId) {
                        event.source.postMessage({
                            type: 'error',
                            ackId: mensaje.ackId,
                            error: error.message
                        }, event.origin);
                    }
                }
            } else {
                console.warn(`Manejador no implementado para tipo de mensaje: ${mensaje.tipo}`);
                // Enviar error si se esperaba un acuse
                if (mensaje.ackId) {
                    event.source.postMessage({
                        type: 'error',
                        ackId: mensaje.ackId,
                        error: `Tipo de mensaje no soportado: ${mensaje.tipo}`
                    }, event.origin);
                }
            }

        });

        // ================== MANEJADORES DE MENSAJES ==================
        
        // Manejadores para el Hijo 2 (botones y coordenadas)
        function handleNavegacionIniciada(datos, evento) {
            console.log('[Padre] Navegaci√≥n iniciada', datos);
            // Actualizar estado de navegaci√≥n
            // Notificar a otros componentes si es necesario
            enviarMensaje('hijo5', MessageType.ACTUALIZAR_UI, {
                navegacionActiva: true,
                origen: datos.origen,
                destino: datos.destino
            });
        }
        
        function handleNavegacionCancelada(datos, evento) {
            console.log('[Padre] Navegaci√≥n cancelada', datos);
            // Limpiar estado de navegaci√≥n
            enviarMensaje('hijo5', MessageType.ACTUALIZAR_UI, {
                navegacionActiva: false,
                ruta: null
            });
        }
        
        function handleSolicitarSiguienteParada(datos, evento) {
            console.log('[Padre] Solicitando siguiente parada');
            // L√≥gica para avanzar a la siguiente parada
            const siguienteParada = window.paradaActual + 1;
            if (siguienteParada < PARADAS.length) {
                manejarSeleccionParada(siguienteParada);
            } else {
                console.log('[Padre] No hay m√°s paradas disponibles');
                mostrarMensajeInfoParada('¬°Has completado todas las paradas!');
            }
        }
        
        function handleSolicitarParadaAnterior(datos, evento) {
            console.log('[Padre] Solicitando parada anterior');
            // L√≥gica para retroceder a la parada anterior
            if (window.paradaActual > 0) {
                manejarSeleccionParada(window.paradaActual - 1);
            } else {
                console.log('[Padre] Ya est√°s en la primera parada');
                mostrarMensajeInfoParada('Esta es la primera parada');
            }
        }
        
        function handleSolicitarIrAParada(datos, evento) {
            console.log(`[Padre] Solicitando ir a parada: ${datos.parada}`);
            // Validar que la parada solicitada existe
            if (datos.parada >= 0 && datos.parada < PARADAS.length) {
                manejarSeleccionParada(datos.parada);
            } else {
                console.error(`[Padre] Parada inv√°lida: ${datos.parada}`);
                mostrarMensajeInfoParada('Parada no encontrada', true);
            }
        }
        
        // Manejadores para el Hijo 3 (audio)
        function handleAudioTerminado(datos, evento) {
            console.log('[Padre] Audio terminado', datos);
            // L√≥gica para manejar el final del audio
            // Por ejemplo, avanzar autom√°ticamente al siguiente paso
            if (datos.autoAvanzar) {
                handleSolicitarSiguienteParada({}, null);
            }
        }
        
        function handleAudioError(datos, evento) {
            console.error('[Padre] Error en el reproductor de audio:', datos.error);
            // Mostrar mensaje de error al usuario
            mostrarMensajeInfoParada('Error al reproducir el audio', true);
        }
        
        // Manejadores para el Hijo 4 (retos y preguntas)
        function handleRetoCompletado(datos, evento) {
            console.log(`[Padre] Reto ${datos.retoId} completado`, datos);
            
            // Actualizar el estado de navegaci√≥n
            navigationState.activeChallenge = null;
            
            // Encontrar la parada actual para determinar los siguientes pasos
            const currentStop = PARADAS[window.paradaActual];
            if (!currentStop) {
                console.error('No se pudo encontrar la parada actual');
                return;
            }
            
            // Notificar al usuario
            mostrarMensajeInfoParada('¬°Reto completado con √©xito!');
            
            // Reproducir sonido de √©xito
            enviarMensaje('hijo3', MessageType.REPRODUCIR_AUDIO, {
                src: './audios/exito.mp3',
                volumen: 0.7
            });
            
            // Si hay una siguiente parada, navegar a ella
            if (window.paradaActual < PARADAS.length - 1) {
                const nextStop = window.paradaActual + 1;
                
                // Notificar a Child 2 para actualizar la UI
                enviarMensaje('hijo2', 'ACTUALIZAR_UI', {
                    paradaActual: nextStop,
                    navegacionActiva: true
                });
                
                // Actualizar el mapa en Child 5
                enviarMensaje('hijo5', 'ACTUALIZAR_UI', {
                    paradaActual: nextStop,
                    navegacionActiva: true
                });
                
                // Mostrar la siguiente parada
                manejarSeleccionParada(nextStop);
            } else {
                // √öltima parada completada
                mostrarMensajeInfoParada('¬°Has completado todas las paradas!');
            }
        }
        
        function handleRetoFallido(datos, evento) {
            console.log(`[Padre] Reto ${datos.retoId} fallido`, datos);
            // L√≥gica para manejar el fallo de un reto
            // Por ejemplo, ofrecer ayuda o reintentar
            if (datos.reintentosRestantes > 0) {
                mostrarMensajeInfoParada(`Int√©ntalo de nuevo. Te quedan ${datos.reintentosRestantes} intentos.`);
            } else {
                mostrarMensajeInfoParada('No te preocupes, puedes volver a intentarlo m√°s tarde.', true);
            }
        }
        
        // Manejadores para el Hijo 5 (mapa)
        function handleUbicacionSeleccionada(datos, evento) {
            console.log('[Padre] Ubicaci√≥n seleccionada en el mapa:', datos.coordenadas);
            // L√≥gica para manejar la selecci√≥n de ubicaci√≥n
            // Por ejemplo, actualizar la interfaz de usuario o mostrar informaci√≥n
            if (datos.paradaCercana !== undefined) {
                manejarSeleccionParada(datos.paradaCercana);
            }
        }
        
        function handleMarcadorClickeado(datos, evento) {
            console.log('[Padre] Marcador clickeado:', datos.marcadorId);
            // L√≥gica para manejar el clic en un marcador
            // Por ejemplo, mostrar informaci√≥n detallada o iniciar una acci√≥n
            if (datos.tipo === 'parada') {
                manejarSeleccionParada(datos.id);
            } else if (datos.tipo === 'tramo') {
                manejarSeleccionTramo(datos.id);
            }
        }
        
        // Manejadores para mensajes de navegaci√≥n
        function handleMostrarRutaNavegacion(datos, evento) {
            console.log('[Padre] Mostrando ruta de navegaci√≥n:', datos);
            procesarZoomNavegacion(datos);
        }
        
        function handleLlegadaParada(datos, evento) {
            console.log(`[Padre] Llegada a parada ${datos.parada}`);
            window.paradaActual = datos.parada;
            avanzarAParada(datos.parada);
            mostrarMensajeInfoParada(`¬°Has llegado a la Parada ${window.paradaActual + 1}: ${PARADAS[window.paradaActual]?.nombre || ''}!`);
        }
        
        // Manejadores para contenido multimedia
        function handleMostrarImagen(datos, evento) {
            console.log('[Padre] Mostrando imagen:', datos.info);
            mostrarImagenParada(datos.info);
        }
        
        function handleMostrarVideo(datos, evento) {
            console.log('[Padre] Mostrando video:', datos.info);
            mostrarVideoParada(datos.info);
        }
        
        function handleMostrarVideoConZoom(datos, evento) {
            console.log('[Padre] Mostrando video con zoom secuencial:', datos);
            if (datos.coordenadasZoom && map) {
                console.log('üé¨ Iniciando zoom secuencial + video');
                
                map.setView([datos.coordenadasZoom.lat, datos.coordenadasZoom.lng], 18, {
                    duration: (datos.secuencia?.paso1?.duracion / 1000) || 2.0,
                    easeLinearity: 0.25
                });
                
                setTimeout(() => {
                    console.log('üé¨ Mostrando video al 70% de la pantalla');
                    mostrarVideoParada({ video: datos.videoSrc });
                }, datos.secuencia?.paso1?.duracion || 2000);
            } else {
                mostrarVideoParada({ video: datos.videoSrc });
            }
        }
        
        // Manejadores para navegaci√≥n
        function handleCambioEstadoNavegacion(datos, evento) {
            console.log(`[Padre] Cambio de estado de navegaci√≥n:`, datos.estado, datos);
            // L√≥gica adicional para manejar cambios de estado de navegaci√≥n
        }
        
        function handleActualizarFlechaNavegacion(datos, evento) {
            console.log('[Padre] Actualizando flecha de navegaci√≥n');
            actualizarFlechaEnMapa(datos);
        }
        
        // Manejadores para retos
        function handleMostrarReto(datos, evento) {
            console.log(`[Padre] Mostrando reto: ${datos.retoId}`);
            mostrarRetoEnHijo4(datos.retoId);
        }

        // ================== MANEJO DE MENSAJES LEGADOS ==================
        // Este manejador es para compatibilidad con mensajes antiguos
        // Los nuevos mensajes ya son manejados por el sistema de mensajer√≠a
        window.addEventListener('message', (event) => {
            const mensaje = event.data;
            if (!mensaje) return;

            // Si el mensaje ya fue manejado por el nuevo sistema, lo ignoramos
            if (mensaje.version === MESSAGE_PROTOCOL_VERSION) {
                return;
            }

            // Mapeo de mensajes antiguos al nuevo sistema
            const mapeoMensajes = {
                // Mensajes de selecci√≥n
                'seleccionParada': { tipo: 'seleccionParada', campo: 'parada' },
                'seleccionTramo': { tipo: 'seleccionTramo', campo: 'tramo' },
                
                // Mensajes del Hijo 4
                'ocultarReto': { tipo: 'ocultarReto' },
                'reto-interactivo-completado': { tipo: 'retoCompletado' },
                'forceShowChallenge': { tipo: 'mostrarReto', campo: 'retoId' },
                
                // Mensajes del Hijo 2
                'mostrar-ruta-navegacion': { tipo: 'mostrarRutaNavegacion' },
                'ya-estoy-aqui': { tipo: 'llegadaParada', campo: 'parada' },
                'mostrar-imagen': { tipo: 'mostrarImagen', campo: 'info' },
                'mostrar-video': { tipo: 'mostrarVideo', campo: 'info' },
                'mostrar-video-con-zoom-secuencial': { tipo: 'mostrarVideoConZoom', campos: ['coordenadasZoom', 'secuencia', 'videoSrc'] },
                'cambio-estado-navegacion': { tipo: 'cambioEstadoNavegacion', campo: 'estado' },
                'actualizar-flecha-navegacion': { tipo: 'actualizarFlechaNavegacion' },
                
                // Mensajes del Hijo 3
                'audioFinalizado': { tipo: 'audioTerminado' }
            };

            // Buscar el mapeo para este mensaje
            let tipoMensaje = null;
            let datos = {};
            
            // Primero verificamos si es un mensaje con tipo en data.type o data.tipo
            const tipo = mensaje.type || mensaje.tipo;
            if (tipo && mapeoMensajes[tipo]) {
                const mapeo = mapeoMensajes[tipo];
                tipoMensaje = mapeo.tipo;
                
                // Copiar los datos seg√∫n el mapeo
                if (mapeo.campo) {
                    datos[mapeo.campo] = mensaje[mapeo.campo];
                } else if (mapeo.campos) {
                    mapeo.campos.forEach(campo => {
                        if (mensaje[campo] !== undefined) {
                            datos[campo] = mensaje[campo];
                        }
                    });
                }
                
                // Copiar todos los datos adicionales
                Object.keys(mensaje).forEach(key => {
                    if (key !== 'type' && key !== 'tipo' && !datos[key]) {
                        datos[key] = mensaje[key];
                    }
                });
            }
            
            // Si encontramos un mapeo, usamos el nuevo sistema
            if (tipoMensaje) {
                console.log(`[Legacy] Mapeando mensaje antiguo '${tipo}' a '${tipoMensaje}'`, datos);
                
                // Crear un evento de mensaje compatible con el nuevo sistema
                const nuevoEvento = {
                    data: {
                        version: MESSAGE_PROTOCOL_VERSION,
                        tipo: tipoMensaje,
                        datos: datos,
                        timestamp: Date.now()
                    }
                };
                
                // Procesar el mensaje con el nuevo sistema
                window.dispatchEvent(new MessageEvent('message', nuevoEvento));
                return;
            }
            
            // Si llegamos aqu√≠, es un mensaje no reconocido
            console.warn('[Legacy] Mensaje no reconocido:', mensaje);
        });

        // ================== MANEJO DE SELECCI√ìN DE PARADAS/TRAMOS ==================
        /**
         * Maneja la selecci√≥n de una parada en el mapa
         * @param {number} paradaIndex - √çndice de la parada seleccionada
         */
        function manejarSeleccionParada(paradaIndex) {
            console.log(`[Padre] Seleccionada parada ${paradaIndex}`);
            
            // Actualizar estado actual
            window.paradaActual = paradaIndex;
            
            // Desbloquear botones en hijo2
            const hijo2 = document.getElementById('hijo2');
            if (hijo2 && hijo2.contentWindow) {
                hijo2.contentWindow.postMessage({ type: 'unlockAllButtons' }, '*');
            }
            
            // Mostrar parada en el mapa
            if (map) {
                // Resetear vista del mapa
                resetMapView();
                
                // Buscar la parada seleccionada
                const parada = PARADAS.find(p => p.parada === paradaIndex);
                if (parada) {
                    // A√±adir marcador de la parada seleccionada
                    const marker = addMarker(
                        [parada.coordenadas.lat, parada.coordenadas.lng],
                        {
                            title: `Parada ${paradaIndex + 1}: ${parada.nombre}`,
                            icon: L.divIcon({
                                className: 'custom-marker',
                                html: `<div class="marker-pin"></div><span>${paradaIndex + 1}</span>`,
                                iconSize: [30, 42],
                                iconAnchor: [15, 42],
                                popupAnchor: [0, -42]
                            })
                        },
                        `parada-${paradaIndex}`
                    );
                    
                    // A√±adir popup informativo
                    marker.bindPopup(`
                        <div style="text-align: center;">
                            <h4 style="margin: 5px 0;">Parada ${paradaIndex + 1}</h4>
                            <p style="margin: 5px 0;">${parada.nombre}</p>
                        </div>
                    `);
                    
                    // Centrar el mapa en la parada seleccionada
                    map.setView([parada.coordenadas.lat, parada.coordenadas.lng], 18, { 
                        animate: true,
                        duration: 1
                    });
                    
                    // Mostrar mensaje informativo
                    mostrarMensajeInfoParada(`Parada ${paradaIndex + 1}: ${parada.nombre}`);
                    
                    // Forzar mostrar el reto si existe, sin esperar al audio
                    if (parada.reto) {
                        // Enviar mensaje al hijo3 (audio) para que se prepare
                        const hijo3 = document.getElementById('hijo3');
                        if (hijo3 && hijo3.contentWindow) {
                            hijo3.contentWindow.postMessage({
                                type: 'prepararAudioParada',
                                paradaIndex: paradaIndex
                            }, '*');
                        }
                        
                        // Mostrar el reto inmediatamente
                        mostrarRetoEnHijo4(parada.reto);
                    }
                }
            }
        }
        
        /**
         * Maneja la selecci√≥n de un tramo en el mapa
         * @param {number} tramoIndex - √çndice del tramo seleccionado
         */
        function manejarSeleccionTramo(tramoIndex) {
            console.log(`[Padre] Seleccionado tramo ${tramoIndex}`);
            
            // Desbloquear botones en hijo2
            const hijo2 = document.getElementById('hijo2');
            if (hijo2 && hijo2.contentWindow) {
                hijo2.contentWindow.postMessage({ type: 'unlockAllButtons' }, '*');
            }
            
            // Mostrar tramo en el mapa
            if (map) {
                resetMapView();
                
                // Encontrar el tramo seleccionado
                const tramo = TRAMOS.find(t => t.tramo === tramoIndex);
                if (tramo) {
                    // Convertir los puntos de la ruta al formato correcto
                    const puntosRuta = tramo.ruta.map(p => [p.lat, p.lng]);
                    
                    // Mostrar la ruta del tramo
                    showRoute(puntosRuta, {
                        color: '#3388ff',
                        weight: 6,
                        opacity: 0.8,
                        dashArray: '10, 6',
                        lineCap: 'round',
                        lineJoin: 'round'
                    });
                    
                    // A√±adir marcador de inicio
                    if (tramo.inicio) {
                        const startMarker = addMarker(
                            [tramo.inicio.lat, tramo.inicio.lng],
                            {
                                title: `Inicio del tramo ${tramoIndex}`,
                                icon: L.divIcon({
                                    className: 'custom-marker start',
                                    html: '<div class="marker-pin start"></div>',
                                    iconSize: [30, 42],
                                    iconAnchor: [15, 42]
                                })
                            },
                            `tramo-${tramoIndex}-inicio`
                        );
                    }
                    
                    // A√±adir marcador de fin
                    if (tramo.fin) {
                        const endMarker = addMarker(
                            [tramo.fin.lat, tramo.fin.lng],
                            {
                                title: `Fin del tramo ${tramoIndex}`,
                                icon: L.divIcon({
                                    className: 'custom-marker end',
                                    html: '<div class="marker-pin end"></div>',
                                    iconSize: [30, 42],
                                    iconAnchor: [15, 42]
                                })
                            },
                            `tramo-${tramoIndex}-fin`
                        );
                    }
                    
                    // Mostrar informaci√≥n del tramo
                    mostrarMensajeInfoParada(`Tramo ${tramoIndex}: ${tramo.nombre || 'Sin nombre'}`);
                }
            }
        }
        
        /**
         * Limpia todos los elementos del mapa (marcadores, rutas, etc.)
         */
        function resetMapView() {
            // Limpiar todos los marcadores
            if (window.markers) {
                Object.entries(window.markers).forEach(([id, marker]) => {
                    if (marker && map.hasLayer(marker)) {
                        map.removeLayer(marker);
                    }
                    delete window.markers[id];
                });
            }
            
            // Limpiar polyline actual
            if (window.currentPolyline && map.hasLayer(window.currentPolyline)) {
                map.removeLayer(window.currentPolyline);
                window.currentPolyline = null;
            }
            
            // Limpiar marcador de parada
            if (markerParada && map.hasLayer(markerParada)) {
                map.removeLayer(markerParada);
                markerParada = null;
            }
            
            // Limpiar marcador de ubicaci√≥n del usuario
            if (userLocationMarker && map.hasLayer(userLocationMarker)) {
                map.removeLayer(userLocationMarker);
                userLocationMarker = null;
            }
        }
        
        /**
         * A√±ade un marcador al mapa
         * @param {Object} latlng - Coordenadas {lat, lng}
         * @param {Object} options - Opciones del marcador
         * @param {string} id - Identificador √∫nico del marcador
         * @returns {L.Marker} - El marcador creado
         */
        function addMarker(latlng, options = {}, id = null) {
            const marker = L.marker(latlng, options).addTo(map);
            if (id) {
                // Si ya existe un marcador con este ID, lo eliminamos primero
                if (window.markers[id]) {
                    map.removeLayer(window.markers[id]);
                }
                window.markers[id] = marker;
            }
            return marker;
        }
        
        /**
         * Muestra una ruta en el mapa
         * @param {Array} points - Array de puntos de la ruta [{lat, lng}, ...]
         * @param {Object} options - Opciones de la polyline
         * @returns {L.Polyline} - La polyline creada
         */
        function showRoute(points, options = {}) {
            // Elimina la ruta anterior si existe
            if (window.currentPolyline) {
                map.removeLayer(window.currentPolyline);
            }
            
            // Crea una nueva polyline con las opciones por defecto
            const defaultOptions = {
                color: '#3388ff',
                weight: 5,
                opacity: 0.7,
                lineJoin: 'round',
                ...options
            };
            
            // Crea la polyline y la a√±ade al mapa
            window.currentPolyline = L.polyline(points, defaultOptions).addTo(map);
            
            // Ajusta la vista para mostrar toda la ruta
            map.fitBounds(window.currentPolyline.getBounds(), { 
                padding: [50, 50],
                maxZoom: 18
            });
            
            return window.currentPolyline;
        }
        
        function enviarGPSaHijo2(origen, destino) {
            const hijo2 = document.getElementById('hijo2');
            if (hijo2 && hijo2.contentWindow) {
                hijo2.contentWindow.postMessage({ 
                    tipo: 'navegar-de-a-b', 
                    origen: origen, 
                    destino: destino 
                }, '*');
            } else {
                console.warn("Advertencia: Iframe 'hijo2' no encontrado. No se puede enviar GPS.");
            }
        }

        // ================== ZOOM AUTOM√ÅTICO DE NAVEGACI√ìN ==================
        function procesarZoomNavegacion(mensaje) {
            if (!map || !mensaje.zoomAutomatico) {
                console.warn('Zoom navegaci√≥n: Mapa no inicializado o datos faltantes');
                return;
            }
            
            const { puntos, margen, duracion } = mensaje.zoomAutomatico;
            
            if (!puntos || puntos.length === 0) {
                console.warn('Zoom navegaci√≥n: No hay puntos para calcular bounds');
                return;
            }
            
            try {
                // Calcular bounds de la polyline
                const lats = puntos.map(p => p.lat);
                const lngs = puntos.map(p => p.lng);
                
                const bounds = L.latLngBounds([
                    [Math.min(...lats) - (margen || 0.001), Math.min(...lngs) - (margen || 0.001)],
                    [Math.max(...lats) + (margen || 0.001), Math.max(...lngs) + (margen || 0.001)]
                ]);
                
                // Zoom suave hacia la ruta completa
                map.fitBounds(bounds, { 
                    padding: [20, 20],
                    duration: (duracion || 1500) / 1000, // Convertir a segundos
                    easeLinearity: 0.25 // Transici√≥n suave
                });
                
                console.log(' Zoom navegaci√≥n aplicado:', mensaje.paradaOrigen, '‚Üí', mensaje.paradaDestino);
                console.log(' Puntos incluidos:', puntos.length, 'Margen:', margen);
                
            } catch (error) {
                console.error('Error en zoom navegaci√≥n:', error);
            }
        }
        
        // ================== FUNCIONES PRINCIPALES ==================
        function iniciarAventura() {
            window.paradaActual = 0;
            if (document.getElementById('hijo2')) {
                document.getElementById('hijo2').contentWindow.postMessage({
                    tipo: 'iniciar-gps-a-parada',
                    paradaDestinoNombre: PARADAS[window.paradaActual].nombre
                }, '*');
            }
            ocultarInfoParada();
        }
        
        function avanzarRuta() {
            ocultarInfoParada();
            window.paradaActual++;
            if (window.paradaActual < PARADAS.length - 1) {
                if (document.getElementById('hijo2')) {
                    document.getElementById('hijo2').contentWindow.postMessage({ 
                        tipo: 'navegar-de-a-b', 
                        origen: window.paradaActual, 
                        destino: window.paradaActual + 1 
                    }, '*');
                }
            } else {
                console.log('¬°Has completado todas las paradas de la aventura!');
            }
        }
        
        function avanzarAParada(paradaIndex) {
            document.getElementById('hijo3')?.contentWindow.postMessage({ 
                type: 'setAudioParada', 
                index: paradaIndex 
            }, '*');
        }
        
        function mostrarRutaEnMapa(ruta, origen, destino) {
            if (!map) return;
            if (polyline) { map.removeLayer(polyline); }
            if (markerA) { map.removeLayer(markerA); }
            if (markerB) { map.removeLayer(markerB); }
            if (!ruta || !Array.isArray(ruta) || ruta.length < 2) return;
            const latlngs = ruta.map(p => [p.lat, p.lng]);
            polyline = L.polyline(latlngs, { color: 'red', weight: 6 }).addTo(map);
            markerA = L.marker([ruta[0].lat, ruta[0].lng]).addTo(map);
            markerB = L.marker([ruta[ruta.length - 1].lat, ruta[ruta.length - 1].lng]).addTo(map);
            map.fitBounds(polyline.getBounds(), { padding: [40, 40] });
        }
        
        // Variables para flecha direccional
        let flechaNavegacion = null;
        
        function actualizarFlechaEnMapa(data) {
            if (!map || !data.ubicacion) return;
            
            // Remover flecha anterior
            if (flechaNavegacion) {
                map.removeLayer(flechaNavegacion);
            }
            
            // Crear nueva flecha direccional
            const { ubicacion, orientacionDispositivo, direccionObjetivo } = data;
            
            // Calcular rotaci√≥n de la flecha
            const rotacion = orientacionDispositivo || 0;
            
            // Crear icono de flecha rotado
            const flechaIcon = L.divIcon({
                html: `<div style="transform: rotate(${rotacion}deg); font-size: 20px; color: #007bff;">‚Üí</div>`,
                className: 'flecha-navegacion',
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
            
            // Agregar flecha al mapa
            flechaNavegacion = L.marker([ubicacion.lat, ubicacion.lng], {
                icon: flechaIcon
            }).addTo(map);
            
            console.log('üß≠ Flecha actualizada:', {
                ubicacion,
                orientacion: orientacionDispositivo,
                direccion: direccionObjetivo,
                progreso: data.progresoRuta
            });
        }
        
        // ================== INICIALIZACI√ìN ==================
        ocultarHijo4();
        ocultarInfoParada();
        closeMediaOverlay();
        
        window.paradaActual = 0;
        
        // Inicializar hijo2
        const hijo2 = document.getElementById('hijo2');
        if (hijo2 && hijo2.contentWindow) {
            hijo2.contentWindow.postMessage({ tipo: 'mostrar-foto-video', index: 0 }, '*');
            hijo2.contentWindow.postMessage({ tipo: 'activar-botones-foto-video', color: 'green' }, '*');
            hijo2.contentWindow.postMessage({ tipo: 'gps-on' }, '*');
        }
    </script>
</body>
</html>
