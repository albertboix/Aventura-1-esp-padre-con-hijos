<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Padre - Coordinador Central</title>
    
    <!-- Estilos CSS para el mapa -->
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #mapa {
            width: 100%;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background-color: #f0f0f0;
        }
        
        /* Loading indicator */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 8px;
        }
        
        /* Estilos para los iframes hijos */
        .iframe-hijo {
            border: none;
            position: fixed;
            z-index: 1000;
            pointer-events: auto;
            background: transparent;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        
        /* Estilos específicos para cada iframe */
        #hijo1-hamburguesa {
            left: 10px;
            bottom: 10px;
            width: 50px;
            height: 50px;
            z-index: 3001;
        }
        
        #hijo1-opciones {
            right: 10px;
            bottom: 10px;
            width: 50px;
            height: 50px;
            z-index: 3001;
        }
        
        #hijo2 {
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            height: 70px;
            z-index: 2000;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        #hijo3 {
            right: 20px;
            top: 100px;
            width: 300px;
            height: 80px;
            z-index: 2000;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        
        #hijo4 {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            height: 70vh;
            max-height: 600px;
            z-index: 2000;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.3);
            display: none; /* Inicialmente oculto */
        }
        
        /* Hijo 5 - Botón casa */
        #hijo5-casa {
            top: 70px;
            right: 0;
            width: 99%;
            height: 85px;
            z-index: 10000;
            border: 1px solid red;
            margin: 0;
            padding: 0;
            border-radius: 0;
        }
        
        /* Estilos para los marcadores */
        .marcador {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            text-align: center;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        
        .marcador-inicio {
            background-color: #4CAF50; /* Verde para el inicio */
            border: 2px solid #388E3C;
            width: 36px;
            height: 36px;
            font-size: 14px;
        }
        
        .marcador-parada {
            background-color: #2196F3; /* Azul para las paradas */
            border: 2px solid #1976D2;
            width: 32px;
            height: 32px;
            font-size: 12px;
        }
        
        .marcador-destacado {
            animation: pulse 1.5s infinite;
            transform: scale(1.1);
            z-index: 1000 !important;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        /* Estilos para los popups */
        .popup-parada {
            padding: 10px;
            text-align: center;
        }
        
        .popup-parada h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }
        
        .popup-parada p {
            margin: 5px 0;
            font-size: 14px;
            color: #666;
        }
        
        .btn-modo {
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            padding: 8px 15px;
            margin: 0 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-modo.active {
            background-color: #2196F3;
            color: white;
            border-color: #1976D2;
        }
        
        .btn-nav {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .btn-nav:hover {
            background-color: #1976D2;
            transform: translateY(-2px);
        }
        
        .btn-navegar {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 8px 15px;
            margin-top: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        .btn-navegar:hover {
            background-color: #1976D2;
        }
        
        /* Ajustes para los controles del mapa */
        .leaflet-control-zoom {
            margin-top: 60px !important; /* Para dejar espacio para el logo */
        }
        
        .leaflet-control-attribution {
            font-size: 10px;
            padding: 2px 5px;
            background: rgba(255, 255, 255, 0.8);
        }
        
        .leaflet-container {
            background: #f8f9fa;
        }
        
        /* Estilos para los marcadores personalizados */
        .marcador {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .marcador:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            z-index: 1000 !important;
        }
        
        .marcador-inicio {
            background-color: #28a745; /* Verde para el punto de inicio */
            width: 36px;
            height: 36px;
            margin-top: -18px !important;
            margin-left: -18px !important;
        }
        
        .marcador-parada {
            background-color: #007bff; /* Azul para las paradas normales */
            width: 32px;
            height: 32px;
            margin-top: -16px !important;
            margin-left: -16px !important;
        }
        
        .marcador-contenido {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Ajustes para el contenedor del mapa */
        #mapa {
            z-index: 1;
        }
    </style>
    
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
</head>

<body>
    <!-- Contenedor del mapa -->
    <div id="mapa" style="width: 100%; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1;"></div>
    
    <!-- Logo de la aplicación -->
    <img id="logo-aventura" src="https://valenciavguides.github.io/Aventura-1-esp-padre-con-hijos/fotos_Av1/LOGO%20LETRAS%20FINAL%20transparente%20recorte.png" 
         alt="Logo" 
         style="position: fixed; top: -32px; left: 50%; transform: translateX(-50%); z-index: 3000; width: 360px; height: 140px;" />
    
    <!-- Controles de modo -->
    <div id="modo-controls" style="position: fixed; top: 100px; left: 20px; z-index: 3000; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);">
        <button id="modo-casa" class="btn-modo active" data-modo="casa">Modo Casa</button>
        <button id="modo-aventura" class="btn-modo" data-modo="aventura">Modo Aventura</button>
    </div>
    
    <!-- Botones de navegación -->
    <div id="nav-buttons" style="position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 3000; display: flex; gap: 10px;">
        <button id="btn-mapa" class="btn-nav" title="Abrir Mapa">
            <i class="fas fa-map"></i> Mapa
        </button>
        <button id="btn-brujula" class="btn-nav" title="Abrir Brújula">
            <i class="fas fa-compass"></i> Brújula
        </button>
    </div>

    <!-- Logo de la aplicación -->
    <img id="logo-aventura" 
         src="https://valenciavguides.github.io/Aventura-1-esp-padre-con-hijos/fotos_Av1/LOGO%20LETRAS%20FINAL%20transparente%20recorte.png" 
         alt="Logo" 
         style="position: fixed; top: -32px; left: 50%; transform: translateX(-50%); z-index: 3000; width: 360px; height: 140px;" />

    <!-- Mensaje de información -->
    <div id="info-parada"></div>
    
    <!-- Fondo blanco para el logo con borde naranja -->
    <div style="position: fixed; top: 0; left: 0; right: 0; width: 99%; margin: 0 auto; height: 80px; background: white; z-index: 2999; border: 2px solid #ec7c26; border-top: none; border-bottom-left-radius: 15px; border-bottom-right-radius: 15px;"></div>

    <!-- Contenedores para los iframes hijos -->
    <iframe id="hijo1-hamburguesa" class="iframe-hijo" src="./botones-y-subfunciones-hamburguesa.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo1-opciones" class="iframe-hijo" src="./botones-y-subfunciones-opciones.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo5-casa" class="iframe-hijo" src="./Av1-boton-casa.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo3" class="iframe-hijo" src="./Av1_audio_esp.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo2" class="iframe-hijo" src="./Av1-botones-coordenadas.html" allow="geolocation" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
    <iframe id="hijo4" class="iframe-hijo" src="./Av1-esp-retos-preguntas.html" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>

    <!-- Script principal -->
    <script type="module">
        // ================== IMPORTACIÓN DE MÓDULOS ==================
        import { Mensajeria, TIPOS_MENSAJE } from './mensajeria.js';
        
        // Variables globales
        
        // URLs de los iframes hijos
        const HIJOS_URLS = {
            audio: 'Av1_audio_esp.html',
            coordenadas: 'Av1-botones-coordenadas.html',
            retos: 'Av1-esp-retos-preguntas.html',
            casa: 'Av1-boton-casa.html'
        };
        
        // Estado de los iframes
        const iframes = {
            audio: null,
            coordenadas: null,
            retos: null,
            casa: null
        };
        
        // Elementos del DOM
        const domElements = {};
        
        // Inicializar elementos del DOM
        function initDOMElements() {
            domElements.modoCasa = document.getElementById('modo-casa');
            domElements.modoAventura = document.getElementById('modo-aventura');
            domElements.btnMapa = document.getElementById('btn-mapa');
            domElements.btnBrujula = document.getElementById('btn-brujula');
            domElements.mapa = document.getElementById('mapa');
            domElements.logo = document.getElementById('logo-aventura');
            
            // Crear iframes dinámicamente
            createIframes();
        }
        
        // Crear iframes dinámicamente
        function createIframes() {
            // Iframe de audio
            iframes.audio = createIframe('hijo-audio', HIJOS_URLS.audio, {
                position: 'fixed',
                bottom: '20px',
                right: '20px',
                width: '300px',
                height: '100px',
                zIndex: '2000',
                border: 'none',
                borderRadius: '10px',
                boxShadow: '0 2px 10px rgba(0,0,0,0.2)'
            });
            
            // Iframe de coordenadas
            iframes.coordenadas = createIframe('hijo-coordenadas', HIJOS_URLS.coordenadas, {
                position: 'fixed',
                bottom: '20px',
                left: '50%',
                transform: 'translateX(-50%)',
                width: '90%',
                maxWidth: '500px',
                height: '80px',
                zIndex: '2000',
                border: 'none',
                borderRadius: '10px',
                boxShadow: '0 2px 10px rgba(0,0,0,0.2)'
            });
            
            // Iframe de retos
            iframes.retos = createIframe('hijo-retos', HIJOS_URLS.retos, {
                position: 'fixed',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                width: '90%',
                maxWidth: '600px',
                height: '70vh',
                maxHeight: '600px',
                zIndex: '3000',
                border: 'none',
                borderRadius: '10px',
                boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
                display: 'none' // Inicialmente oculto
            });
            
            // Iframe de casa
            iframes.casa = createIframe('hijo-casa', HIJOS_URLS.casa, {
                position: 'fixed',
                top: '20px',
                right: '20px',
                width: '50px',
                height: '50px',
                zIndex: '3000',
                border: 'none',
                borderRadius: '50%',
                overflow: 'hidden',
                boxShadow: '0 2px 10px rgba(0,0,0,0.2)'
            });
        }
        
        // Función auxiliar para crear iframes
        function createIframe(id, src, styles) {
            const iframe = document.createElement('iframe');
            iframe.id = id;
            iframe.src = src;
            iframe.allow = 'geolocation';
            
            // Aplicar estilos
            Object.assign(iframe.style, styles);
            
            // Agregar al body
            document.body.appendChild(iframe);
            
            return iframe;
        }
        
        // Inicializar manejadores de eventos
        function initEventListeners() {
            // Manejadores de modo
            domElements.modoCasa?.addEventListener('click', () => cambiarModo('casa'));
            domElements.modoAventura?.addEventListener('click', () => cambiarModo('aventura'));
            
            // Manejadores de botones de navegación
            domElements.btnMapa?.addEventListener('click', abrirMapa);
            domElements.btnBrujula?.addEventListener('click', abrirBrujula);
            
            // Manejador de mensajes de los iframes hijos
            window.addEventListener('message', manejarMensajeHijo);
        }
        
        // Cambiar entre modos
        function cambiarModo(modo) {
            if (estadoGlobal.modo === modo) return;
            
            // Actualizar estado
            estadoGlobal.modo = modo;
            
            // Actualizar interfaz
            if (modo === 'casa') {
                domElements.modoCasa.classList.add('active');
                domElements.modoAventura.classList.remove('active');
                // Ocultar elementos específicos de aventura
                if (iframes.coordenadas) iframes.coordenadas.style.display = 'none';
            } else {
                domElements.modoAventura.classList.add('active');
                domElements.modoCasa.classList.remove('active');
                // Mostrar elementos específicos de aventura
                if (iframes.coordenadas) iframes.coordenadas.style.display = 'block';
            }
            
            // Notificar a los hijos del cambio de modo
            enviarMensajeATodos('sistema:cambioModo', { modo });
            
            console.log(`Modo cambiado a: ${modo}`);
        }
        
        // Abrir mapa en nueva pestaña
        function abrirMapa() {
            window.open('mapa.html', '_blank');
        }
        
        // Abrir brújula en nueva pestaña
        function abrirBrujula() {
            window.open('brujula.html', '_blank');
        }
        
        // Enviar mensaje a todos los iframes hijos
        function enviarMensajeATodos(tipo, datos = {}) {
            Object.values(iframes).forEach(iframe => {
                if (iframe && iframe.contentWindow) {
                    iframe.contentWindow.postMessage({ tipo, datos }, '*');
                }
            });
        }
        
        // ================== CONSTANTES ==================
        const ERROR_TIMEOUT = 5000; // 5 segundos de timeout para operaciones asíncronas
        const NOTIFICATION_DURATION = 5000; // 5 segundos para mostrar notificaciones
        const MONITOR_INTERVAL = 30000; // 30 segundos para el intervalo de monitoreo
        const INACTIVITY_THRESHOLD = 30000; // 30 segundos de inactividad
        const MAX_RETRY_ATTEMPTS = 3; // Número máximo de reintentos
        const RETRY_DELAY = 1000; // 1 segundo entre reintentos
        
        // ================== MANEJADORES DE ESTADO ==================
        
        /**
         * Maneja el inicio de un reto
         * @param {Object} datos - Datos del reto iniciado
         * @throws {Error} Si los datos del reto no son válidos
         */
        function manejarRetoIniciado(datos) {
            const { retoId, paradaId } = datos;
            console.log(`🏁 Reto iniciado: ${retoId} en parada ${paradaId}`);
            
            // Actualizar estado global
            estadoGlobal.retoActivo = {
                id: retoId,
                paradaId,
                inicio: new Date(),
                completado: false
            };
            
            // Notificar a otros componentes
            enviarMensajeATodos('reto:estado', {
                retoId,
                paradaId,
                estado: 'iniciado',
                timestamp: new Date().toISOString()
            });
            
            // Mostrar indicador de reto activo en la interfaz
            mostrarMensajeInterfaz({
                tipo: 'info',
                titulo: 'Reto Iniciado',
                mensaje: `Has comenzado el reto en la parada ${paradaId}`,
                duracion: 5000
            });
        }
        
        /**
         * Maneja la finalización de un reto
         * @param {Object} datos - Datos del reto completado
         */
        /**
         * Maneja la finalización de un reto
         * @param {Object} datos - Datos del reto completado
         * @throws {Error} Si los datos del reto no son válidos
         */
        /**
         * Maneja la finalización de un reto
         * @param {Object} mensaje - Mensaje con los datos del reto completado
         * @throws {Error} Si los datos del reto no son válidos
         */
        function manejarRetoCompletado(mensaje) {
            if (!mensaje || typeof mensaje !== 'object' || !mensaje.datos) {
                throw new Error('Mensaje de reto completado no válido');
            }
            
            const { datos } = mensaje;
            if (typeof datos !== 'object') {
                throw new Error('Datos de reto no válidos');
            }
            const { retoId, paradaId, exito, puntos } = datos;
            const tiempoTranscurrido = estadoGlobal.retoActivo 
                ? (new Date() - estadoGlobal.retoActivo.inicio) / 1000 
                : null;
            
            console.log(`✅ Reto completado: ${retoId} en parada ${paradaId} - Éxito: ${exito}, Puntos: ${puntos || 0}`);
            
            // Actualizar estado global
            if (estadoGlobal.retoActivo) {
                estadoGlobal.retoActivo.completado = true;
                estadoGlobal.retoActivo.exito = exito;
                estadoGlobal.retoActivo.puntos = puntos || 0;
                estadoGlobal.retoActivo.fin = new Date();
                estadoGlobal.retoActivo.tiempo = tiempoTranscurrido;
                
                // Registrar en el historial
                estadoGlobal.historialRetos = estadoGlobal.historialRetos || [];
                estadoGlobal.historialRetos.push({...estadoGlobal.retoActivo});
                
                // Actualizar estadísticas
                if (exito && puntos) {
                    estadoGlobal.estadisticas = estadoGlobal.estadisticas || {};
                    estadoGlobal.estadisticas.puntosTotales = (estadoGlobal.estadisticas.puntosTotales || 0) + puntos;
                    estadoGlobal.estadisticas.retosCompletados = (estadoGlobal.estadisticas.retosCompletados || 0) + 1;
                }
            }
            
            // Notificar a otros componentes
            enviarMensajeATodos('reto:estado', {
                retoId,
                paradaId,
                estado: 'completado',
                exito,
                puntos: puntos || 0,
                tiempo: tiempoTranscurrido,
                timestamp: new Date().toISOString()
            });
            
            // Mostrar resultado en la interfaz
            const mensaje = exito 
                ? `¡Reto completado con éxito! +${puntos} puntos`
                : 'El reto no se pudo completar';
                
            mostrarMensajeInterfaz({
                tipo: exito ? 'exito' : 'error',
                titulo: exito ? '¡Éxito!' : 'Inténtalo de nuevo',
                mensaje: mensaje,
                duracion: 5000
            });
        }
        
        /**
         * Maneja la reproducción de audio
         * @param {Object} datos - Datos del audio a reproducir
         */
        function manejarReproducirAudio(datos) {
            const { audioId, volumen = 1, loop = false } = datos;
            console.log(`🔊 Reproduciendo audio: ${audioId}`);
            
            // Aquí iría la lógica para reproducir el audio
            // Por ejemplo, podrías tener un reproductor de audio en el padre
            // o delegar la reproducción a un iframe específico
            
            // Notificar a otros componentes
            enviarMensajeATodos('audio:estado', {
                audioId,
                estado: 'reproduciendo',
                timestamp: new Date().toISOString()
            });
            
            // Actualizar estado
            estadoGlobal.audioActual = {
                id: audioId,
                inicio: new Date(),
                volumen,
                loop,
                pausado: false
            };
        }
        
        /**
         * Muestra un mensaje en la interfaz de usuario
         * @param {Object} datos - Datos del mensaje a mostrar
         */
        /**
         * Muestra un mensaje en la interfaz de usuario y lo elimina después de la duración especificada
         * @param {Object} datos - Datos del mensaje a mostrar
         * @param {string} [datos.tipo=info] - Tipo de mensaje (info, exito, error)
         * @param {string} [datos.titulo=''] - Título del mensaje
         * @param {string} [datos.mensaje=''] - Contenido del mensaje
         * @param {number} [datos.duracion=3000] - Duración en milisegundos
         */
        function mostrarMensajeInterfaz(datos) {
            if (!datos || typeof datos !== 'object') {
                console.error('Datos de mensaje no válidos');
                return;
            }
            
            const { 
                tipo = 'info', 
                titulo = '', 
                mensaje = '', 
                duracion = NOTIFICATION_DURATION 
            } = datos;
            
            console.log(`💬 [${tipo.toUpperCase()}] ${titulo}: ${mensaje}`);
            
            // Crear elemento de notificación
            const notificacion = document.createElement('div');
            notificacion.className = `notificacion notificacion-${tipo}`;
            notificacion.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 20px;
                background: ${tipo === 'error' ? '#f44336' : tipo === 'exito' ? '#4CAF50' : '#2196F3'};
                color: white;
                border-radius: 4px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                z-index: 5000;
                max-width: 300px;
                transform: translateX(120%);
                transition: transform 0.3s ease;
            `;
            
            if (titulo) {
                const tituloEl = document.createElement('div');
                tituloEl.style.fontWeight = 'bold';
                tituloEl.style.marginBottom = '5px';
                tituloEl.textContent = titulo;
                notificacion.appendChild(tituloEl);
            }
            
            if (mensaje) {
                const mensajeEl = document.createElement('div');
                mensajeEl.textContent = mensaje;
                notificacion.appendChild(mensajeEl);
            }
            
            document.body.appendChild(notificacion);
            
            // Animar entrada
            setTimeout(() => {
                notificacion.style.transform = 'translateX(0)';
            }, 10);
            
            // Eliminar después de la duración especificada
            const removeNotification = () => {
                notificacion.style.transform = 'translateX(120%)';
                const removeElement = () => {
                    if (notificacion.parentNode) {
                        notificacion.removeEventListener('transitionend', removeElement);
                        notificacion.parentNode.removeChild(notificacion);
                    }
                };
                notificacion.addEventListener('transitionend', removeElement);
            };
            
            // Usar requestAnimationFrame para mejor rendimiento
            requestAnimationFrame(() => {
                setTimeout(removeNotification, duracion);
            });
        }
        
        // Manejador de mensajes de los iframes hijos
        function manejarMensajeHijo(event) {
            const { tipo, datos } = event.data || {};
            
            // Validar origen del mensaje
            const iframe = Object.values(iframes).find(
                iframe => iframe && iframe.contentWindow === event.source
            );
            
            if (!iframe) return; // Mensaje de origen desconocido
            
            console.log(`Mensaje recibido de iframe ${iframe.id}:`, { tipo, datos });
            
            // Manejar diferentes tipos de mensajes
            switch (tipo) {
                case 'sistema:listo':
                    // El iframe hijo está listo
                    manejarHijoListo(iframe.id);
                    break;
                case 'navegacion:solicitudParada':
                    // El iframe hijo solicita información de una parada
                    manejarSolicitudParada(datos);
                    break;
                case 'navegacion:llegadaDestino':
                    // El iframe hijo notifica llegada a un destino
                    manejarLlegadaDestino(datos);
                    break;
                case 'reto:iniciado':
                    // Un reto ha sido iniciado
                    manejarRetoIniciado(datos);
                    break;
                case 'reto:completado':
                    // Un reto ha sido completado
                    manejarRetoCompletado(datos);
                    break;
                case 'audio:reproducir':
                    // Reproducir un audio específico
                    manejarReproducirAudio(datos);
                    break;
                case 'ui:mostrarMensaje':
                    // Mostrar un mensaje en la interfaz
                    mostrarMensajeInterfaz(datos);
                    break;
                // Agregar más manejadores según sea necesario
            }
        }
        // Estado global de la aplicación
        // ================== ESTADO GLOBAL MEJORADO ==================
        const estadoGlobal = {
            // Estado de la aplicación
            modo: 'casa',
            gpsActivo: false,
            paradaActual: 0,
            tramoActual: 0,
            
            // Gestión de hijos
            hijosListos: new Set(),
            hijosConectados: new Map(), // Mapa de estado de conexión de hijos
            
            // Componentes
            mapa: null,
            audioReproduciendo: false,
            retoActivo: null,
            
            // Datos
            coordenadasParadas: new Map(),
            marcadores: new Map(),
            rutas: new Map(),
            
            // Estado del sistema
            errores: [],
            ultimaActualizacion: null,
            version: '2.0.0',
            
            // Rendimiento
            metricas: {
                mensajesEnviados: 0,
                mensajesRecibidos: 0,
                ultimaComprobacion: Date.now()
            },
            
            // Configuración
            config: {
                maxReintentos: 3,
                tiempoEsperaInicial: 1000,
                debug: true,
                tiempoEsperaHijos: 10000, // 10 segundos para que los hijos se conecten
                intervaloMonitoreo: 30000, // Verificar estado de hijos cada 30 segundos
                maxReintentosConexion: 3
            },
            coordenadasParadas: new Map(),
            marcadores: new Map(),
            rutas: new Map(),
            hijosConectados: new Map(),
            grupoMarcadores: null,
            intervaloMonitoreo: null,
            metricas: {
                mensajesEnviados: 0,
                mensajesRecibidos: 0,
                errores: 0
            },
            errores: []
        };
        
        // Mostrar indicador de carga
        const loadingEl = document.createElement('div');
        loadingEl.className = 'loading';
        loadingEl.textContent = 'Cargando mapa...';
        document.body.appendChild(loadingEl);
        
        // ================== CONFIGURACIÓN GLOBAL ==================
        const CONFIG = {
            iframeId: 'padre',
            debug: true,
            logLevel: 1
        };

        // ================== ESTADO GLOBAL MEJORADO ==================
        const estadoGlobal = {
            // Estado de la aplicación
            modo: 'casa',
            gpsActivo: false,
            paradaActual: 0,
            tramoActual: 0,
            
            // Gestión de hijos
            hijosListos: new Set(),
            hijosConectados: new Map(), // Mapa de estado de conexión de hijos
            
            // Componentes
            mapa: null,
            audioReproduciendo: false,
            retoActivo: null,
            
            // Datos
            coordenadasParadas: new Map(),
            marcadores: new Map(),
            rutas: new Map(),
            
            // Estado del sistema
            errores: [],
            ultimaActualizacion: null,
            version: '2.0.0',
            
            // Rendimiento
            metricas: {
                mensajesEnviados: 0,
                mensajesRecibidos: 0,
                ultimaComprobacion: Date.now()
            },
            
            // Configuración
            config: {
                maxReintentos: 3,
                tiempoEsperaInicial: 1000,
                debug: true,
                tiempoEsperaHijos: 10000, // 10 segundos para que los hijos se conecten
                intervaloMonitoreo: 30000, // Verificar estado de hijos cada 30 segundos
                maxReintentosConexion: 3
            }
        };

        // Lista de hijos conocidos con sus configuraciones
        const HIJOS_SISTEMA = [
            { id: 'hijo1-hamburguesa', tipo: 'menu', requerido: false },
            { id: 'hijo1-opciones', tipo: 'menu', requerido: false },
            { id: 'hijo2', tipo: 'navegacion', requerido: true },
            { id: 'hijo3', tipo: 'audio', requerido: true },
            { id: 'hijo4', tipo: 'retos', requerido: true },
            { id: 'hijo5-casa', tipo: 'ui', requerido: true }
        ];
        
        // Mapa de tipos de mensajes que cada hijo debe manejar
        const MENSAJES_POR_TIPO = {
            audio: [
                TIPOS_MENSAJE.AUDIO.REPRODUCIR,
                TIPOS_MENSAJE.AUDIO.PAUSAR,
                TIPOS_MENSAJE.AUDIO.DETENER,
                TIPOS_MENSAJE.AUDIO.ESTADO
            ],
            navegacion: [
                TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA,
                TIPOS_MENSAJE.NAVEGACION.CAMBIO_TRAMO,
                TIPOS_MENSAJE.NAVEGACION.ESTADO,
                TIPOS_MENSAJE.GPS.ESTADO
            ],
            retos: [
                TIPOS_MENSAJE.RETOS.ABRIR,
                TIPOS_MENSAJE.RETOS.CERRAR,
                TIPOS_MENSAJE.RETOS.COMPLETADO,
                TIPOS_MENSAJE.RETOS.VALIDAR
            ],
            ui: [
                TIPOS_MENSAJE.UI.ACTUALIZAR,
                TIPOS_MENSAJE.UI.MOSTRAR_IMAGEN,
                TIPOS_MENSAJE.UI.MOSTRAR_VIDEO,
                TIPOS_MENSAJE.UI.CERRAR_MEDIA
            ]
        };

        // ================== DATOS DE PARADAS ==================
        const AVENTURA_PARADAS = [
            // Parada 0 – INICIO (Torres de Serranos start) reto 2 (223, 226, 228, 229)
            { padreid: "padre-P-0", tipo: "inicio", parada_id: 'P-0', audio_id: "audio-P-0", reto_id: "R-2" },
            // tramo 1 (Torres de Serranos → Plaza de la crida) (2, 126,)
            { padreid: "padre-TR-1", tipo: "tramo", tramo_id: 'TR-1', audio_id: "audio-TR-1" },
            // Parada 1 - Plaza de la crida (Puente de Serranos) Reto 3 (233) //
            { padreid: "padre-P-1", tipo: "parada", parada_id: 'P-1', audio_id: "audio-P-1", reto_id: "R-3" },
            // tramo 2 (Plaza de la crida → Calle Muro de Santa Ana) (81) //
            { padreid: "padre-TR-2", tipo: "tramo", tramo_id: 'TR-2', audio_id: "audio-TR-2" },
            // Parada 2 (Calle Muro de Santa Ana) Reto 4 (68) //
            { padreid: "padre-P-2", tipo: "parada", parada_id: 'P-2', audio_id: "audio-P-2", reto_id: "R-4" },
            // tramo 3 (Calle Muro de Santa Ana → Palacio de los Borgia) (52) //
            { padreid: "padre-TR-3", tipo: "tramo", tramo_id: 'TR-3', audio_id: "audio-TR-3" },
            // Parada 3 (Iglesia de San Lorenzo) Reto 5 (686, 682-B, 462, 683, 684) //
            { padreid: "padre-P-3", tipo: "parada", parada_id: 'P-3', audio_id: "audio-P-3", reto_id: "R-5" },
            // tramo 4 (Iglesia de San Lorenzo → Plaza de la Virgen) (465-B) //
            { padreid: "padre-TR-4", tipo: "tramo", tramo_id: 'TR-4', audio_id: "audio-TR-4" },
            // Parada 4 (Plaza de la Virgen) Reto 6 (466, 467) //
            { padreid: "padre-P-4", tipo: "parada", parada_id: 'P-4', audio_id: "audio-P-4", reto_id: "R-6" },
            // Parada 5 (Plaza de la Virgen) Reto 7, 8 Puzzle plaza de la virgen (468)  //
            { 
                padreid: "padre-P-5",
                tipo: "parada", 
                parada_id: 'P-5', 
                audio_id: "audio-P-5", 
                retos: [
                    { tipo: "reto", id: "R-7" },
                    { tipo: "puzzle", id: "PZ-8" }
                ] 
            },
            // tramo 5 (Plaza de la Virgen → Plaza de la Almoína) (477-B, 479, 141, 83, 8-C) //
            { padreid: "padre-TR-5", tipo: "tramo", tramo_id: 'TR-5', audio_id: "audio-TR-5" },
            // Parada 6 (Panel cerámico muro Catedral) Reto 9 (434, 440, 441, 442) //
            { padreid: "padre-P-6", tipo: "parada", parada_id: 'P-6', audio_id: "audio-P-6", reto_id: "R-9" },
            // Parada 7 (Capilla exterior catedral) Reto 10 (443, 444, 445) //
            { padreid: "padre-P-7", tipo: "parada", parada_id: 'P-7', audio_id: "audio-P-7", reto_id: "R-10" },
            // Parada 8 (Capilla exterior catedral) Reto 11 (445) //
            { padreid: "padre-P-8", tipo: "parada", parada_id: 'P-8', audio_id: "audio-P-8", reto_id: "R-11" },
            // Parada 9 (Arco Novo Catedral y Puerta Negra Basílica) (446, 355, 447, 11-B, 451, 452) //
            { padreid: "padre-P-9", tipo: "parada", parada_id: 'P-9', audio_id: "audio-P-9" },
            // Parada 10 (Casa del Punt de Gantxo) Reto 12 (51-C, 454, 455, 455-B, 456, 148) //
            { padreid: "padre-P-10", tipo: "parada", parada_id: 'P-10', audio_id: "audio-P-10", reto_id: "R-12"  },
            // tramo 6 (Plaza de la Almoína (casa del punt de Gantxo) → Plaza Decimo Junio Bruto) (457, 10-B)//
            { padreid: "padre-TR-6", tipo: "tramo", tramo_id: 'TR-6', audio_id: "audio-TR-6" },
            // Parada 11 (Museo arqueológico La Almoína) Reto 13 (458) //
            { padreid: "padre-P-11", tipo: "parada", parada_id: 'P-11', audio_id: "audio-P-11", reto_id: "R-13" },
            // Parada 12 (Museo arqueológico La Almoína 2) (459, 460, 461) //
            { padreid: "padre-P-12", tipo: "parada", parada_id: 'P-12', audio_id: "audio-P-12" },
            // Parada 13 (Vista de la Catedral, Cimborrio) Reto 14 (8-C, 464) //
            { padreid: "padre-P-13", tipo: "parada", parada_id: 'P-13', audio_id: "audio-P-13", reto_id: "R-14" },
            // tramo 7 (Museo arqueológico La Almoína → Palacio Arzobispal) (85) //
            { padreid: "padre-TR-7", tipo: "tramo", tramo_id: 'TR-7', audio_id: "audio-TR-7" },
            // Parada 14 (Palacio Arzobispal y Puerta Románica de la Catedral) Reto 15 (673, 86, 426-B, 141, 437, 438) //
            { padreid: "padre-P-14", tipo: "parada", parada_id: 'P-14', audio_id: "audio-P-14", reto_id: "R-15" },
            // Parada 15 (Puerta Románica de la Catedral) (439) //
            { padreid: "padre-P-15", tipo: "parada", parada_id: 'P-15', audio_id: "audio-P-15" },
            // tramo 8 (Puerta Románica de la Catedral → Plaza del Ayuntamiento) (125) //
            { padreid: "padre-TR-8", tipo: "tramo", tramo_id: 'TR-8', audio_id: "audio-TR-8" },
            // Parada 16 (Plaza del Ayuntamiento) (13-B, 263, 332, 14-C) //
            { padreid: "padre-P-16", tipo: "parada", parada_id: 'P-16', audio_id: "audio-P-16" },
            // tramo 9 (Plaza del Ayuntamiento → Edificio del Ayuntamiento) (334, 335) //
            { padreid: "padre-TR-9", tipo: "tramo", tramo_id: 'TR-9', audio_id: "audio-TR-9" },
            // Parada 17 (Edificio del Ayuntamiento) Reto 16 (336, 337, 338) //
            { padreid: "padre-P-17", tipo: "parada", parada_id: 'P-17', audio_id: "audio-P-17", reto_id: "R-16" },
            // Parada 18 (Edificio del Ayuntamiento, leyenda del murciélago) (339, 340, 341, 54) //
            { padreid: "padre-P-18", tipo: "parada", parada_id: 'P-18', audio_id: "audio-P-18" },
            // tramo 10 (Edificio del Ayuntamiento → Estación del Norte) (87, 15-C) //
            { padreid: "padre-TR-10", tipo: "tramo", tramo_id: 'TR-10', audio_id: "audio-TR-10" },
            // Parada 19 (Estación del Norte) Reto 17, 18 Puzzle Estación del Norte (326) //
            { 
                padreid: "padre-P-19",
                tipo: "parada", 
                parada_id: 'P-19', 
                audio_id: "audio-P-19", 
                retos: [
                    { tipo: "reto", id: "R-17" },
                    { tipo: "puzzle", id: "PZ-18" }
                ] 
            },
            // tramo 11 (Estación del Norte → Plaza de Toros) (20-C, 323-B, 88) //
            { padreid: "padre-TR-11", tipo: "tramo", tramo_id: 'TR-11', audio_id: "audio-TR-11" },
            // Tramo 12 (Plaza de Toros → Casa estilo Árabe) (89, 3-D) //
            { padreid: "padre-TR-12", tipo: "tramo", tramo_id: 'TR-12', audio_id: "audio-TR-12" },
            // Parada 20 (Casa estilo Árabe) Reto 19 (99) //
            { padreid: "padre-P-20", tipo: "parada", parada_id: 'P-20', audio_id: "audio-P-20", reto_id: "R-19" },
            // Parada 21 (Casa estilo Árabe, mitad Aventura) (100) //
            { padreid: "padre-P-21", tipo: "parada", parada_id: 'P-21', audio_id: "audio-P-21" },
            // tramo 13 (Casa estilo Árabe → Palacio de Comunicaciones) (21-B) //
            { padreid: "padre-TR-13", tipo: "tramo", tramo_id: 'TR-13', audio_id: "audio-TR-13" },
            // Parada 22 (Palacio de Comunicaciones) Reto 20 y Reto 21 (700, 343, 344) //
            { padreid: "padre-P-22", tipo: "parada", parada_id: 'P-22', audio_id: "audio-P-22", retos: ["R-20", "R-21"] },
            // Parada 23 (Edificio Suay) Reto 21 (693, 693-B) //
            { padreid: "padre-P-23", tipo: "parada", parada_id: 'P-23', audio_id: "audio-P-23", reto_id: "R-21" },
            // tramo 14 (Palacio de Comunicaciones, edificio Suay → Banco de València) (345, 347, 348, 22, 109) //
            { padreid: "padre-TR-14", tipo: "tramo", tramo_id: 'TR-14', audio_id: "audio-TR-14" },
            // Parada 24 (Banco de Valencia) Reto 22 (349, 350) //
            { padreid: "padre-P-24", tipo: "parada", parada_id: 'P-24', audio_id: "audio-P-24", reto_id: "R-22" },
            // tramo 15 (Banco de València → Palacio del Marqués de Dos Aguas) (351, 23-B, 352, 354) //
            { padreid: "padre-TR-15", tipo: "tramo", tramo_id: 'TR-15', audio_id: "audio-TR-15" },
            // Parada 25 (Palacio del Marqués de Dos Aguas) (356, 357)//
            { padreid: "padre-P-25", tipo: "parada", parada_id: 'P-25', audio_id: "audio-P-25" },
            // tramo 16 (Palacio del Marqués → Mercado Central) (358, 359-B, 101) //
            { padreid: "padre-TR-16", tipo: "tramo", tramo_id: 'TR-16', audio_id: "audio-TR-16" },
            // Parada 26 (Mercado central) Reto23 (701, 24-D, 361, 362, 363, 364) //
            { padreid: "padre-P-26", tipo: "parada", parada_id: 'P-26', audio_id: "audio-P-26", reto_id: "R-23" },
            // tramo 17 (Mercado Central → Iglesia de los Santos Juanes) (274, 27-C) //
            { padreid: "padre-TR-17", tipo: "tramo", tramo_id: 'TR-17', audio_id: "audio-TR-17" },
            // Parada 27 (Iglesia de los Santos Juanes) Reto 24) (365, 366) //
            { padreid: "padre-P-27", tipo: "parada", parada_id: 'P-27', audio_id: "audio-P-27", reto_id: "R-24" },
            // Parada 28 (Iglesia de los Santos Juanes reto 25) (367) //
            { padreid: "padre-P-28", tipo: "parada", parada_id: 'P-28', audio_id: "audio-P-28", reto_id: "R-25" },
            // tramo 18 (Iglesia Santos Juanes → Lonja de València) (368, 369, 28, 370, 371, 372, 373, 374, 375, 376, 377) //
            { padreid: "padre-TR-18", tipo: "tramo", tramo_id: 'TR-18', audio_id: "audio-TR-18" },
            // Parada 29 (Lonja Puerta de Los Pecados barquero) Reto 27 (378, 379) //
            { padreid: "padre-P-29", tipo: "parada", parada_id: 'P-29', audio_id: "audio-P-29", reto_id: "R-27" },
            // Parada 30 (Lonja Puerta de Los Pecados árbol muerto) Reto 28 (380, 381) //
            { padreid: "padre-P-30", tipo: "parada", parada_id: 'P-30', audio_id: "audio-P-30", reto_id: "R-28" },
            // tramo 19 (Lonja Gárgolas) (383) //
            { padreid: "padre-TR-19", tipo: "tramo", tramo_id: 'TR-19', audio_id: "audio-TR-19" },
            // Parada 31 (Lonja Gárgolas ángel vasija) Reto 29 (384) //
            { padreid: "padre-P-31", tipo: "parada", parada_id: 'P-31', audio_id: "audio-P-31", reto_id: "R-29" },
            // Parada 32 (Lonja Gárgolas barbudo y león) Reto 30 (385) //
            { padreid: "padre-P-32", tipo: "parada", parada_id: 'P-32', audio_id: "audio-P-32", reto_id: "R-30" },
            // Parada 33 (Lonja Gárgolas fornicador ventana) Reto 31, Puzzle 26 ) (386) //
            { padreid: "padre-P-33", tipo: "parada", parada_id: 'P-33', audio_id: "audio-P-33", retos: [ { tipo: "reto", id: "R-31" }, { tipo: "puzzle", id: "PZ-26" } ] },
            // tramo 20 (Lonja → Plaza del Doctor Collado) (388, 389, 390, 391, 392) //
            { padreid: "padre-TR-20", tipo: "tramo", tramo_id: 'TR-20', audio_id: "audio-TR-20" },
            // tramo 21 (Plaza del Doctor Collado → Plaza del Negrito) (333, 397, 41, 398, 198, 671, 522, 32-C) //
            { padreid: "padre-TR-21", tipo: "tramo", tramo_id: 'TR-21', audio_id: "audio-TR-21" },
            // Parada 34 (Fuente del Negrito) Reto 32 (382, 501) //
            { padreid: "padre-P-34", tipo: "parada", parada_id: 'P-34', audio_id: "audio-P-34", reto_id: "R-32" },
            // tramo 22 (Plaza del Negrito → Calle Caballeros) (33-B, 486, 480-B) //
            { padreid: "padre-TR-22", tipo: "tramo", tramo_id: 'TR-22', audio_id: "audio-TR-22" },
            // Parada 35 (Palau de la Generalitat) (481-B, 482-B, 2-D) //
            { padreid: "padre-P-35", tipo: "parada", parada_id: 'P-35', audio_id: "audio-P-35" },
            // tramo 23 (Palacio de la Generalitat → Calle de los Serranos - FINAL)  //
            { padreid: "padre-TR-23", tipo: "tramo", tramo_id: 'TR-23', audio_id: "audio-TR-23" },
            // Parada 36 (Torres de Serranos Final) //
            { padreid: "padre-P-36", tipo: "parada", parada_id: 'P-36', audio_id: "audio-P-36" }
        ];

        // ================== INICIALIZACIÓN DE COORDENADAS ==================
        
        /**
         * Inicia el mapa de coordenadas de las paradas solicitando los datos al hijo2
         * @returns {Promise<boolean>} True si se solicitaron las coordenadas correctamente
         */
        async function inicializarCoordenadasParadas() {
            try {
                console.log('🔄 Solicitando coordenadas al hijo2...');
                
                // Asegurarse de que el mapa de coordenadas esté inicializado
                if (!estadoGlobal.coordenadasParadas) {
                    estadoGlobal.coordenadasParadas = new Map();
                }
                
                // Solicitar coordenadas al hijo2
                const respuesta = await Mensajeria.enviarMensaje('hijo2', {
                    tipo: 'solicitar_coordenadas_paradas',
                    timestamp: Date.now()
                });
                
                if (respuesta && respuesta.coordenadas) {
                    console.log('✅ Coordenadas recibidas del hijo2:', respuesta.coordenadas);
                    // Actualizar el estado global con las coordenadas recibidas
                    estadoGlobal.coordenadasParadas = new Map(Object.entries(respuesta.coordenadas));
                    return true;
                } else {
                    console.error('❌ No se recibieron coordenadas del hijo2');
                    throw new Error('No se pudieron obtener las coordenadas del componente de mapa');
                }
                
            } catch (error) {
                console.error('❌ Error al obtener coordenadas del hijo2:', error);
                throw error; // Propagar el error para que el sistema lo maneje
            }
        }
        
        // ================== FUNCIONES AUXILIARES DE MARCADORES ==================
        
        /**
         * Crea los marcadores iniciales para todas las paradas
         */
        /**
         * Crea los marcadores iniciales para todas las paradas
         * @returns {Promise<boolean>} True si se crearon los marcadores correctamente
         */
        /**
         * Crea los marcadores iniciales para todas las paradas
         * @returns {Promise<boolean>} True si se crearon los marcadores correctamente
         */
        async function crearMarcadoresIniciales() {
            return new Promise((resolve) => {
                try {
                    if (!estadoGlobal || !estadoGlobal.mapa) {
                        console.warn('No se pueden crear marcadores: el mapa no está inicializado');
                        resolve(false);
                        return;
                    }
                    
                    // Verificar si existen las coordenadas de las paradas
                    if (!estadoGlobal.coordenadasParadas || estadoGlobal.coordenadasParadas.size === 0) {
                        console.warn('No hay coordenadas disponibles para crear los marcadores');
                        resolve(false);
                        return;
                    }
                    
                    try {
                        // Inicializar el grupo de marcadores si no existe
                        if (!estadoGlobal.grupoMarcadores) {
                            estadoGlobal.grupoMarcadores = L.layerGroup().addTo(estadoGlobal.mapa);
                        } else {
                            // Limpiar marcadores existentes
                            estadoGlobal.grupoMarcadores.clearLayers();
                        }
                        
                        // Inicializar el mapa de marcadores si no existe
                        if (!estadoGlobal.marcadoresParadas) {
                            estadoGlobal.marcadoresParadas = new Map();
                        } else {
                            estadoGlobal.marcadoresParadas.clear();
                        }
                        
                        // Contadores para estadísticas
                        let marcadoresCreados = 0;
                        let errores = 0;
                        
                        // Recorrer todas las paradas y crear marcadores
                        AVENTURA_PARADAS.forEach(parada => {
                            // Solo procesar paradas e inicio, no tramos
                            if (parada.tipo !== 'parada' && parada.tipo !== 'inicio') {
                                return;
                            }
                            
                            try {
                                const marcador = crearMarcadorParada(parada);
                                if (marcador) {
                                    estadoGlobal.marcadoresParadas.set(parada.parada_id, marcador);
                                    marcadoresCreados++;
                                }
                            } catch (error) {
                                console.error(`Error al crear marcador para ${parada.parada_id}:`, error);
                                errores++;
                            }
                        });
                        
                        console.log(`✅ ${marcadoresCreados} marcadores creados, ${errores} errores`);
                        resolve(marcadoresCreados > 0);
                    } catch (error) {
                        console.error('Error al crear marcadores iniciales:', error);
                        resolve(false);
                    }
                } catch (error) {
                    console.error('Error inesperado en crearMarcadoresIniciales:', error);
                    resolve(false);
                }
            });
        }
        
        /**
         * Crea un marcador para una parada específica
         * @param {Object} parada - Objeto con los datos de la parada
         * @returns {L.Marker|null} Marcador de Leaflet o null si no se pudo crear
         */
        function crearMarcadorParada(parada) {
            try {
                // Validar parámetros de entrada
                if (!parada || typeof parada !== 'object') {
                    console.error('Error: El parámetro parada no es un objeto válido');
                    return null;
                }

                const paradaId = parada.parada_id;
                
                // Validar ID de parada
                if (!paradaId || typeof paradaId !== 'string') {
                    console.error('Error: ID de parada no válido:', paradaId);
                    return null;
                }
                
                // Obtener coordenadas
                if (!estadoGlobal.coordenadasParadas || !(estadoGlobal.coordenadasParadas instanceof Map)) {
                    console.error('Error: El mapa de coordenadas no está inicializado');
                    return null;
                }
                
                const coords = estadoGlobal.coordenadasParadas.get(paradaId);
                
                // Validar coordenadas
                if (!Array.isArray(coords) || coords.length !== 2 || 
                    typeof coords[0] !== 'number' || typeof coords[1] !== 'number') {
                    console.error(`Coordenadas no válidas para la parada ${paradaId}:`, coords);
                    return null;
                }
                
                // Determinar la clase CSS según el tipo de parada
                const esInicio = parada.tipo === 'inicio';
                const claseIcono = esInicio ? 'marcador-inicio' : 'marcador-parada';
                const numeroParada = paradaId.replace('P-', '');
                
                // Validar número de parada
                if (!/^\d+$/.test(numeroParada) && !esInicio) {
                    console.error('Número de parada no válido:', numeroParada);
                    return null;
                }
                
                // Crear icono personalizado
                let icono;
                try {
                    icono = L.divIcon({
                        className: `marcador ${claseIcono}`,
                        html: `<div class="marcador-contenido">${numeroParada}</div>`,
                        iconSize: esInicio ? [36, 36] : [32, 32],
                        iconAnchor: esInicio ? [18, 36] : [16, 32],
                        popupAnchor: [0, -32]
                    });
                } catch (error) {
                    console.error('Error al crear el icono del marcador:', error);
                    // Usar un marcador predeterminado en caso de error
                    icono = L.icon({
                        iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
                        iconSize: [25, 41],
                        iconAnchor: [12, 41],
                        popupAnchor: [1, -34]
                    });
                }
                
                // Crear marcador
                let marcador;
                try {
                    marcador = L.marker(coords, { 
                        icon: icono,
                        title: `Parada ${numeroParada}${esInicio ? ' (Inicio)' : ''}`,
                        alt: `Marcador de ${esInicio ? 'inicio' : 'parada'} ${numeroParada}`,
                        zIndexOffset: esInicio ? 1000 : 500,
                        riseOnHover: true
                    });
                } catch (error) {
                    console.error('Error al crear el marcador:', error);
                    return null;
                }
                
                // Configurar popup
                try {
                    const popupContent = `
                        <div class="popup-parada">
                            <h4>${esInicio ? 'Punto de Inicio' : 'Parada ' + numeroParada}</h4>
                            <p>ID: ${paradaId}</p>
                            ${parada.reto_id ? `<p><strong>Reto:</strong> ${parada.reto_id}</p>` : ''}
                            <button class="btn-navegar" data-parada="${paradaId}">
                                Navegar aquí
                            </button>
                        </div>
                    `;
            
                    // Añadir popup con contenido HTML
                    marcador.bindPopup(popupContent, {
                        maxWidth: 250,
                        minWidth: 180,
                        className: 'popup-parada-estilo',
                        closeButton: true,
                        autoClose: false,
                        closeOnClick: false
                    });
                    
                    // Manejar eventos del marcador
                    marcador.on('click', function(e) {
                        console.log(`Marcador de ${paradaId} clickeado`);
                        // Centrar el mapa en el marcador con zoom
                        estadoGlobal.mapa.setView(coords, 18);
                    });
                    
                    // Añadir al grupo de marcadores
                    if (estadoGlobal.grupoMarcadores) {
                        marcador.addTo(estadoGlobal.grupoMarcadores);
                    } else {
                        console.error('Error: grupoMarcadores no está inicializado');
                        return null;
                    }
                    
                    return marcador;
                } catch (error) {
                    console.error('Error al configurar el marcador:', error);
                    return null;
                }
            } catch (error) {
                console.error('Error al crear el marcador:', error);
                return null;
            }
        }
        
        /**
         * Muestra u oculta los marcadores de las paradas
         * @param {boolean} mostrar - Indica si mostrar u ocultar los marcadores
         */
        /**
         * Muestra u oculta los marcadores de las paradas
         * @param {boolean} [mostrar=true] - Indica si mostrar u ocultar los marcadores
         * @returns {void}
         */
        function mostrarMarcadoresParadas(mostrar = true) {
            if (!estadoGlobal.grupoMarcadores) return;
            
            if (mostrar) {
                estadoGlobal.mapa.addLayer(estadoGlobal.grupoMarcadores);
            } else {
                estadoGlobal.mapa.removeLayer(estadoGlobal.grupoMarcadores);
            }
        }
        
        /**
         * Mueve el mapa a la ubicación de una parada específica
         * @param {string} paradaId - ID de la parada
         * @param {number} zoom - Nivel de zoom (opcional)
         */
        function centrarEnParada(paradaId, zoom = 18) {
            const marcador = estadoGlobal.marcadoresParadas.get(paradaId);
            if (marcador) {
                const coords = marcador.getLatLng();
                estadoGlobal.mapa.setView(coords, zoom);
                
                // Abrir el popup del marcador
                marcador.openPopup();
                
                // Destacar temporalmente el marcador
                const icon = marcador.getElement();
                if (icon) {
                    icon.classList.add('marcador-destacado');
                    setTimeout(() => {
                        icon.classList.remove('marcador-destacado');
                    }, 2000);
                }
            } else {
                console.warn(`No se encontró el marcador para la parada ${paradaId}`);
            }
        }
        
        // ================== FUNCIONES DE RUTAS ==================
        
        /**
         * Dibuja una ruta entre dos paradas
         * @param {string} desdeId - ID de la parada de origen
         * @param {string} hastaId - ID de la parada de destino
         * @param {Object} opciones - Opciones para la ruta
         * @returns {L.Polyline} Línea de la ruta
         */
        function dibujarRuta(desdeId, hastaId, opciones = {}) {
            if (!estadoGlobal.mapa) {
                console.warn('No se puede dibujar la ruta: el mapa no está inicializado');
                return null;
            }
            
            // Obtener coordenadas de las paradas
            const desdeCoords = estadoGlobal.coordenadasParadas.get(desdeId);
            const hastaCoords = estadoGlobal.coordenadasParadas.get(hastaId);
            
            if (!desdeCoords || !hastaCoords) {
                console.warn('No se encontraron coordenadas para una o ambas paradas');
                return null;
            }
            
            // Opciones por defecto
            const opcionesRuta = {
                color: '#3f51b5',
                weight: 5,
                opacity: 0.8,
                dashArray: '10, 10',
                lineCap: 'round',
                ...opciones
            };
            
            // Crear la ruta
            const ruta = L.polyline([desdeCoords, hastaCoords], opcionesRuta).addTo(estadoGlobal.mapa);
            
            // Almacenar referencia a la ruta
            if (!estadoGlobal.rutas) {
                estadoGlobal.rutas = [];
            }
            estadoGlobal.rutas.push(ruta);
            
            // Ajustar la vista para mostrar toda la ruta
            const bounds = L.latLngBounds([desdeCoords, hastaCoords]);
            estadoGlobal.mapa.fitBounds(bounds, { padding: [50, 50] });
            
            return ruta;
        }
        
        /**
         * Limpia todas las rutas dibujadas en el mapa
         */
        function limpiarRutas() {
            if (!estadoGlobal.rutas || estadoGlobal.rutas.length === 0) return;
            
            estadoGlobal.rutas.forEach(ruta => {
                if (ruta && estadoGlobal.mapa.hasLayer(ruta)) {
                    estadoGlobal.mapa.removeLayer(ruta);
                }
            });
            
            estadoGlobal.rutas = [];
            console.log('✅ Rutas limpiadas');
        }
        
        /**
         * Navega a la siguiente parada desde la actual
         * @param {string} paradaActualId - ID de la parada actual
         * @returns {boolean} True si se pudo navegar a la siguiente parada
         */
        function navegarSiguienteParada(paradaActualId) {
            if (!paradaActualId || !estadoGlobal.coordenadasParadas.has(paradaActualId)) {
                console.warn('ID de parada actual no válido');
                return false;
            }
            
            // Obtener el índice de la parada actual
            const indiceActual = AVENTURA_PARADAS.findIndex(p => p.parada_id === paradaActualId);
            if (indiceActual === -1 || indiceActual >= AVENTURA_PARADAS.length - 1) {
                console.warn('No hay más paradas disponibles');
                return false;
            }
            
            // Obtener la siguiente parada
            const siguienteParada = AVENTURA_PARADAS[indiceActual + 1];
            if (!siguienteParada || !estadoGlobal.coordenadasParadas.has(siguienteParada.parada_id)) {
                console.warn('No se pudo encontrar la siguiente parada');
                return false;
            }
            
            // Limpiar rutas anteriores
            limpiarRutas();
            
            // Dibujar la ruta
            dibujarRuta(paradaActualId, siguienteParada.parada_id, {
                color: '#ff9800',
                weight: 6,
                dashArray: '15, 10',
                className: 'ruta-activa'
            });
            
            // Centrar en la siguiente parada
            centrarEnParada(siguienteParada.parada_id);
            
            console.log(`🚀 Navegando a la siguiente parada: ${siguienteParada.parada_id}`);
            return true;
        }
        
        // ================== MANEJADORES DE EVENTOS ==================
        
        /**
         * Inicializa los manejadores de eventos del mapa
         */
        function inicializarManejadoresEventos() {
            if (!estadoGlobal.mapa) return;
            
            // Manejador para clics en el botón de navegación en los popups
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('btn-navegar')) {
                    const paradaId = e.target.dataset.parada;
                    if (paradaId) {
                        centrarEnParada(paradaId);
                        
                        // Desplazar suavemente al mapa
                        const mapaElement = document.getElementById('mapa');
                        if (mapaElement) {
                            mapaElement.scrollIntoView({ behavior: 'smooth' });
                        }
                    }
                }
            });
            
            // Manejador para el evento de cambio de tamaño de ventana
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (estadoGlobal.mapa) {
                        estadoGlobal.mapa.invalidateSize({ animate: true });
                    }
                }, 250);
            });
            
            console.log('✅ Manejadores de eventos inicializados');
        }
        
        // ================== GESTIÓN DE HIJOS ==================
        
        /**
         * Inicializa el monitoreo de los componentes hijos
         */
        /**
         * Inicializa el monitoreo periódico de los componentes hijos
         * @returns {number} ID del intervalo para poder limpiarlo después
         */
        function inicializarMonitoreoHijos() {
            console.log('🔍 Iniciando monitoreo de componentes hijos...');
            
            // Limpiar intervalo existente si lo hay
            if (estadoGlobal.intervaloMonitoreo) {
                clearInterval(estadoGlobal.intervaloMonitoreo);
            }
            
            // Configurar el monitoreo periódico
            return setInterval(verificarEstadoHijos, 
                estadoGlobal.configuracion.intervaloMonitoreo);
                
            // Configurar un temporizador para detectar hijos que no responden
            setTimeout(() => {
                const hijosInactivos = HIJOS_SISTEMA.filter(hijo => 
                    !estadoGlobal.hijosListos.has(hijo.id) && hijo.requerido
                );
                
                if (hijosInactivos.length > 0) {
                    console.warn('⚠️ Algunos componentes hijos no respondieron a tiempo:', 
                        hijosInactivos.map(h => h.id).join(', '));
                    
                    // Intentar reconexión con los hijos inactivos
                    hijosInactivos.forEach(hijo => {
                        const reintentos = estadoGlobal.hijosConectados.get(hijo.id)?.reintentos || 0;
                        if (reintentos < estadoGlobal.configuracion.maxReintentosConexion) {
                            console.log(`🔄 Intentando reconectar con ${hijo.id} (intento ${reintentos + 1})`);
                            enviarMensajeHijo(hijo.id, TIPOS_MENSAJE.SISTEMA.INICIALIZACION, {});
                            
                            // Actualizar contador de reintentos
                            estadoGlobal.hijosConectados.set(hijo.id, { 
                                ...(estadoGlobal.hijosConectados.get(hijo.id) || {}),
                                reintentos: reintentos + 1,
                                ultimoIntento: Date.now()
                            });
                        } else {
                            console.error(`❌ Se agotaron los intentos de conexión con ${hijo.id}`);
                            // Aquí podrías notificar al usuario o tomar otra acción
                        }
                    });
                }
            }, estadoGlobal.configuracion.tiempoEsperaHijos);
            
            console.log('✅ Monitoreo de componentes hijos iniciado');
        }
        
        /**
         * Verifica el estado de los componentes hijos
         */
        function verificarEstadoHijos() {
            const ahora = Date.now();
            const umbralInactividad = 60000; // 1 minuto sin actividad
            
            HIJOS_SISTEMA.forEach(hijo => {
                const ultimoMensaje = estadoGlobal.ultimoMensajeRecibido.get(hijo.id);
                const tiempoInactivo = ultimoMensaje ? ahora - ultimoMensaje : Infinity;
                
                if (tiempoInactivo > umbralInactividad) {
                    console.warn(`⚠️ El componente ${hijo.id} no ha enviado mensajes en ${Math.floor(tiempoInactivo/1000)} segundos`);
                    
                    // Intentar reconexión si es un componente requerido
                    if (hijo.requerido) {
                        const estadoConexion = estadoGlobal.hijosConectados.get(hijo.id) || { reintentos: 0 };
                        if (estadoConexion.reintentos < estadoGlobal.configuracion.maxReintentosConexion) {
                            console.log(`🔄 Enviando ping a ${hijo.id}`);
                            enviarMensajeHijo(hijo.id, TIPOS_MENSAJE.SISTEMA.INICIALIZACION, {});
                        }
                    }
                }
            });
            
            // Actualizar la hora de la última verificación
            estadoGlobal.ultimaVerificacionHijos = ahora;
        }
        
        /**
         * Envía un mensaje a un componente hijo
         * @param {string} hijoId - ID del componente hijo
         * @param {string} tipo - Tipo de mensaje
         * @param {Object} datos - Datos del mensaje
         * @returns {Promise} Promesa que se resuelve cuando se envía el mensaje
         */
        /**
         * Envía un mensaje a un componente hijo con timeout
         * @param {string} hijoId - ID del componente hijo
         * @param {string} tipo - Tipo de mensaje
         * @param {Object} [datos={}] - Datos del mensaje
         * @returns {Promise<Object>} Respuesta del hijo
         * @throws {Error} Si el mensaje falla o se excede el tiempo de espera
         */
        function enviarMensajeHijo(hijoId, tipo, datos = {}) {
            if (!hijoId || !tipo) {
                return Promise.reject(new Error('ID de hijo y tipo son requeridos'));
            }
            
            return new Promise((resolve, reject) => {
                // Configurar timeout
                const timeoutId = setTimeout(() => {
                    reject(new Error(`Timeout al enviar mensaje a ${hijoId}`));
                }, ERROR_TIMEOUT);
                
                try {
                try {
                    // Limpiar el timeout cuando se resuelva
                    const limpiar = () => clearTimeout(timeoutId);
                    
                    // Verificar si el hijo está en la lista de conocidos
                    const hijo = HIJOS_SISTEMA.find(h => h.id === hijoId);
                    
                    // Configurar manejo de resolución/rechazo con limpieza
                    const resolver = (respuesta) => {
                        limpiar();
                        resolve(respuesta);
                    };
                    
                    const rechazador = (error) => {
                        limpiar();
                        reject(error);
                    };
                    if (!hijo) {
                        throw new Error(`Componente hijo desconocido: ${hijoId}`);
                    }
                    
                    // Verificar si el mensaje es compatible con el tipo de hijo
                    if (!esMensajeCompatible(hijo, tipo)) {
                        console.warn(`⚠️ El componente ${hijoId} no está configurado para manejar mensajes de tipo ${tipo}`);
                    }
                    
                    // Enviar el mensaje a través del sistema de mensajería
                    Mensajeria.enviarMensaje(hijoId, tipo, datos)
                        .then(() => {
                            // Actualizar el estado de conexión del hijo
                            estadoGlobal.hijosConectados.set(hijoId, {
                                ...(estadoGlobal.hijosConectados.get(hijoId) || {}),
                                ultimoMensajeEnviado: Date.now(),
                                conectado: true,
                                ultimoError: null
                            });
                            resolve();
                        })
                        .catch(error => {
                            console.error(`❌ Error al enviar mensaje a ${hijoId}:`, error);
                            
                            // Actualizar el estado de error
                            estadoGlobal.hijosConectados.set(hijoId, {
                                ...(estadoGlobal.hijosConectados.get(hijoId) || {}),
                                conectado: false,
                                ultimoError: error.message,
                                ultimoIntento: Date.now()
                            });
                            
                            reject(error);
                        });
                        
                } catch (error) {
                    console.error(`Error al enviar mensaje a ${hijoId}:`, error);
                    reject(error);
                }
            });
        }
        
        /**
         * Verifica si un mensaje es compatible con un tipo de hijo
         * @param {Object} hijo - Configuración del hijo
         * @param {string} tipoMensaje - Tipo de mensaje a verificar
         * @returns {boolean} True si el mensaje es compatible
         */
        function esMensajeCompatible(hijo, tipoMensaje) {
            // Si el hijo no tiene un tipo definido, se asume que maneja todos los mensajes
            if (!hijo.tipo) return true;
            
            // Obtener los tipos de mensaje que el hijo debería manejar
            const tiposMensajeHijo = MENSAJES_POR_TIPO[hijo.tipo] || [];
            
            // Verificar si el tipo de mensaje está en la lista de mensajes que el hijo maneja
            return tiposMensajeHijo.includes(tipoMensaje);
        }
        
            // Verificar si el tipo de mensaje está en la lista de mensajes que el hijo maneja
            return tiposMensajeHijo.some(tipo => tipo === tipoMensaje);
        }
        
        /**
         * Maneja la notificación de que un hijo está listo
         * @param {Object} mensaje - Mensaje recibido
         * @returns {Object} Respuesta de confirmación
         */
        function manejarHijoListo(mensaje) {
            const { origen, datos = {} } = mensaje;
            const timestamp = Date.now();
            
            try {
                // Validación de entrada
                if (!origen) {
                    throw new Error('Mensaje sin origen');
                }
                
                console.log(`✅ Hijo listo: ${origen}`, {
                    version: datos.version,
                    capacidades: datos.capacidades ? datos.capacidades.length : 0,
                    metadata: datos.metadata || {}
                });
                
                // Registrar métricas
                estadoGlobal.metricas.mensajesRecibidos++;
                
                // Actualizar estado del hijo
                const estadoHijo = {
                    id: origen,
                    conectado: true,
                    ultimaConexion: timestamp,
                    ultimaSincronizacion: timestamp,
                    reintentos: 0,
                    version: datos.version || 'desconocida',
                    capacidades: Array.isArray(datos.capacidades) ? datos.capacidades : [],
                    metadata: datos.metadata || {},
                    estado: 'conectado',
                    errores: [],
                    metricas: {
                        mensajesEnviados: 0,
                        mensajesRecibidos: 1,
                        ultimaActividad: timestamp
                    }
                };
                
                // Mantener datos existentes si los hay
                const estadoAnterior = estadoGlobal.hijosConectados.get(origen) || {};
                estadoGlobal.hijosConectados.set(origen, { ...estadoAnterior, ...estadoHijo });
                
                // Notificar a otros componentes
                broadcastMensaje({
                    tipo: 'sistema:hijo_listo',
                    origen: 'sistema',
                    destino: 'todos',
                    datos: { 
                        componente: origen,
                        version: estadoHijo.version,
                        timestamp,
                        // Solo incluir metadatos públicos
                        metadata: {
                            capacidades: estadoHijo.capacidades,
                            conectado: true
                        }
                    }
                }, [origen]); // Excluir al remitente
                
                // Sincronizar estado con el nuevo hijo
                sincronizarEstadoConHijo(origen);
                
                // Respuesta de confirmación
                return {
                    exito: true,
                    mensaje: 'Registro exitoso',
                    timestamp,
                    estado: {
                        modo: estadoGlobal.modo,
                        gpsActivo: estadoGlobal.gpsActivo,
                        paradaActual: estadoGlobal.paradaActual,
                        tramoActual: estadoGlobal.tramoActual,
                        version: estadoGlobal.version,
                        timestamp
                    },
                    config: {
                        debug: estadoGlobal.config.debug,
                        maxReintentos: estadoGlobal.config.maxReintentos,
                        tiempoEspera: estadoGlobal.config.tiempoEsperaInicial
                    }
                };
                
            } catch (error) {
                console.error(`❌ Error al procesar notificación de hijo listo (${origen}):`, error);
                
                // Registrar error
                if (origen) {
                    const estadoHijo = estadoGlobal.hijosConectados.get(origen) || {
                        id: origen,
                        errores: [],
                        estado: 'error',
                        ultimoError: {
                            tipo: 'registro',
                            mensaje: error.message,
                            codigo: 'ERROR_REGISTRO',
                            timestamp: new Date().toISOString(),
                            stack: error.stack
                        }
                    };
                    
                    estadoHijo.errores = estadoHijo.errores || [];
                    estadoHijo.errores.push({
                        tipo: 'registro',
                        mensaje: error.message,
                        codigo: 'ERROR_REGISTRO',
                        timestamp: new Date().toISOString(),
                        stack: error.stack,
                        datos: datos || {}
                    });
                    
                    estadoGlobal.hijosConectados.set(origen, estadoHijo);
                }
                
                // Devolver error detallado
                return {
                    exito: false,
                    error: {
                        mensaje: error.message || 'Error desconocido',
                        codigo: 'ERROR_REGISTRO',
                        detalle: error.stack ? error.stack.split('\n')[0] : undefined
                    },
                    timestamp: Date.now(),
                    intentarNuevamente: true,
                    tiempoEspera: 5000 // 5 segundos
                };
            }
        }
        
        /**
         * Sincroniza el estado actual con un hijo específico
         * @param {string} hijoId - ID del componente hijo
         */
        function sincronizarEstadoConHijo(hijoId) {
            const mensaje = {
                tipo: TIPOS_MENSAJE.SISTEMA.SINCRONIZAR_ESTADO,
                datos: {
                    modo: estadoGlobal.modo,
                    paradaActual: estadoGlobal.paradaActual,
                    tramoActual: estadoGlobal.tramoActual,
                    gpsActivo: estadoGlobal.gpsActivo,
                    audioReproduciendo: estadoGlobal.audioReproduciendo,
                    retoActivo: estadoGlobal.retoActivo,
                    timestamp: Date.now()
                }
            };
            
            enviarMensajeHijo(hijoId, mensaje.tipo, mensaje.datos)
                .then(() => console.log(`✅ Estado sincronizado con ${hijoId}`))
                .catch(error => console.error(`❌ Error al sincronizar estado con ${hijoId}:`, error));
        }
        
        // ================== MAPA ==================
        /**
         * Inicializa el mapa de Leaflet
         * @returns {Promise<L.Map>} Instancia del mapa de Leaflet
         */
        /**
         * Inicializa el mapa Leaflet
         * @returns {Promise<L.Map>} Instancia del mapa
         * @throws {Error} Si no se puede cargar Leaflet o inicializar el mapa
         */
        async function inicializarMapa() {
            return new Promise((resolve, reject) => {
                try {
                    // Verificar si el contenedor del mapa existe
                    const mapaContainer = document.getElementById('mapa');
                    if (!mapaContainer) {
                        throw new Error('No se encontró el contenedor del mapa');
                    }
                    
                    // Verificar si Leaflet está cargado
                    if (typeof L === 'undefined') {
                        throw new Error('La biblioteca Leaflet no está cargada correctamente');
                    }
                    console.log('🌍 Iniciando inicialización del mapa...');
                    
                    // Coordenadas por defecto (centro de Valencia)
                    const valenciaCoords = [39.44859, -0.37489];
                    const mapContainer = document.getElementById('mapa');
                    
                    if (!mapContainer) {
                        throw new Error('No se encontró el contenedor del mapa');
                    }
                    
                    // Asegurarse de que el contenedor del mapa sea visible
                    mapContainer.style.display = 'block';
                    mapContainer.style.width = '100%';
                    mapContainer.style.height = '100%';
                    
                    // Crear instancia del mapa
                    const mapa = L.map('mapa', {
                        center: valenciaCoords,
                        zoom: 14,
                        zoomControl: false,
                        scrollWheelZoom: true,
                        doubleClickZoom: true,
                        boxZoom: true,
                        rotate: false,
                        touchRotate: false,
                        bearing: 0,
                        preferCanvas: true,
                        tap: false // Desactivar tap para evitar conflictos con dispositivos táctiles
                    });
                    
                    // Añadir capa base de OpenStreetMap
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19,
                        attribution: '© OpenStreetMap contributors',
                        detectRetina: true
                    }).addTo(mapa);
                    
                    // Añadir control de zoom personalizado
                    L.control.zoom({
                        position: 'topright'
                    }).addTo(mapa);
                    
                    // Inicializar el estado global del mapa
                    estadoGlobal.mapa = mapa;
                    
                    // Manejar la carga del mapa
                    mapa.whenReady(async () => {
                        console.log('✅ Mapa cargado correctamente');
                        
                        // Forzar un redimensionamiento para asegurar que el mapa se renderice correctamente
                        setTimeout(() => {
                            mapa.invalidateSize({ animate: true });
                            
                            try {
                                // Inicializar coordenadas y crear marcadores
                                if (typeof inicializarCoordenadasParadas === 'function') {
                                    // Esperar a que se carguen las coordenadas antes de crear los marcadores
                                    inicializarCoordenadasParadas()
                                        .then(() => {
                                            if (typeof crearMarcadoresIniciales === 'function') {
                                                crearMarcadoresIniciales();
                                            }
                                            resolve(mapa);
                                        })
                                        .catch(error => {
                                            console.error('Error al inicializar coordenadas:', error);
                                            reject(error);
                                        });
                                } else {
                                    resolve(mapa);
                                }
                            } catch (error) {
                                console.error('Error durante la inicialización del mapa:', error);
                                reject(error);
                            }
                            
                        }, 100);
                    });
                    
                    // Manejar errores del mapa
                    mapa.on('error', (error) => {
                        const errorMsg = 'Error en el mapa: ' + (error.message || 'Error desconocido');
                        console.error('❌', errorMsg, error);
                        
                        if (typeof mostrarErrorEnInterfaz === 'function') {
                            mostrarErrorEnInterfaz(errorMsg);
                        }
                        
                        reject(new Error(errorMsg));
                    });
                    
                } catch (error) {
                    console.error('❌ Error al inicializar el mapa:', error);
                    const errorMsg = 'Error al cargar el mapa: ' + (error.message || 'Error desconocido');
                    
                    if (typeof mostrarErrorEnInterfaz === 'function') {
                        mostrarErrorEnInterfaz(errorMsg, () => {
                            try {
                                return inicializarMapa();
                            } catch (retryError) {
                                console.error('Error al reintentar la inicialización del mapa:', retryError);
                                return null;
                            }
                        });
                    }
                    
                    reject(new Error(errorMsg));
                }
            });
        }
        
        // ================== GESTIÓN DE HIJOS ==================
        
        /**
         * Inicializa un iframe hijo existente
         * @param {Object} hijo - Configuración del hijo
         */
        function inicializarIframeHijo(hijo) {
            const iframe = document.getElementById(hijo.id);
            if (!iframe) {
                console.error(`❌ No se encontró el iframe con ID: ${hijo.id}`);
                if (hijo.requerido) {
                    mostrarErrorEnInterfaz(`No se encontró el componente requerido: ${hijo.id}`);
                }
                return;
            }
            
            // Configuración de atributos para seguridad
            iframe.setAttribute('sandbox', 'allow-same-origin allow-scripts allow-popups allow-forms');
            iframe.setAttribute('allow', 'geolocation; microphone; camera');
            
            // Manejar errores de carga
            iframe.onerror = (error) => {
                console.error(`❌ Error al cargar el componente ${hijo.id}:`, error);
                if (hijo.requerido) {
                    mostrarErrorEnInterfaz(`Error al cargar el componente requerido: ${hijo.id}`);
                }
            };
            
            // Manejar carga exitosa
            iframe.onload = () => {
                console.log(`✅ Componente ${hijo.id} cargado correctamente`);
                
                // Actualizar el estado del hijo
                const estadoHijo = estadoGlobal.hijosConectados.get(hijo.id) || {};
                estadoHijo.estado = 'cargado';
                estadoHijo.ultimaComunicacion = Date.now();
                estadoGlobal.hijosConectados.set(hijo.id, estadoHijo);
                
                // Notificar al componente que está listo
                const mensaje = {
                    tipo: 'sistema:inicializado',
                    origen: 'padre',
                    datos: {
                        id: hijo.id,
                        config: {
                            debug: estadoGlobal.config.debug
                        }
                    }
                };
                
                // Esperar un momento para asegurar que el iframe esté listo
                setTimeout(() => {
                    try {
                        iframe.contentWindow.postMessage(mensaje, '*');
                        console.log(`📤 Notificación de inicialización enviada a ${hijo.id}`);
                    } catch (error) {
                        console.error(`❌ Error al notificar a ${hijo.id}:`, error);
                    }
                }, 500);
            };
            
            // Inicializar el estado del hijo si no existe
            if (!estadoGlobal.hijosConectados.has(hijo.id)) {
                estadoGlobal.hijosConectados.set(hijo.id, {
                    id: hijo.id,
                    tipo: hijo.tipo,
                    iframe: iframe,
                    estado: 'inicializando',
                    ultimaComunicacion: null,
                    errores: [],
                    version: '1.0.0',
                    capacidades: []
                });
            }
        }
        
        /**
         * Inicializa todos los componentes hijos
         * @returns {Promise<void>}
         */
        async function inicializarComponentesHijos() {
            console.log('🚀 Inicializando componentes hijos...');
            
            // Configurar el manejador de mensajes para la comunicación con los hijos
            window.addEventListener('message', manejarMensajeHijo);
            
            // Inicializar cada iframe hijo
            HIJOS_SISTEMA.forEach(hijo => {
                try {
                    console.log(`📦 Inicializando componente hijo: ${hijo.id}`);
                    inicializarIframeHijo(hijo);
                } catch (error) {
                    console.error(`❌ Error al inicializar el componente ${hijo.id}:`, error);
                    if (hijo.requerido) {
                        mostrarErrorEnInterfaz(`Error al inicializar el componente requerido: ${hijo.id}`);
                    }
                }
            });
            
            // Iniciar el monitoreo de estado de los hijos
            iniciarMonitoreoHijos();
            
            // Notificar que la inicialización de los hijos ha comenzado
            console.log('✅ Inicialización de componentes hijos iniciada');
        }
        
        /**
         * Maneja los mensajes entrantes de los componentes hijos
         * @param {MessageEvent} event - Evento de mensaje
         */
        /**
         * Maneja los mensajes entrantes de los iframes hijos
         * @param {MessageEvent} event - Evento de mensaje
         */
        /**
         * Maneja los mensajes entrantes de los iframes hijos
         * @param {MessageEvent} event - Evento de mensaje
         */
        function manejarMensajeHijo(event) {
            const mensaje = event.data;
            let origen = null;
            
            try {
                // Validar el origen del mensaje para seguridad
                const origenesPermitidos = HIJOS_SISTEMA.map(h => h.url).filter(Boolean);
                if (!origenesPermitidos.includes(event.origin)) {
                    console.warn('Mensaje de origen no permitido:', event.origin);
                    return;
                }
                
                // Validar que el mensaje tenga la estructura esperada
                if (!mensaje || typeof mensaje !== 'object' || !mensaje.tipo) {
                    console.warn('Mensaje no válido recibido:', mensaje);
                    return;
                }
                
                origen = mensaje.origen;
                
                // Registrar la comunicación
                const ahora = Date.now();
                
                // Actualizar el estado del hijo
                if (origen) {
                    const estadoHijo = estadoGlobal.hijosConectados.get(origen) || {
                        id: origen,
                        tipo: 'desconocido',
                        estado: 'activo',
                        ultimaComunicacion: ahora,
                        errores: [],
                        version: mensaje.version || '1.0.0',
                        capacidades: mensaje.capacidades || []
                    };
                    
                    // Actualizar información del estado
                    estadoHijo.ultimaComunicacion = ahora;
                    estadoHijo.estado = 'activo';
                    
                    // Actualizar versión y capacidades si están presentes en el mensaje
                    if (mensaje.version) estadoHijo.version = mensaje.version;
                    if (mensaje.capacidades) estadoHijo.capacidades = mensaje.capacidades;
                    
                    estadoGlobal.hijosConectados.set(origen, estadoHijo);
                    
                    // Registrar el mensaje en el historial de comunicación
                    if (!estadoHijo.historial) estadoHijo.historial = [];
                    estadoHijo.historial.push({
                        timestamp: ahora,
                        tipo: mensaje.tipo,
                        datos: mensaje.datos
                    });
                    
                    // Mantener un límite en el historial
                    if (estadoHijo.historial.length > 50) {
                        estadoHijo.historial.shift();
                    }
                }
                
                // Registrar el mensaje recibido
                estadoGlobal.metricas.mensajesRecibidos++;
                
                // Procesar el mensaje según su tipo
                const manejador = manejadoresMensajes[mensaje.tipo];
                if (manejador && typeof manejador === 'function') {
                    console.log(`📨 [${mensaje.tipo}] de ${origen || 'origen desconocido'}:`, mensaje.datos || 'Sin datos');
                    manejador(mensaje);
                } else {
                    console.warn(`⚠️ No se encontró manejador para el tipo de mensaje: ${mensaje.tipo}`, mensaje);
                }
            } catch (error) {
                console.error('Error al procesar mensaje:', error);
                mostrarMensajeInterfaz({
                    tipo: 'error',
                    titulo: 'Error',
                    mensaje: 'Error al procesar mensaje: ' + (error.message || 'Error desconocido')
                });
                
                // Registrar el error en el estado del hijo si es posible
                if (origen) {
                    const estadoHijo = estadoGlobal.hijosConectados.get(origen) || { errores: [] };
                    estadoHijo.errores = estadoHijo.errores || [];
                    estadoHijo.errores.push({
                        timestamp: new Date().toISOString(),
                        tipo: 'procesamiento_mensaje',
                        mensaje: error.message || 'Error desconocido',
                        stack: error.stack
                    });
                    estadoGlobal.hijosConectados.set(origen, estadoHijo);
                }
            }
            
            // Registrar la comunicación
            const ahora = Date.now();
            const origen = mensaje.origen;
            
            // Actualizar el estado del hijo
            if (origen) {
                const estadoHijo = estadoGlobal.hijosConectados.get(origen) || {
                    id: origen,
                    tipo: 'desconocido',
                    estado: 'activo',
                    ultimaComunicacion: ahora,
                    errores: [],
                    version: mensaje.version || '1.0.0',
                    capacidades: mensaje.capacidades || []
                };
                
                // Actualizar información del estado
                estadoHijo.ultimaComunicacion = ahora;
                estadoHijo.estado = 'activo';
                
                // Actualizar versión y capacidades si están presentes en el mensaje
                if (mensaje.version) estadoHijo.version = mensaje.version;
                if (mensaje.capacidades) estadoHijo.capacidades = mensaje.capacidades;
                
                estadoGlobal.hijosConectados.set(origen, estadoHijo);
                
                // Registrar el mensaje en el historial de comunicación
                if (!estadoHijo.historial) estadoHijo.historial = [];
                estadoHijo.historial.push({
                    timestamp: ahora,
                    tipo: mensaje.tipo,
                    datos: mensaje.datos
                });
                
                // Mantener un límite en el historial
                if (estadoHijo.historial.length > 50) {
                    estadoHijo.historial.shift();
                }
            }
            
            // Registrar el mensaje recibido
            estadoGlobal.metricas.mensajesRecibidos++;
            
            // Procesar el mensaje según su tipo
            try {
                const manejador = manejadoresMensajes[mensaje.tipo];
                if (manejador && typeof manejador === 'function') {
                    console.log(`📨 [${mensaje.tipo}] de ${origen || 'origen desconocido'}:`, mensaje.datos || 'Sin datos');
                    manejador(mensaje);
                } else {
                    console.warn(`⚠️ No se encontró manejador para el tipo de mensaje: ${mensaje.tipo}`, mensaje);
                }
            } catch (error) {
                console.error(`❌ Error al procesar mensaje de ${origen || 'origen desconocido'}:`, error);
                
                // Registrar el error en el estado del hijo
                if (origen) {
                    const estadoHijo = estadoGlobal.hijosConectados.get(origen);
                    if (estadoHijo) {
                        estadoHijo.errores = estadoHijo.errores || [];
                        estadoHijo.errores.push({
                            timestamp: ahora,
                            tipo: 'procesamiento_mensaje',
                            mensaje: error.message,
                            stack: error.stack,
                            mensajeOriginal: mensaje
                        });
                        estadoGlobal.hijosConectados.set(origen, estadoHijo);
                    }
                }
            }
        }
        
        /**
         * Inicia el monitoreo del estado de los componentes hijos
         */
        let intervaloMonitoreo = null;
        
        /**
         * Inicia el monitoreo de los componentes hijos
         */
        function iniciarMonitoreoHijos() {
            // Limpiar intervalo existente si lo hay
            if (intervaloMonitoreo) {
                clearInterval(intervaloMonitoreo);
            }
            
            // Verificar estado de los hijos periódicamente
            estadoGlobal.intervaloMonitoreo = setInterval(() => {
                try {
                    const ahora = Date.now();
                    const umbralInactividad = INACTIVITY_THRESHOLD; // Usar constante definida
                
                estadoGlobal.hijosConectados.forEach((hijo, id) => {
                    const tiempoInactivo = ahora - (hijo.ultimaComunicacion || ahora);
                    
                    if (tiempoInactivo > umbralInactividad && hijo.estado !== 'inactivo') {
                        console.warn(`⚠️ El componente ${id} no ha respondido en ${Math.floor(tiempoInactivo / 1000)} segundos`);
                        
                        // Actualizar estado
                        hijo.estado = 'inactivo';
                        estadoGlobal.hijosConectados.set(id, hijo);
                        
                        // Notificar a la interfaz de usuario
                        mostrarNotificacion(`El componente ${id} no responde`, 'advertencia');
                    }
                });
            }, 10000); // Verificar cada 10 segundos
        }
        
        // ================== MANEJADORES DE MENSAJES ==================
        
        /**
         * Maneja la notificación de que un hijo está listo
         * @param {Object} mensaje - Mensaje recibido
         * @returns {Object} Respuesta de confirmación
         */
        function manejarHijoListo(mensaje) {
            const { origen, datos = {} } = mensaje;
            console.log(`✅ Hijo listo: ${origen}`, datos);
            
            // Actualizar el estado del hijo
            const estadoHijo = estadoGlobal.hijosConectados.get(origen);
            if (estadoHijo) {
                estadoHijo.estado = 'listo';
                estadoHijo.version = datos.version || '1.0.0';
                estadoHijo.capacidades = datos.capacidades || [];
                estadoGlobal.hijosConectados.set(origen, estadoHijo);
                
                // Notificar a la interfaz de usuario
                mostrarNotificacion(`Componente ${origen} listo`, 'éxito');
            }
        }
        
        /**
         * Maneja los errores reportados por los hijos
         * @param {Object} mensaje - Mensaje de error
         */
        function manejarErrorDeHijo(mensaje) {
            const { origen, datos = {} } = mensaje;
            console.error(`❌ Error en ${origen}:`, datos);
            
            // Registrar el error
            if (origen) {
                const estadoHijo = estadoGlobal.hijosConectados.get(origen);
                if (estadoHijo) {
                    estadoHijo.errores = estadoHijo.errores || [];
                    estadoHijo.errores.push({
                        codigo: datos.codigo,
                        mensaje: datos.mensaje,
                        timestamp: Date.now(),
                        stack: datos.stack
                    });
                    estadoGlobal.hijosConectados.set(origen, estadoHijo);
                }
            }
            
            // Mostrar notificación al usuario
            mostrarNotificacion(`Error en ${origen}: ${datos.mensaje || 'Error desconocido'}`, 'error');
        }
        
        /**
         * Maneja las confirmaciones de los hijos
         * @param {Object} mensaje - Mensaje de confirmación
         */
        function manejarConfirmacion(mensaje) {
            const { origen, datos = {} } = mensaje;
            console.log(`✅ Confirmación de ${origen}:`, datos);
            
            // Aquí podrías implementar lógica adicional basada en la confirmación
            // Por ejemplo, actualizar la interfaz de usuario o el estado de la aplicación
        }
        
        /**
         * Maneja las actualizaciones de estado de los hijos
         * @param {Object} mensaje - Mensaje de estado
         */
        function manejarEstadoHijo(mensaje) {
            const { origen, datos = {} } = mensaje;
            
            if (origen) {
                const estadoHijo = estadoGlobal.hijosConectados.get(origen);
                if (estadoHijo) {
                    // Actualizar el estado del hijo con los nuevos datos
                    Object.assign(estadoHijo, datos);
                    estadoHijo.ultimaActualizacion = Date.now();
                    estadoGlobal.hijosConectados.set(origen, estadoHijo);
                }
            }
        }
        
        // Mapa de manejadores de mensajes
        const manejadoresMensajes = {
            // Mensajes del sistema
            'sistema:listo': manejarHijoListo,
            'sistema:error': manejarErrorDeHijo,
            'sistema:confirmacion': manejarConfirmacion,
            'sistema:estado': manejarEstadoHijo,
            
            // Mensajes de audio
            'audio:reproducir': manejarReproducirAudio,
            'audio:pausar': manejarPausarAudio,
            'audio:detener': manejarDetenerAudio,
            'audio:estado': manejarEstadoAudio,
            
            // Mensajes de navegación
            'navegacion:parada': manejarCambioParada,
            'navegacion:tramo': manejarCambioTramo,
            'navegacion:estado': manejarEstadoNavegacion,
            
            // Mensajes de retos
            'reto:iniciar': manejarIniciarReto,
            'reto:completar': manejarCompletarReto,
            'reto:fallar': manejarFallarReto,
            'reto:estado': manejarEstadoReto,
            
            // Mensajes de interfaz de usuario
            'ui:notificacion': manejarNotificacionUI,
            'ui:dialogo': manejarDialogoUI
        };
        
        // ================== FUNCIONES AUXILIARES ==================
        
        /**
         * Muestra un mensaje de error en la interfaz de usuario
         * @param {string} mensaje - Mensaje de error
         * @param {Function} [onRetry] - Función a ejecutar al reintentar
         */
        function mostrarErrorEnInterfaz(mensaje, onRetry) {
            console.error('❌ ' + mensaje);
            // Aquí podrías implementar la lógica para mostrar el error en la UI
            // Por ejemplo, mostrando un modal o un mensaje flotante
            
            // Ejemplo básico de notificación
            const notificacion = document.createElement('div');
            notificacion.className = 'notificacion-error';
            notificacion.textContent = mensaje;
            
            if (onRetry) {
                const botonReintentar = document.createElement('button');
                botonReintentar.textContent = 'Reintentar';
                botonReintentar.onclick = () => {
                    notificacion.remove();
                    onRetry();
                };
                notificacion.appendChild(botonReintentar);
            }
            
            document.body.appendChild(notificacion);
            
            // Eliminar la notificación después de 5 segundos
            setTimeout(() => {
                if (notificacion.parentNode) {
                    notificacion.remove();
                }
            }, 5000);
        }
        
        /**
         * Muestra una notificación en la interfaz de usuario
         * @param {string} mensaje - Mensaje a mostrar
         * @param {string} tipo - Tipo de notificación (éxito, error, advertencia, info)
         */
        function mostrarNotificacion(mensaje, tipo = 'info') {
            console.log(`📢 [${tipo.toUpperCase()}] ${mensaje}`);
            // Implementar lógica para mostrar notificaciones en la UI
        }
        
        // ================== INICIALIZACIÓN ==================
        
        /**
         * Función principal de inicialización
         */
        /**
         * Inicializa la aplicación
         * @returns {Promise<void>}
         */
        async function inicializar() {
            try {
                console.log('🚀 Inicializando sistema padre...');
                
                // Registrar manejador de errores global
                window.onerror = function(mensaje, fuente, linea, columna, error) {
                    console.error('Error no capturado:', { mensaje, fuente, linea, columna, error });
                    mostrarMensajeInterfaz({
                        tipo: 'error',
                        titulo: 'Error en la aplicación',
                        mensaje: 'Se ha producido un error inesperado. Por favor, recarga la página.'
                    });
                    return true; // Evita que el error se propague
                };
                
                // 1. Inicializar elementos del DOM
                initDOMElements();
                initEventListeners();
                
                // 2. Inicializar el mapa
                console.log('🌍 Inicializando mapa...');
                try {
                    estadoGlobal.mapa = await inicializarMapa();
                    console.log('✅ Mapa inicializado correctamente');
                } catch (error) {
                    console.error('❌ Error al inicializar el mapa:', error);
                    mostrarErrorEnInterfaz('Error al cargar el mapa. Por favor, recarga la página.');
                    return;
                }
                
                // 2. Inicializar componentes hijos
                console.log('👶 Inicializando componentes hijos...');
                await inicializarComponentesHijos();
                
                // 3. Configurar manejadores de eventos
                console.log('🔧 Configurando manejadores de eventos...');
                inicializarManejadoresEventos();
                
                // 4. Iniciar monitoreo del sistema
                console.log('🔍 Iniciando monitoreo del sistema...');
                iniciarMonitoreoSistema();
                
                // 5. Notificar que la inicialización ha finalizado
                console.log('✅ Sistema padre inicializado correctamente');
                
                // Ocultar indicador de carga
                const loadingEl = document.querySelector('.loading');
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                }
                
                // Notificar a los hijos que el sistema está listo
                broadcastMensaje({
                    tipo: 'sistema:inicializacion_completada',
                    origen: 'padre',
                    datos: {
                        timestamp: Date.now(),
                        version: estadoGlobal.version
                    }
                });
                
            } catch (error) {
                console.error('❌ Error durante la inicialización del sistema:', error);
                mostrarErrorEnInterfaz(
                    'Error al iniciar la aplicación. Por favor, recarga la página.",
                    () => window.location.reload()
                );
                
                // Mostrar error en la consola para depuración
                console.error('Stack trace del error:', error.stack);
                
                // Asegurarse de que el indicador de carga se oculte en caso de error
                const loadingEl = document.querySelector('.loading');
                if (loadingEl) {
                    loadingEl.textContent = 'Error al cargar la aplicación. Por favor, recarga la página.';
                    loadingEl.style.backgroundColor = '#f44336';
                }
            }
                
                // Inicializar el estado global (ya está definido al inicio del módulo)
                estadoGlobal.modo = 'inactivo';
                estadoGlobal.ultimaActualizacion = Date.now();
                estadoGlobal.intentosReconexion = 0;
                estadoGlobal.maxIntentosReconexion = MAX_RETRY_ATTEMPTS;
                estadoGlobal.gpsActivo = false;
                estadoGlobal.paradaActual = 'P-0';
                estadoGlobal.tramoActual = 'TR-1';
                estadoGlobal.hijosListos = new Set();
                estadoGlobal.hijosConectados = new Map();
                estadoGlobal.ultimoMensajeRecibido = new Map();
                estadoGlobal.mapa = null;
                estadoGlobal.audioReproduciendo = false;
                estadoGlobal.retoActivo = null;
                estadoGlobal.inicializado = false;
                estadoGlobal.marcadoresParadas = new Map();
                estadoGlobal.marcadoresUsuario = new Map();
                estadoGlobal.rutasActivas = new Map();
                estadoGlobal.errores = [];
                estadoGlobal.ultimaSincronizacion = null;
                estadoGlobal.configuracion = {
                    tiempoEsperaHijos: 10000,
                    intervaloMonitoreo: 30000,
                    maxReintentosConexion: 3
                };
                
                // 1. Inicializar el mapa
                console.log('🌍 Inicializando mapa...');
                estadoGlobal.mapa = await inicializarMapa();
                
                if (!estadoGlobal.mapa) {
                    throw new Error('No se pudo inicializar el mapa');
                }
                
                // Notificar a los hijos que el mapa está listo
                broadcastMensaje({
                    tipo: 'sistema:mapa_listo',
                    datos: {
                        mensaje: 'El mapa se ha inicializado correctamente',
                        timestamp: Date.now()
                    }
                });
                
                // 4. Inicializar manejadores de eventos
                console.log('🖱️ Inicializando manejadores de eventos...');
                inicializarManejadoresEventos();
                
                // 5. Inicializar la mensajería
                console.log('📡 Inicializando sistema de mensajería...');
                await inicializarMensajeria();
                
                // 6. Registrar manejadores de mensajes
                console.log('📩 Registrando manejadores de mensajes...');
                registrarManejadores();
                
                // 7. Inicializar monitoreo de componentes hijos
                console.log('👥 Inicializando monitoreo de componentes hijos...');
                inicializarMonitoreoHijos();
                
                // 8. Inicializar componentes hijos
                console.log('🔄 Inicializando componentes hijos...');
                await inicializarComponentesHijos();
                
                // 9. Centrar en la primera parada
                const primeraParada = AVENTURA_PARADAS.find(p => p.tipo === 'inicio');
                if (primeraParada) {
                    centrarEnParada(primeraParada.parada_id, 16);
                }
                
                // 10. Marcar como inicializado
                estadoGlobal.inicializado = true;
                estadoGlobal.ultimaSincronizacion = new Date().toISOString();
                
                console.log('✅ Sistema padre inicializado correctamente');
                
                // Notificar a los hijos que el sistema está listo
                broadcastMensaje({
                    tipo: TIPOS_MENSAJE.SISTEMA.INICIALIZACION,
                    datos: {
                        estado: 'listo',
                        timestamp: Date.now(),
                        version: '1.0.0'
                    }
                });
                
            } catch (error) {
                console.error('❌ Error al inicializar el sistema padre:', error);
                mostrarErrorEnInterfaz(
                    'Error al inicializar la aplicación: ' + (error.message || 'Error desconocido'),
                    () => {
                        // Intentar reiniciar la inicialización
                        setTimeout(inicializar, 1000);
                    }
                );
            }
        }
        
        /**
         * Inicializa los componentes hijos de forma secuencial con reintentos
         */
        async function inicializarComponentesHijos() {
            console.log('🚀 Inicializando componentes hijos...');
            
            // Inicializar cada componente hijo con manejo de errores robusto
            for (const hijo of HIJOS_SISTEMA) {
                try {
                    console.log(`🔄 Inicializando ${hijo.id}...`);
                    
                    // Configurar el estado inicial del hijo
                    estadoGlobal.hijosConectados.set(hijo.id, {
                        conectado: false,
                        ultimoIntento: Date.now(),
                        reintentos: 0,
                        version: 'desconocida',
                        capacidades: [],
                        errores: []
                    });
                    
                    // Intentar inicializar con reintentos
                    await intentarInicializarHijo(hijo);
                    
                } catch (error) {
                    console.error(`❌ Error crítico al inicializar ${hijo.id}:`, error);
                    // Registrar el error pero continuar con los demás componentes
                    const estadoHijo = estadoGlobal.hijosConectados.get(hijo.id) || {};
                    estadoHijo.errores = estadoHijo.errores || [];
                    estadoHijo.errores.push({
                        tipo: 'inicializacion',
                        mensaje: error.message,
                        timestamp: new Date().toISOString()
                    });
                    estadoGlobal.hijosConectados.set(hijo.id, estadoHijo);
                }
            }
            
            console.log('✅ Proceso de inicialización de componentes hijos completado');
            
            // Verificar estado de inicialización
            const hijosFallidos = Array.from(estadoGlobal.hijosConectados.entries())
                .filter(([_, estado]) => !estado.conectado)
                .map(([id]) => id);
                
            if (hijosFallidos.length > 0) {
                console.warn(`⚠️ Algunos componentes no se inicializaron correctamente: ${hijosFallidos.join(', ')}`);
            }
            
            return {
                exitoso: true,
                total: HIJOS_SISTEMA.length,
                exitosos: HIJOS_SISTEMA.length - hijosFallidos.length,
                fallidos: hijosFallidos.length,
                idsFallidos: hijosFallidos
            };
            
            /**
             * Intenta inicializar un componente hijo con reintentos
             */
            async function intentarInicializarHijo(hijo, intento = 1) {
                const maxReintentos = 3;
                const tiempoEspera = 1000 * intento; // Espera creciente
                
                try {
                    // Enviar mensaje de inicialización al hijo
                    await enviarMensajeHijo(hijo.id, 'sistema:inicializacion', {
                        configuracion: {
                            modo: estadoGlobal.modo,
                            version: '1.0.0',
                            timestamp: Date.now(),
                            maxReintentos,
                            tiempoEspera: 5000 // Tiempo de espera para la respuesta
                        }
                    });
                    
                    console.log(`✅ Mensaje de inicialización enviado a ${hijo.id}`);
                    
                    // Actualizar estado del hijo
                    const estadoHijo = estadoGlobal.hijosConectados.get(hijo.id);
                    estadoHijo.ultimoIntento = Date.now();
                    estadoHijo.reintentos = intento;
                    estadoGlobal.hijosConectados.set(hijo.id, estadoHijo);
                    
                } catch (error) {
                    if (intento < maxReintentos) {
                        console.warn(`⚠️ Reintentando (${intento}/${maxReintentos}) inicialización de ${hijo.id}...`);
                        await new Promise(resolve => setTimeout(resolve, tiempoEspera));
                        return intentarInicializarHijo(hijo, intento + 1);
                    }
                    
                    // Si llegamos aquí, agotamos los reintentos
                    throw new Error(`No se pudo inicializar ${hijo.id} después de ${maxReintentos} intentos: ${error.message}`);
                }
            }
        }

        // ================== MANEJADORES DE MENSAJES MEJORADOS ==================
        const manejadoresMensajes = {
            // Sistema
            'sistema:listo': manejarHijoListo,
            'sistema:error': manejarErrorDeHijo,
            'sistema:confirmacion': manejarConfirmacion,
            'sistema:ping': manejarPing,
            
            // Datos
            'datos:solicitar_parada': manejarSolicitudDatos,
            'datos:solicitar_estado': manejarSolicitudEstado,
            'datos:actualizar': manejarActualizacionDatos,
            
            // Navegación
            'navegacion:cambio_parada': manejarCambioParada,
            'navegacion:llegada_detectada': manejarLlegadaDestino,
            'navegacion:solicitar_destino': manejarSolicitudDestino,
            'navegacion:actualizar_posicion': manejarActualizacionPosicion,
            
            // Audio
            'audio:finalizado': manejarAudioFinalizado,
            'audio:estado': manejarEstadoAudio,
            'audio:error': manejarErrorAudio,
            
            // Retos
            'retos:completado': manejarRetoCompletado,
            'retos:abrir': manejarAbrirReto,
            'retos:estado': manejarEstadoReto,
            
            // GPS
            'gps:estado': manejarEstadoGPS,
            'gps:posicion': manejarPosicionGPS,
            
            // Mensajes específicos de componentes
            'hijo5:notificar_punto': manejarNotificacionPunto,
            'hijo5:actualizar_estado': manejarActualizacionEstadoHijo
        };

        /**
         * Registra todos los manejadores de mensajes
         */
        function registrarManejadores() {
            try {
                console.log('📝 Registrando manejadores de mensajes...');
                
                // Registrar todos los manejadores definidos
                Object.entries(manejadoresMensajes).forEach(([tipo, manejador]) => {
                    if (typeof manejador === 'function') {
                        Mensajeria.registrarControlador(tipo, manejador);
                    } else {
                        console.warn(`⚠️ Manejador no encontrado para el tipo: ${tipo}`);
                    }
                });

                console.log(`✅ ${Object.keys(manejadoresMensajes).length} manejadores registrados correctamente`);
                return true;
                
            } catch (error) {
                console.error('❌ Error al registrar manejadores:', error);
                throw error; // Relanzar para manejo de errores superior
            }
        }

        // ================== FUNCIONES PRINCIPALES ==================
        
        /**
         * Obtiene los datos de una parada por su ID
         * @param {string} paradaId - ID de la parada
         * @returns {Object|null} Datos de la parada o null si no se encuentra
         */
        function obtenerDatosParada(paradaId) {
            try {
                console.log(`📍 Obteniendo datos para parada: ${paradaId}`);
                
                // Buscar la parada en el array AVENTURA_PARADAS
                const parada = AVENTURA_PARADAS.find(p => p.parada_id === paradaId);
                
                if (!parada) {
                    console.warn(`No se encontró la parada ${paradaId}`);
                    return null;
                }
                
                // Obtener coordenadas de la parada
                let coordenadas = null;
                if (COORDENADAS_PARADAS && COORDENADAS_PARADAS.get) {
                    coordenadas = COORDENADAS_PARADAS.get(paradaId);
                }
                
                // Construir objeto de datos de la parada
                return {
                    id: paradaId,
                    tipo: parada.tipo || 'parada',
                    nombre: `Parada ${paradaId}`,
                    descripcion: `Descripción de la parada ${paradaId}`,
                    coordenadas: coordenadas,
                    audio: parada.audio_id ? `audios/${parada.audio_id}.mp3` : null,
                    reto: parada.reto_id ? { id: parada.reto_id, completado: false } : null,
                    propiedadesAdicionales: {
                        visitada: false,
                        timestamp: Date.now()
                    }
                };
                
            } catch (error) {
                console.error(`Error al obtener datos de la parada ${paradaId}:`, error);
                return null;
            }
        }

        // Función de inicialización del mapa ya existe, no es necesario duplicarla
        
        // Función para crear marcadores ya existe, no es necesario duplicarla
        
        /**
         * Maneja las solicitudes de datos de paradas
         */
        function manejarSolicitudDatos(mensaje) {
            try {
                const { tipo, datos, origen } = mensaje;
                console.log(`Solicitud de datos recibida de ${origen}:`, tipo, datos);
                
                if (tipo === TIPOS_MENSAJE.DATOS.SOLICITAR_PARADA) {
                    const { paradaId } = datos;
                    const datosParada = obtenerDatosParada(paradaId);
                    
                    if (datosParada) {
                        return { 
                            exito: true, 
                            datos: datosParada 
                        };
                    } else {
                        return { 
                            exito: false, 
                            error: `No se encontró la parada ${paradaId}` 
                        };
                    }
                }
                
                return { exito: false, error: 'Tipo de solicitud no reconocido' };
                
            } catch (error) {
                console.error('Error manejando solicitud de datos:', error);
                return { 
                    exito: false, 
                    error: error.message 
                };
            }
        }

        // ================== MANEJO DE MARCADORES ==================
        
        /**
         * Inicializa los marcadores en el mapa
         */
        function inicializarMarcadores() {
            // Aquí se inicializarán los marcadores de las paradas
            console.log('Inicializando marcadores...');
            // Implementación pendiente
        }

        // ================== MANEJADORES DE EVENTOS ==================
        
        /**
         * Maneja la notificación de que un hijo está listo
         * @param {Object} mensaje - Mensaje recibido
         */
        // Función para manejar hijo listo ya existe, no es necesario duplicarla
        // El código original ha sido movido a la función manejarHijoListo

        /**
         * Maneja errores reportados por los hijos
         * @param {Object} mensaje - Mensaje de error
         */
        function manejarErrorDeHijo(mensaje) {
            const { origen, datos } = mensaje;
            console.error(`❌ Error reportado por ${origen}:`, datos);
            
            // Registrar el error en el estado global
            if (!estadoGlobal.errores) estadoGlobal.errores = [];
            estadoGlobal.errores.push({
                origen,
                timestamp: new Date().toISOString(),
                error: datos.error || 'Error desconocido'
            });
            
            // Opcional: Notificar a otros componentes sobre el error
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.SISTEMA.ERROR,
                datos: { 
                    origen,
                    mensaje: 'Se ha producido un error en un componente',
                    error: datos.error
                }
            }, [origen]);
        }

        /**
         * Maneja el cambio de parada solicitado por un hijo
         * @param {Object} mensaje - Mensaje de cambio de parada
         * @returns {Object} Resultado de la operación
         */
        function manejarCambioParada(mensaje) {
            const { origen, datos } = mensaje;
            const { paradaId } = datos || {};
            
            if (!paradaId) {
                console.warn('Se solicitó cambio de parada sin especificar ID');
                return { exito: false, error: 'ID de parada no especificado' };
            }
            
            console.log(`🔄 Cambio de parada solicitado por ${origen}: ${paradaId}`);
            
            // Verificar si la parada existe
            const parada = AVENTURA_PARADAS.find(p => p.parada_id === paradaId || p.padreid === paradaId);
            if (!parada) {
                console.warn(`Parada ${paradaId} no encontrada`);
                return { exito: false, error: 'Parada no encontrada' };
            }
            
            try {
                // Actualizar estado global
                estadoGlobal.paradaActual = parada.parada_id || parada.padreid;
                
                // Notificar a todos los hijos sobre el cambio
                broadcastMensaje({
                    tipo: TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA,
                    datos: { 
                        paradaId: estadoGlobal.paradaActual,
                        origen: 'sistema',
                        timestamp: Date.now()
                    }
                });
                
                // Si hay un reto asociado, notificarlo
                if (parada.reto_id) {
                    broadcastMensaje({
                        tipo: TIPOS_MENSAJE.RETOS.ABRIR,
                        datos: { retoId: parada.reto_id }
                    });
                }
                
                return { exito: true };
                
            } catch (error) {
                console.error('Error al manejar cambio de parada:', error);
                return { exito: false, error: error.message };
            }
        }

        /**
         * Maneja la notificación de llegada a un destino
         * @param {Object} mensaje - Mensaje de llegada
         */
        function manejarLlegadaDestino(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`🏁 Llegada a destino reportada por ${origen}:`, datos);
            
            // Actualizar estado
            estadoGlobal.ultimaLlegada = {
                timestamp: Date.now(),
                paradaId: datos.paradaId,
                origen
            };
            
            // Notificar a otros componentes
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.NAVEGACION.LLEGADA_CONFIRMADA,
                datos: {
                    paradaId: datos.paradaId,
                    timestamp: Date.now()
                }
            }, [origen]);
        }

        /**
         * Maneja la solicitud de información de destino
         * @param {Object} mensaje - Mensaje de solicitud
         */
        function manejarSolicitudDestino(mensaje) {
            const { origen } = mensaje;
            console.log(`❓ Solicitud de destino desde ${origen}`);
            
            return {
                exito: true,
                datos: {
                    paradaActual: estadoGlobal.paradaActual,
                    modo: estadoGlobal.modo,
                    timestamp: Date.now()
                }
            };
        }

        /**
         * Maneja la notificación de finalización de audio
         * @param {Object} mensaje - Mensaje de finalización
         */
        function manejarAudioFinalizado(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`🔊 Audio finalizado en ${origen}:`, datos.audioId);
            
            // Actualizar estado de reproducción
            estadoGlobal.audioReproduciendo = false;
            
            // Notificar a otros componentes
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.AUDIO.FINALIZADO,
                datos: { audioId: datos.audioId }
            }, [origen]);
        }

        /**
         * Maneja actualizaciones de estado de audio
         * @param {Object} mensaje - Mensaje de estado
         */
        function manejarEstadoAudio(mensaje) {
            const { origen, datos } = mensaje;
            estadoGlobal.audioReproduciendo = datos.reproduciendo;
            console.log(`🎵 Estado de audio actualizado por ${origen}:`, 
                datos.reproduciendo ? 'Reproduciendo' : 'Detenido');
        }

        /**
         * Maneja la finalización de un reto
         * @param {Object} mensaje - Mensaje de reto completado
         */
        function manejarRetoCompletado(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`🏆 Reto completado por ${origen}:`, datos.retoId);
            
            // Actualizar estado de retos completados
            if (!estadoGlobal.retosCompletados) {
                estadoGlobal.retosCompletados = new Set();
            }
            estadoGlobal.retosCompletados.add(datos.retoId);
            
            // Notificar a otros componentes
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.RETOS.COMPLETADO,
                datos: {
                    retoId: datos.retoId,
                    timestamp: Date.now()
                }
            });
        }

        /**
         * Maneja la solicitud de abrir un reto
         * @param {Object} mensaje - Mensaje de apertura de reto
         */
        function manejarAbrirReto(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`🎮 Abriendo reto solicitado por ${origen}:`, datos.retoId);
            
            // Verificar si el reto está disponible
            const paradaActual = AVENTURA_PARADAS.find(p => 
                p.parada_id === estadoGlobal.paradaActual || 
                p.padreid === estadoGlobal.paradaActual
            );
            
            if (!paradaActual || paradaActual.reto_id !== datos.retoId) {
                console.warn(`Intento de abrir reto no válido: ${datos.retoId}`);
                return { exito: false, error: 'Reto no disponible en la parada actual' };
            }
            
            // Notificar a todos los componentes para abrir el reto
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.RETOS.ABRIR,
                datos: { 
                    retoId: datos.retoId,
                    origen: 'sistema',
                    timestamp: Date.now()
                }
            });
            
            return { exito: true };
        }

        /**
         * Maneja actualizaciones de estado del GPS
         * @param {Object} mensaje - Mensaje de estado del GPS
         */
        function manejarEstadoGPS(mensaje) {
            const { origen, datos } = mensaje;
            estadoGlobal.gpsActivo = datos.activo;
            console.log(`📍 Estado GPS actualizado por ${origen}:`, 
                datos.activo ? 'Activo' : 'Inactivo');
            
            // Notificar a otros componentes sobre el cambio de estado del GPS
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.GPS.ESTADO,
                datos: { 
                    activo: datos.activo,
                    precision: datos.precision,
                    timestamp: Date.now()
                }
            }, [origen]);
        }

        /**
         * Transmite un mensaje a todos los hijos excepto a los excluidos
         * @param {Object} mensaje - Mensaje a transmitir
         * @param {Array} [excluir=[]] - Lista de IDs de componentes a excluir
         */
        function broadcastMensaje(mensaje, excluir = []) {
            if (!mensaje.tipo) {
                console.error('Intento de broadcast sin tipo de mensaje');
                return;
            }
            
            HIJOS_SISTEMA.forEach(hijo => {
                if (!excluir.includes(hijo)) {
                    Mensajeria.enviarMensaje(hijo, mensaje.tipo, mensaje.datos || {})
                        .catch(error => {
                            console.error(`Error enviando mensaje a ${hijo}:`, error);
                        });
                }
            });
        }

        /**
         * Sincroniza el estado actual con todos los hijos
         */
        function sincronizarEstadoConHijos() {
            console.log('🔄 Sincronizando estado con todos los hijos...');
            
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.SISTEMA.SINCRONIZAR_ESTADO,
                datos: {
                    modo: estadoGlobal.modo,
                    paradaActual: estadoGlobal.paradaActual,
                    gpsActivo: estadoGlobal.gpsActivo,
                    audioReproduciendo: estadoGlobal.audioReproduciendo,
                    retosCompletados: Array.from(estadoGlobal.retosCompletados || []),
                    timestamp: Date.now()
                }
            });
        }

        // ================== INICIALIZACIÓN DE LA APLICACIÓN ==================
        
        // Mostrar indicador de carga
        const loadingEl = document.createElement('div');
        loadingEl.className = 'loading';
        loadingEl.textContent = 'Inicializando aplicación...';
        document.body.appendChild(loadingEl);

        // Función para manejar errores de inicialización
        /**
         * Maneja errores durante la inicialización
         * @param {Error} error - Error que ocurrió
         * @param {number} [intento=1] - Número de intento actual
         */
        async function manejarErrorInicializacion(error, intento = 1) {
            console.error(`Error de inicialización (intento ${intento}):`, error);
            
            // Mostrar mensaje de error
            const mensajeError = `Error: ${error.message || 'Error desconocido'}`;
            
            if (loadingEl) {
                loadingEl.textContent = mensajeError;
                loadingEl.style.backgroundColor = '#f44336';
            }
            
            // Intentar reconectar si no hemos superado el número máximo de intentos
            if (intento < MAX_RETRY_ATTEMPTS) {
                console.log(`Reintentando en ${RETRY_DELAY}ms...`);
                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                return inicializar().catch(err => manejarErrorInicializacion(err, intento + 1));
            }
            
            // Si llegamos aquí, hemos agotado los intentos
            mostrarMensajeInterfaz({
                tipo: 'error',
                titulo: 'Error de inicialización',
                mensaje: 'No se pudo inicializar la aplicación. Por favor, recarga la página.'
            });
            
            // Añadir botón de reintento
            const reintentarBtn = document.createElement('button');
            reintentarBtn.textContent = 'Reintentar';
            reintentarBtn.style.marginTop = '10px';
            reintentarBtn.style.padding = '5px 10px';
            reintentarBtn.onclick = () => {
                loadingEl.textContent = 'Reintentando...';
                setTimeout(() => inicializar().catch(manejarErrorInicializacion), 1000);
            };
            loadingEl.appendChild(document.createElement('br'));
            loadingEl.appendChild(reintentarBtn);
        }

        /**
         * Inicializa la aplicación principal
         */
        async function initApp() {
            console.log('🚀 Iniciando aplicación...');
            const loadingEl = document.createElement('div');
            loadingEl.id = 'loading-indicator';
            loadingEl.style.position = 'fixed';
            loadingEl.style.top = '50%';
            loadingEl.style.left = '50%';
            loadingEl.style.transform = 'translate(-50%, -50%)';
            loadingEl.style.padding = '20px';
            loadingEl.style.background = 'rgba(0,0,0,0.8)';
            loadingEl.style.color = 'white';
            loadingEl.style.borderRadius = '5px';
            loadingEl.style.zIndex = '1000';
            loadingEl.textContent = 'Inicializando aplicación...';
            document.body.appendChild(loadingEl);
            
            try {
                await inicializar();
                console.log('✅ Aplicación iniciada correctamente');
                loadingEl.remove();
            } catch (error) {
                console.error('❌ Error al iniciar la aplicación:', error);
                loadingEl.textContent = 'Error al iniciar: ' + (error.message || 'Error desconocido');
                loadingEl.style.background = '#f44336';
                
                // Añadir botón de reintento
                const retryBtn = document.createElement('button');
                retryBtn.textContent = 'Reintentar';
                retryBtn.style.marginTop = '10px';
                retryBtn.style.padding = '5px 10px';
                retryBtn.onclick = () => {
                    loadingEl.textContent = 'Reintentando...';
                    setTimeout(() => initApp(), 1000);
                };
                loadingEl.appendChild(document.createElement('br'));
                loadingEl.appendChild(retryBtn);
            }
        }

        // Iniciar la aplicación cuando el DOM esté listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }

    </script>
</body>
</html>
