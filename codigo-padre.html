<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Padre - Coordinador Central</title>
    
    <!-- Estilos CSS para el mapa -->
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #mapa {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background-color: #f0f0f0;
        }
        
        /* Loading indicator */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 40px;
            border-radius: 5px;
            font-size: 18px;
        }
        
        /* Estilos para los marcadores */
        .marcador {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            text-align: center;
            font-weight: bold;
            color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        
        .marcador-inicio {
            background-color: #4CAF50; /* Verde para el inicio */
            border: 2px solid #388E3C;
            width: 36px;
            height: 36px;
            font-size: 14px;
        }
        
        .marcador-parada {
            background-color: #2196F3; /* Azul para las paradas */
            border: 2px solid #1976D2;
            width: 32px;
            height: 32px;
            font-size: 12px;
        }
        
        .marcador-destacado {
            animation: pulse 1.5s infinite;
            transform: scale(1.1);
            z-index: 1000 !important;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        
        /* Estilos para los popups */
        .popup-parada {
            padding: 10px;
            text-align: center;
        }
        
        .popup-parada h4 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 16px;
        }
        
        .popup-parada p {
            margin: 5px 0;
            font-size: 14px;
            color: #666;
        }
        
        .btn-navegar {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 8px 15px;
            margin-top: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        
        .btn-navegar:hover {
            background-color: #1976D2;
        }
        
        /* Ajustes para los controles del mapa */
        .leaflet-control-zoom {
            margin-top: 60px !important; /* Para dejar espacio para el logo */
        }
        
        .leaflet-control-attribution {
            font-size: 10px;
            padding: 2px 5px;
            background: rgba(255, 255, 255, 0.8);
        }
        
        .leaflet-container {
            background: #f8f9fa;
        }
        
        /* Estilos para los marcadores personalizados */
        .marcador {
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .marcador:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            z-index: 1000 !important;
        }
        
        .marcador-inicio {
            background-color: #28a745; /* Verde para el punto de inicio */
            width: 36px;
            height: 36px;
            margin-top: -18px !important;
            margin-left: -18px !important;
        }
        
        .marcador-parada {
            background-color: #007bff; /* Azul para las paradas normales */
            width: 32px;
            height: 32px;
            margin-top: -16px !important;
            margin-left: -16px !important;
        }
        
        .marcador-contenido {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Ajustes para el contenedor del mapa */
        #mapa {
            z-index: 1;
        }
    </style>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tC8quh7qG8H+2g2jC9SM="
          crossorigin=""/>
    
    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
</head>

<body>
    <!-- Contenedor del mapa -->
    <div id="mapa"></div>
    
    <!-- Logo de la aplicaci√≥n -->
    <img id="logo-aventura" 
         src="https://valenciavguides.github.io/Aventura-1-esp-padre-con-hijos/fotos_Av1/LOGO%20LETRAS%20FINAL%20transparente%20recorte.png" 
         alt="Logo" 
         style="position: fixed; top: -32px; left: 50%; transform: translateX(-50%); z-index: 3000; width: 360px; height: 140px;" />

    <!-- Script principal -->
    <script type="module">
        // ================== IMPORTACI√ìN DE M√ìDULOS ==================
        import { Mensajeria, TIPOS_MENSAJE } from './mensajeria.js';
        
        // ================== CONFIGURACI√ìN GLOBAL ==================
        const CONFIG = {
            iframeId: 'padre',
            debug: true,
            logLevel: 1
        };

        // ================== ESTADO GLOBAL MEJORADO ==================
        const estadoGlobal = {
            // Estado de la aplicaci√≥n
            modo: 'casa',
            gpsActivo: false,
            paradaActual: 0,
            tramoActual: 0,
            
            // Gesti√≥n de hijos
            hijosListos: new Set(),
            hijosConectados: new Map(), // Mapa de estado de conexi√≥n de hijos
            
            // Componentes
            mapa: null,
            audioReproduciendo: false,
            retoActivo: null,
            
            // Datos
            coordenadasParadas: new Map(),
            marcadores: new Map(),
            rutas: new Map(),
            
            // Estado del sistema
            errores: [],
            ultimaActualizacion: null,
            version: '2.0.0',
            
            // Rendimiento
            metricas: {
                mensajesEnviados: 0,
                mensajesRecibidos: 0,
                ultimaComprobacion: Date.now()
            },
            
            // Configuraci√≥n
            config: {
                maxReintentos: 3,
                tiempoEsperaInicial: 1000,
                debug: true,
                tiempoEsperaHijos: 10000, // 10 segundos para que los hijos se conecten
                intervaloMonitoreo: 30000, // Verificar estado de hijos cada 30 segundos
                maxReintentosConexion: 3
            }
        };

        // Lista de hijos conocidos con sus configuraciones
        const HIJOS_SISTEMA = [
            { id: 'Av1_audio_esp', tipo: 'audio', requerido: true },
            { id: 'Av1-botones-coordenadas', tipo: 'navegacion', requerido: true },
            { id: 'Av1-esp-retos-preguntas', tipo: 'retos', requerido: true },
            { id: 'Av1-boton-casa', tipo: 'ui', requerido: true }
        ];
        
        // Mapa de tipos de mensajes que cada hijo debe manejar
        const MENSAJES_POR_TIPO = {
            audio: [
                TIPOS_MENSAJE.AUDIO.REPRODUCIR,
                TIPOS_MENSAJE.AUDIO.PAUSAR,
                TIPOS_MENSAJE.AUDIO.DETENER,
                TIPOS_MENSAJE.AUDIO.ESTADO
            ],
            navegacion: [
                TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA,
                TIPOS_MENSAJE.NAVEGACION.CAMBIO_TRAMO,
                TIPOS_MENSAJE.NAVEGACION.ESTADO,
                TIPOS_MENSAJE.GPS.ESTADO
            ],
            retos: [
                TIPOS_MENSAJE.RETOS.ABRIR,
                TIPOS_MENSAJE.RETOS.CERRAR,
                TIPOS_MENSAJE.RETOS.COMPLETADO,
                TIPOS_MENSAJE.RETOS.VALIDAR
            ],
            ui: [
                TIPOS_MENSAJE.UI.ACTUALIZAR,
                TIPOS_MENSAJE.UI.MOSTRAR_IMAGEN,
                TIPOS_MENSAJE.UI.MOSTRAR_VIDEO,
                TIPOS_MENSAJE.UI.CERRAR_MEDIA
            ]
        };

        // ================== DATOS DE PARADAS ==================
        const AVENTURA_PARADAS = [
            // Parada 0 ‚Äì INICIO (Torres de Serranos start) reto 2 (223, 226, 228, 229)
            { padreid: "padre-P-0", tipo: "inicio", parada_id: 'P-0', audio_id: "audio-P-0", reto_id: "R-2" },
            // tramo 1 (Torres de Serranos ‚Üí Plaza de la crida) (2, 126,)
            { padreid: "padre-TR-1", tipo: "tramo", tramo_id: 'TR-1', audio_id: "audio-TR-1" },
            // Parada 1 - Plaza de la crida (Puente de Serranos) Reto 3 (233) //
            { padreid: "padre-P-1", tipo: "parada", parada_id: 'P-1', audio_id: "audio-P-1", reto_id: "R-3" },
            // tramo 2 (Plaza de la crida ‚Üí Calle Muro de Santa Ana) (81) //
            { padreid: "padre-TR-2", tipo: "tramo", tramo_id: 'TR-2', audio_id: "audio-TR-2" },
            // Parada 2 (Calle Muro de Santa Ana) Reto 4 (68) //
            { padreid: "padre-P-2", tipo: "parada", parada_id: 'P-2', audio_id: "audio-P-2", reto_id: "R-4" },
            // tramo 3 (Calle Muro de Santa Ana ‚Üí Palacio de los Borgia) (52) //
            { padreid: "padre-TR-3", tipo: "tramo", tramo_id: 'TR-3', audio_id: "audio-TR-3" },
            // Parada 3 (Iglesia de San Lorenzo) Reto 5 (686, 682-B, 462, 683, 684) //
            { padreid: "padre-P-3", tipo: "parada", parada_id: 'P-3', audio_id: "audio-P-3", reto_id: "R-5" },
            // tramo 4 (Iglesia de San Lorenzo ‚Üí Plaza de la Virgen) (465-B) //
            { padreid: "padre-TR-4", tipo: "tramo", tramo_id: 'TR-4', audio_id: "audio-TR-4" },
            // Parada 4 (Plaza de la Virgen) Reto 6 (466, 467) //
            { padreid: "padre-P-4", tipo: "parada", parada_id: 'P-4', audio_id: "audio-P-4", reto_id: "R-6" },
            // Parada 5 (Plaza de la Virgen) Reto 7, 8 Puzzle plaza de la virgen (468)  //
            { 
                padreid: "padre-P-5",
                tipo: "parada", 
                parada_id: 'P-5', 
                audio_id: "audio-P-5", 
                retos: [
                    { tipo: "reto", id: "R-7" },
                    { tipo: "puzzle", id: "PZ-8" }
                ] 
            },
            // tramo 5 (Plaza de la Virgen ‚Üí Plaza de la Almo√≠na) (477-B, 479, 141, 83, 8-C) //
            { padreid: "padre-TR-5", tipo: "tramo", tramo_id: 'TR-5', audio_id: "audio-TR-5" },
            // Parada 6 (Panel cer√°mico muro Catedral) Reto 9 (434, 440, 441, 442) //
            { padreid: "padre-P-6", tipo: "parada", parada_id: 'P-6', audio_id: "audio-P-6", reto_id: "R-9" },
            // Parada 7 (Capilla exterior catedral) Reto 10 (443, 444, 445) //
            { padreid: "padre-P-7", tipo: "parada", parada_id: 'P-7', audio_id: "audio-P-7", reto_id: "R-10" },
            // Parada 8 (Capilla exterior catedral) Reto 11 (445) //
            { padreid: "padre-P-8", tipo: "parada", parada_id: 'P-8', audio_id: "audio-P-8", reto_id: "R-11" },
            // Parada 9 (Arco Novo Catedral y Puerta Negra Bas√≠lica) (446, 355, 447, 11-B, 451, 452) //
            { padreid: "padre-P-9", tipo: "parada", parada_id: 'P-9', audio_id: "audio-P-9" },
            // Parada 10 (Casa del Punt de Gantxo) Reto 12 (51-C, 454, 455, 455-B, 456, 148) //
            { padreid: "padre-P-10", tipo: "parada", parada_id: 'P-10', audio_id: "audio-P-10", reto_id: "R-12"  },
            // tramo 6 (Plaza de la Almo√≠na (casa del punt de Gantxo) ‚Üí Plaza Decimo Junio Bruto) (457, 10-B)//
            { padreid: "padre-TR-6", tipo: "tramo", tramo_id: 'TR-6', audio_id: "audio-TR-6" },
            // Parada 11 (Museo arqueol√≥gico La Almo√≠na) Reto 13 (458) //
            { padreid: "padre-P-11", tipo: "parada", parada_id: 'P-11', audio_id: "audio-P-11", reto_id: "R-13" },
            // Parada 12 (Museo arqueol√≥gico La Almo√≠na 2) (459, 460, 461) //
            { padreid: "padre-P-12", tipo: "parada", parada_id: 'P-12', audio_id: "audio-P-12" },
            // Parada 13 (Vista de la Catedral, Cimborrio) Reto 14 (8-C, 464) //
            { padreid: "padre-P-13", tipo: "parada", parada_id: 'P-13', audio_id: "audio-P-13", reto_id: "R-14" },
            // tramo 7 (Museo arqueol√≥gico La Almo√≠na ‚Üí Palacio Arzobispal) (85) //
            { padreid: "padre-TR-7", tipo: "tramo", tramo_id: 'TR-7', audio_id: "audio-TR-7" },
            // Parada 14 (Palacio Arzobispal y Puerta Rom√°nica de la Catedral) Reto 15 (673, 86, 426-B, 141, 437, 438) //
            { padreid: "padre-P-14", tipo: "parada", parada_id: 'P-14', audio_id: "audio-P-14", reto_id: "R-15" },
            // Parada 15 (Puerta Rom√°nica de la Catedral) (439) //
            { padreid: "padre-P-15", tipo: "parada", parada_id: 'P-15', audio_id: "audio-P-15" },
            // tramo 8 (Puerta Rom√°nica de la Catedral ‚Üí Plaza del Ayuntamiento) (125) //
            { padreid: "padre-TR-8", tipo: "tramo", tramo_id: 'TR-8', audio_id: "audio-TR-8" },
            // Parada 16 (Plaza del Ayuntamiento) (13-B, 263, 332, 14-C) //
            { padreid: "padre-P-16", tipo: "parada", parada_id: 'P-16', audio_id: "audio-P-16" },
            // tramo 9 (Plaza del Ayuntamiento ‚Üí Edificio del Ayuntamiento) (334, 335) //
            { padreid: "padre-TR-9", tipo: "tramo", tramo_id: 'TR-9', audio_id: "audio-TR-9" },
            // Parada 17 (Edificio del Ayuntamiento) Reto 16 (336, 337, 338) //
            { padreid: "padre-P-17", tipo: "parada", parada_id: 'P-17', audio_id: "audio-P-17", reto_id: "R-16" },
            // Parada 18 (Edificio del Ayuntamiento, leyenda del murci√©lago) (339, 340, 341, 54) //
            { padreid: "padre-P-18", tipo: "parada", parada_id: 'P-18', audio_id: "audio-P-18" },
            // tramo 10 (Edificio del Ayuntamiento ‚Üí Estaci√≥n del Norte) (87, 15-C) //
            { padreid: "padre-TR-10", tipo: "tramo", tramo_id: 'TR-10', audio_id: "audio-TR-10" },
            // Parada 19 (Estaci√≥n del Norte) Reto 17, 18 Puzzle Estaci√≥n del Norte (326) //
            { 
                padreid: "padre-P-19",
                tipo: "parada", 
                parada_id: 'P-19', 
                audio_id: "audio-P-19", 
                retos: [
                    { tipo: "reto", id: "R-17" },
                    { tipo: "puzzle", id: "PZ-18" }
                ] 
            },
            // tramo 11 (Estaci√≥n del Norte ‚Üí Plaza de Toros) (20-C, 323-B, 88) //
            { padreid: "padre-TR-11", tipo: "tramo", tramo_id: 'TR-11', audio_id: "audio-TR-11" },
            // Tramo 12 (Plaza de Toros ‚Üí Casa estilo √Årabe) (89, 3-D) //
            { padreid: "padre-TR-12", tipo: "tramo", tramo_id: 'TR-12', audio_id: "audio-TR-12" },
            // Parada 20 (Casa estilo √Årabe) Reto 19 (99) //
            { padreid: "padre-P-20", tipo: "parada", parada_id: 'P-20', audio_id: "audio-P-20", reto_id: "R-19" },
            // Parada 21 (Casa estilo √Årabe, mitad Aventura) (100) //
            { padreid: "padre-P-21", tipo: "parada", parada_id: 'P-21', audio_id: "audio-P-21" },
            // tramo 13 (Casa estilo √Årabe ‚Üí Palacio de Comunicaciones) (21-B) //
            { padreid: "padre-TR-13", tipo: "tramo", tramo_id: 'TR-13', audio_id: "audio-TR-13" },
            // Parada 22 (Palacio de Comunicaciones) Reto 20 y Reto 21 (700, 343, 344) //
            { padreid: "padre-P-22", tipo: "parada", parada_id: 'P-22', audio_id: "audio-P-22", retos: ["R-20", "R-21"] },
            // Parada 23 (Edificio Suay) Reto 21 (693, 693-B) //
            { padreid: "padre-P-23", tipo: "parada", parada_id: 'P-23', audio_id: "audio-P-23", reto_id: "R-21" },
            // tramo 14 (Palacio de Comunicaciones, edificio Suay ‚Üí Banco de Val√®ncia) (345, 347, 348, 22, 109) //
            { padreid: "padre-TR-14", tipo: "tramo", tramo_id: 'TR-14', audio_id: "audio-TR-14" },
            // Parada 24 (Banco de Valencia) Reto 22 (349, 350) //
            { padreid: "padre-P-24", tipo: "parada", parada_id: 'P-24', audio_id: "audio-P-24", reto_id: "R-22" },
            // tramo 15 (Banco de Val√®ncia ‚Üí Palacio del Marqu√©s de Dos Aguas) (351, 23-B, 352, 354) //
            { padreid: "padre-TR-15", tipo: "tramo", tramo_id: 'TR-15', audio_id: "audio-TR-15" },
            // Parada 25 (Palacio del Marqu√©s de Dos Aguas) (356, 357)//
            { padreid: "padre-P-25", tipo: "parada", parada_id: 'P-25', audio_id: "audio-P-25" },
            // tramo 16 (Palacio del Marqu√©s ‚Üí Mercado Central) (358, 359-B, 101) //
            { padreid: "padre-TR-16", tipo: "tramo", tramo_id: 'TR-16', audio_id: "audio-TR-16" },
            // Parada 26 (Mercado central) Reto23 (701, 24-D, 361, 362, 363, 364) //
            { padreid: "padre-P-26", tipo: "parada", parada_id: 'P-26', audio_id: "audio-P-26", reto_id: "R-23" },
            // tramo 17 (Mercado Central ‚Üí Iglesia de los Santos Juanes) (274, 27-C) //
            { padreid: "padre-TR-17", tipo: "tramo", tramo_id: 'TR-17', audio_id: "audio-TR-17" },
            // Parada 27 (Iglesia de los Santos Juanes) Reto 24) (365, 366) //
            { padreid: "padre-P-27", tipo: "parada", parada_id: 'P-27', audio_id: "audio-P-27", reto_id: "R-24" },
            // Parada 28 (Iglesia de los Santos Juanes reto 25) (367) //
            { padreid: "padre-P-28", tipo: "parada", parada_id: 'P-28', audio_id: "audio-P-28", reto_id: "R-25" },
            // tramo 18 (Iglesia Santos Juanes ‚Üí Lonja de Val√®ncia) (368, 369, 28, 370, 371, 372, 373, 374, 375, 376, 377) //
            { padreid: "padre-TR-18", tipo: "tramo", tramo_id: 'TR-18', audio_id: "audio-TR-18" },
            // Parada 29 (Lonja Puerta de Los Pecados barquero) Reto 27 (378, 379) //
            { padreid: "padre-P-29", tipo: "parada", parada_id: 'P-29', audio_id: "audio-P-29", reto_id: "R-27" },
            // Parada 30 (Lonja Puerta de Los Pecados √°rbol muerto) Reto 28 (380, 381) //
            { padreid: "padre-P-30", tipo: "parada", parada_id: 'P-30', audio_id: "audio-P-30", reto_id: "R-28" },
            // tramo 19 (Lonja G√°rgolas) (383) //
            { padreid: "padre-TR-19", tipo: "tramo", tramo_id: 'TR-19', audio_id: "audio-TR-19" },
            // Parada 31 (Lonja G√°rgolas √°ngel vasija) Reto 29 (384) //
            { padreid: "padre-P-31", tipo: "parada", parada_id: 'P-31', audio_id: "audio-P-31", reto_id: "R-29" },
            // Parada 32 (Lonja G√°rgolas barbudo y le√≥n) Reto 30 (385) //
            { padreid: "padre-P-32", tipo: "parada", parada_id: 'P-32', audio_id: "audio-P-32", reto_id: "R-30" },
            // Parada 33 (Lonja G√°rgolas fornicador ventana) Reto 31, Puzzle 26 ) (386) //
            { padreid: "padre-P-33", tipo: "parada", parada_id: 'P-33', audio_id: "audio-P-33", retos: [ { tipo: "reto", id: "R-31" }, { tipo: "puzzle", id: "PZ-26" } ] },
            // tramo 20 (Lonja ‚Üí Plaza del Doctor Collado) (388, 389, 390, 391, 392) //
            { padreid: "padre-TR-20", tipo: "tramo", tramo_id: 'TR-20', audio_id: "audio-TR-20" },
            // tramo 21 (Plaza del Doctor Collado ‚Üí Plaza del Negrito) (333, 397, 41, 398, 198, 671, 522, 32-C) //
            { padreid: "padre-TR-21", tipo: "tramo", tramo_id: 'TR-21', audio_id: "audio-TR-21" },
            // Parada 34 (Fuente del Negrito) Reto 32 (382, 501) //
            { padreid: "padre-P-34", tipo: "parada", parada_id: 'P-34', audio_id: "audio-P-34", reto_id: "R-32" },
            // tramo 22 (Plaza del Negrito ‚Üí Calle Caballeros) (33-B, 486, 480-B) //
            { padreid: "padre-TR-22", tipo: "tramo", tramo_id: 'TR-22', audio_id: "audio-TR-22" },
            // Parada 35 (Palau de la Generalitat) (481-B, 482-B, 2-D) //
            { padreid: "padre-P-35", tipo: "parada", parada_id: 'P-35', audio_id: "audio-P-35" },
            // tramo 23 (Palacio de la Generalitat ‚Üí Calle de los Serranos - FINAL)  //
            { padreid: "padre-TR-23", tipo: "tramo", tramo_id: 'TR-23', audio_id: "audio-TR-23" },
            // Parada 36 (Torres de Serranos Final) //
            { padreid: "padre-P-36", tipo: "parada", parada_id: 'P-36', audio_id: "audio-P-36" }
        ];

        // ================== INICIALIZACI√ìN DE COORDENADAS ==================
        
        /**
         * Inicia el mapa de coordenadas de las paradas solicitando los datos al hijo2
         * @returns {Promise<boolean>} True si se solicitaron las coordenadas correctamente
         */
        async function inicializarCoordenadasParadas() {
            try {
                console.log('üîÑ Solicitando coordenadas al hijo2...');
                
                // Asegurarse de que el mapa de coordenadas est√© inicializado
                if (!estadoGlobal.coordenadasParadas) {
                    estadoGlobal.coordenadasParadas = new Map();
                }
                
                // Solicitar coordenadas al hijo2
                const respuesta = await Mensajeria.enviarMensaje('hijo2', {
                    tipo: 'solicitar_coordenadas_paradas',
                    timestamp: Date.now()
                });
                
                if (respuesta && respuesta.coordenadas) {
                    console.log('‚úÖ Coordenadas recibidas del hijo2:', respuesta.coordenadas);
                    // Actualizar el estado global con las coordenadas recibidas
                    estadoGlobal.coordenadasParadas = new Map(Object.entries(respuesta.coordenadas));
                    return true;
                } else {
                    console.error('‚ùå No se recibieron coordenadas del hijo2');
                    throw new Error('No se pudieron obtener las coordenadas del componente de mapa');
                }
                
            } catch (error) {
                console.error('‚ùå Error al obtener coordenadas del hijo2:', error);
                throw error; // Propagar el error para que el sistema lo maneje
            }
        }
        
        // ================== FUNCIONES AUXILIARES DE MARCADORES ==================
        
        /**
         * Crea los marcadores iniciales para todas las paradas
         */
        function crearMarcadoresIniciales() {
            if (!estadoGlobal.mapa) {
                console.warn('No se pueden crear marcadores: el mapa no est√° inicializado');
                return;
            }
            
            // Inicializar el grupo de marcadores si no existe
            if (!estadoGlobal.grupoMarcadores) {
                estadoGlobal.grupoMarcadores = L.layerGroup().addTo(estadoGlobal.mapa);
            } else {
                // Limpiar marcadores existentes
                estadoGlobal.grupoMarcadores.clearLayers();
            }
            
            // Inicializar el mapa de marcadores si no existe
            if (!estadoGlobal.marcadoresParadas) {
                estadoGlobal.marcadoresParadas = new Map();
            } else {
                estadoGlobal.marcadoresParadas.clear();
            }
            
            // Contadores para estad√≠sticas
            let marcadoresCreados = 0;
            let errores = 0;
            
            // Recorrer todas las paradas y crear marcadores
            AVENTURA_PARADAS.forEach(parada => {
                // Solo procesar paradas e inicio, no tramos
                if (parada.tipo !== 'parada' && parada.tipo !== 'inicio') {
                    return;
                }
                
                try {
                    const marcador = crearMarcadorParada(parada);
                    if (marcador) {
                        estadoGlobal.marcadoresParadas.set(parada.parada_id, marcador);
                        marcadoresCreados++;
                    }
                } catch (error) {
                    console.error(`Error al crear marcador para ${parada.parada_id}:`, error);
                    errores++;
                }
            });
            
            console.log(`‚úÖ ${marcadoresCreados} marcadores creados, ${errores} errores`);
        }
        
        /**
         * Crea un marcador para una parada espec√≠fica
         * @param {Object} parada - Objeto con los datos de la parada
         * @returns {L.Marker} Marcador de Leaflet
         */
        function crearMarcadorParada(parada) {
            const paradaId = parada.parada_id;
            const coords = estadoGlobal.coordenadasParadas.get(paradaId);
            
            if (!coords) {
                throw new Error(`Coordenadas no encontradas para la parada ${paradaId}`);
            }
            
            // Determinar la clase CSS seg√∫n el tipo de parada
            const esInicio = parada.tipo === 'inicio';
            const claseIcono = esInicio ? 'marcador-inicio' : 'marcador-parada';
            const numeroParada = paradaId.replace('P-', '');
            
            // Crear icono personalizado
            const icono = L.divIcon({
                className: `marcador ${claseIcono}`,
                html: `<div class="marcador-contenido">${numeroParada}</div>`,
                iconSize: esInicio ? [36, 36] : [32, 32],
                iconAnchor: esInicio ? [18, 36] : [16, 32],
                popupAnchor: [0, -32]
            });
            
            // Crear marcador
            const marcador = L.marker(coords, { 
                icon: icono,
                title: `Parada ${numeroParada}${esInicio ? ' (Inicio)' : ''}`,
                alt: `Marcador de ${esInicio ? 'inicio' : 'parada'} ${numeroParada}`,
                zIndexOffset: esInicio ? 1000 : 500, // Asegurar que el inicio est√© por encima
                riseOnHover: true
            });
            
            // Configurar popup
            const popupContent = `
                <div class="popup-parada">
                    <h4>${esInicio ? 'Punto de Inicio' : 'Parada ' + numeroParada}</h4>
                    <p>ID: ${paradaId}</p>
                    ${parada.reto_id ? `<p><strong>Reto:</strong> ${parada.reto_id}</p>` : ''}
                    <button class="btn-navegar" data-parada="${paradaId}">
                        Navegar aqu√≠
                    </button>
                </div>
            `;
            
            // A√±adir popup con contenido HTML
            marcador.bindPopup(popupContent, {
                maxWidth: 250,
                minWidth: 180,
                className: 'popup-parada-estilo',
                closeButton: true,
                autoClose: false,
                closeOnClick: false
            });
            
            // Manejar eventos del marcador
            marcador.on('click', function(e) {
                console.log(`Marcador de ${paradaId} clickeado`);
                // Centrar el mapa en el marcador con zoom
                estadoGlobal.mapa.setView(coords, 18);
            });
            
            // A√±adir al grupo de marcadores
            marcador.addTo(estadoGlobal.grupoMarcadores);
            
            return marcador;
        }
        
        /**
         * Muestra u oculta los marcadores de las paradas
         * @param {boolean} mostrar - Indica si mostrar u ocultar los marcadores
         */
        function mostrarMarcadoresParadas(mostrar = true) {
            if (!estadoGlobal.grupoMarcadores) return;
            
            if (mostrar) {
                estadoGlobal.mapa.addLayer(estadoGlobal.grupoMarcadores);
            } else {
                estadoGlobal.mapa.removeLayer(estadoGlobal.grupoMarcadores);
            }
        }
        
        /**
         * Mueve el mapa a la ubicaci√≥n de una parada espec√≠fica
         * @param {string} paradaId - ID de la parada
         * @param {number} zoom - Nivel de zoom (opcional)
         */
        function centrarEnParada(paradaId, zoom = 18) {
            const marcador = estadoGlobal.marcadoresParadas.get(paradaId);
            if (marcador) {
                const coords = marcador.getLatLng();
                estadoGlobal.mapa.setView(coords, zoom);
                
                // Abrir el popup del marcador
                marcador.openPopup();
                
                // Destacar temporalmente el marcador
                const icon = marcador.getElement();
                if (icon) {
                    icon.classList.add('marcador-destacado');
                    setTimeout(() => {
                        icon.classList.remove('marcador-destacado');
                    }, 2000);
                }
            } else {
                console.warn(`No se encontr√≥ el marcador para la parada ${paradaId}`);
            }
        }
        
        // ================== FUNCIONES DE RUTAS ==================
        
        /**
         * Dibuja una ruta entre dos paradas
         * @param {string} desdeId - ID de la parada de origen
         * @param {string} hastaId - ID de la parada de destino
         * @param {Object} opciones - Opciones para la ruta
         * @returns {L.Polyline} L√≠nea de la ruta
         */
        function dibujarRuta(desdeId, hastaId, opciones = {}) {
            if (!estadoGlobal.mapa) {
                console.warn('No se puede dibujar la ruta: el mapa no est√° inicializado');
                return null;
            }
            
            // Obtener coordenadas de las paradas
            const desdeCoords = estadoGlobal.coordenadasParadas.get(desdeId);
            const hastaCoords = estadoGlobal.coordenadasParadas.get(hastaId);
            
            if (!desdeCoords || !hastaCoords) {
                console.warn('No se encontraron coordenadas para una o ambas paradas');
                return null;
            }
            
            // Opciones por defecto
            const opcionesRuta = {
                color: '#3f51b5',
                weight: 5,
                opacity: 0.8,
                dashArray: '10, 10',
                lineCap: 'round',
                ...opciones
            };
            
            // Crear la ruta
            const ruta = L.polyline([desdeCoords, hastaCoords], opcionesRuta).addTo(estadoGlobal.mapa);
            
            // Almacenar referencia a la ruta
            if (!estadoGlobal.rutas) {
                estadoGlobal.rutas = [];
            }
            estadoGlobal.rutas.push(ruta);
            
            // Ajustar la vista para mostrar toda la ruta
            const bounds = L.latLngBounds([desdeCoords, hastaCoords]);
            estadoGlobal.mapa.fitBounds(bounds, { padding: [50, 50] });
            
            return ruta;
        }
        
        /**
         * Limpia todas las rutas dibujadas en el mapa
         */
        function limpiarRutas() {
            if (!estadoGlobal.rutas || estadoGlobal.rutas.length === 0) return;
            
            estadoGlobal.rutas.forEach(ruta => {
                if (ruta && estadoGlobal.mapa.hasLayer(ruta)) {
                    estadoGlobal.mapa.removeLayer(ruta);
                }
            });
            
            estadoGlobal.rutas = [];
            console.log('‚úÖ Rutas limpiadas');
        }
        
        /**
         * Navega a la siguiente parada desde la actual
         * @param {string} paradaActualId - ID de la parada actual
         * @returns {boolean} True si se pudo navegar a la siguiente parada
         */
        function navegarSiguienteParada(paradaActualId) {
            if (!paradaActualId || !estadoGlobal.coordenadasParadas.has(paradaActualId)) {
                console.warn('ID de parada actual no v√°lido');
                return false;
            }
            
            // Obtener el √≠ndice de la parada actual
            const indiceActual = AVENTURA_PARADAS.findIndex(p => p.parada_id === paradaActualId);
            if (indiceActual === -1 || indiceActual >= AVENTURA_PARADAS.length - 1) {
                console.warn('No hay m√°s paradas disponibles');
                return false;
            }
            
            // Obtener la siguiente parada
            const siguienteParada = AVENTURA_PARADAS[indiceActual + 1];
            if (!siguienteParada || !estadoGlobal.coordenadasParadas.has(siguienteParada.parada_id)) {
                console.warn('No se pudo encontrar la siguiente parada');
                return false;
            }
            
            // Limpiar rutas anteriores
            limpiarRutas();
            
            // Dibujar la ruta
            dibujarRuta(paradaActualId, siguienteParada.parada_id, {
                color: '#ff9800',
                weight: 6,
                dashArray: '15, 10',
                className: 'ruta-activa'
            });
            
            // Centrar en la siguiente parada
            centrarEnParada(siguienteParada.parada_id);
            
            console.log(`üöÄ Navegando a la siguiente parada: ${siguienteParada.parada_id}`);
            return true;
        }
        
        // ================== MANEJADORES DE EVENTOS ==================
        
        /**
         * Inicializa los manejadores de eventos del mapa
         */
        function inicializarManejadoresEventos() {
            if (!estadoGlobal.mapa) return;
            
            // Manejador para clics en el bot√≥n de navegaci√≥n en los popups
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('btn-navegar')) {
                    const paradaId = e.target.dataset.parada;
                    if (paradaId) {
                        centrarEnParada(paradaId);
                        
                        // Desplazar suavemente al mapa
                        const mapaElement = document.getElementById('mapa');
                        if (mapaElement) {
                            mapaElement.scrollIntoView({ behavior: 'smooth' });
                        }
                    }
                }
            });
            
            // Manejador para el evento de cambio de tama√±o de ventana
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (estadoGlobal.mapa) {
                        estadoGlobal.mapa.invalidateSize({ animate: true });
                    }
                }, 250);
            });
            
            console.log('‚úÖ Manejadores de eventos inicializados');
        }
        
        // ================== GESTI√ìN DE HIJOS ==================
        
        /**
         * Inicializa el monitoreo de los componentes hijos
         */
        function inicializarMonitoreoHijos() {
            console.log('üîç Iniciando monitoreo de componentes hijos...');
            
            // Configurar el monitoreo peri√≥dico
            estadoGlobal.intervaloMonitoreo = setInterval(verificarEstadoHijos, 
                estadoGlobal.configuracion.intervaloMonitoreo);
                
            // Configurar un temporizador para detectar hijos que no responden
            setTimeout(() => {
                const hijosInactivos = HIJOS_SISTEMA.filter(hijo => 
                    !estadoGlobal.hijosListos.has(hijo.id) && hijo.requerido
                );
                
                if (hijosInactivos.length > 0) {
                    console.warn('‚ö†Ô∏è Algunos componentes hijos no respondieron a tiempo:', 
                        hijosInactivos.map(h => h.id).join(', '));
                    
                    // Intentar reconexi√≥n con los hijos inactivos
                    hijosInactivos.forEach(hijo => {
                        const reintentos = estadoGlobal.hijosConectados.get(hijo.id)?.reintentos || 0;
                        if (reintentos < estadoGlobal.configuracion.maxReintentosConexion) {
                            console.log(`üîÑ Intentando reconectar con ${hijo.id} (intento ${reintentos + 1})`);
                            enviarMensajeHijo(hijo.id, TIPOS_MENSAJE.SISTEMA.INICIALIZACION, {});
                            
                            // Actualizar contador de reintentos
                            estadoGlobal.hijosConectados.set(hijo.id, { 
                                ...(estadoGlobal.hijosConectados.get(hijo.id) || {}),
                                reintentos: reintentos + 1,
                                ultimoIntento: Date.now()
                            });
                        } else {
                            console.error(`‚ùå Se agotaron los intentos de conexi√≥n con ${hijo.id}`);
                            // Aqu√≠ podr√≠as notificar al usuario o tomar otra acci√≥n
                        }
                    });
                }
            }, estadoGlobal.configuracion.tiempoEsperaHijos);
            
            console.log('‚úÖ Monitoreo de componentes hijos iniciado');
        }
        
        /**
         * Verifica el estado de los componentes hijos
         */
        function verificarEstadoHijos() {
            const ahora = Date.now();
            const umbralInactividad = 60000; // 1 minuto sin actividad
            
            HIJOS_SISTEMA.forEach(hijo => {
                const ultimoMensaje = estadoGlobal.ultimoMensajeRecibido.get(hijo.id);
                const tiempoInactivo = ultimoMensaje ? ahora - ultimoMensaje : Infinity;
                
                if (tiempoInactivo > umbralInactividad) {
                    console.warn(`‚ö†Ô∏è El componente ${hijo.id} no ha enviado mensajes en ${Math.floor(tiempoInactivo/1000)} segundos`);
                    
                    // Intentar reconexi√≥n si es un componente requerido
                    if (hijo.requerido) {
                        const estadoConexion = estadoGlobal.hijosConectados.get(hijo.id) || { reintentos: 0 };
                        if (estadoConexion.reintentos < estadoGlobal.configuracion.maxReintentosConexion) {
                            console.log(`üîÑ Enviando ping a ${hijo.id}`);
                            enviarMensajeHijo(hijo.id, TIPOS_MENSAJE.SISTEMA.INICIALIZACION, {});
                        }
                    }
                }
            });
            
            // Actualizar la hora de la √∫ltima verificaci√≥n
            estadoGlobal.ultimaVerificacionHijos = ahora;
        }
        
        /**
         * Env√≠a un mensaje a un componente hijo
         * @param {string} hijoId - ID del componente hijo
         * @param {string} tipo - Tipo de mensaje
         * @param {Object} datos - Datos del mensaje
         * @returns {Promise} Promesa que se resuelve cuando se env√≠a el mensaje
         */
        function enviarMensajeHijo(hijoId, tipo, datos) {
            return new Promise((resolve, reject) => {
                try {
                    // Verificar si el hijo est√° en la lista de conocidos
                    const hijo = HIJOS_SISTEMA.find(h => h.id === hijoId);
                    if (!hijo) {
                        throw new Error(`Componente hijo desconocido: ${hijoId}`);
                    }
                    
                    // Verificar si el mensaje es compatible con el tipo de hijo
                    if (!esMensajeCompatible(hijo, tipo)) {
                        console.warn(`‚ö†Ô∏è El componente ${hijoId} no est√° configurado para manejar mensajes de tipo ${tipo}`);
                    }
                    
                    // Enviar el mensaje a trav√©s del sistema de mensajer√≠a
                    Mensajeria.enviarMensaje(hijoId, tipo, datos)
                        .then(() => {
                            // Actualizar el estado de conexi√≥n del hijo
                            estadoGlobal.hijosConectados.set(hijoId, {
                                ...(estadoGlobal.hijosConectados.get(hijoId) || {}),
                                ultimoMensajeEnviado: Date.now(),
                                conectado: true,
                                ultimoError: null
                            });
                            resolve();
                        })
                        .catch(error => {
                            console.error(`‚ùå Error al enviar mensaje a ${hijoId}:`, error);
                            
                            // Actualizar el estado de error
                            estadoGlobal.hijosConectados.set(hijoId, {
                                ...(estadoGlobal.hijosConectados.get(hijoId) || {}),
                                conectado: false,
                                ultimoError: error.message,
                                ultimoIntento: Date.now()
                            });
                            
                            reject(error);
                        });
                        
                } catch (error) {
                    console.error(`Error al enviar mensaje a ${hijoId}:`, error);
                    reject(error);
                }
            });
        }
        
        /**
         * Verifica si un mensaje es compatible con un tipo de hijo
         * @param {Object} hijo - Configuraci√≥n del hijo
         * @param {string} tipoMensaje - Tipo de mensaje a verificar
         * @returns {boolean} True si el mensaje es compatible
         */
        function esMensajeCompatible(hijo, tipoMensaje) {
            // Si el hijo no tiene un tipo definido, se asume que maneja todos los mensajes
            if (!hijo.tipo) return true;
            
            // Obtener los tipos de mensaje que el hijo deber√≠a manejar
            const tiposMensajeHijo = MENSAJES_POR_TIPO[hijo.tipo] || [];
            
            // Verificar si el tipo de mensaje est√° en la lista de mensajes que el hijo maneja
            return tiposMensajeHijo.some(tipo => tipo === tipoMensaje);
        }
        
        /**
         * Maneja la notificaci√≥n de que un hijo est√° listo
         * @param {Object} mensaje - Mensaje recibido
         * @returns {Object} Respuesta de confirmaci√≥n
         */
        function manejarHijoListo(mensaje) {
            const { origen, datos = {} } = mensaje;
            const timestamp = Date.now();
            
            try {
                // Validaci√≥n de entrada
                if (!origen) {
                    throw new Error('Mensaje sin origen');
                }
                
                console.log(`‚úÖ Hijo listo: ${origen}`, {
                    version: datos.version,
                    capacidades: datos.capacidades ? datos.capacidades.length : 0,
                    metadata: datos.metadata || {}
                });
                
                // Registrar m√©tricas
                estadoGlobal.metricas.mensajesRecibidos++;
                
                // Actualizar estado del hijo
                const estadoHijo = {
                    id: origen,
                    conectado: true,
                    ultimaConexion: timestamp,
                    ultimaSincronizacion: timestamp,
                    reintentos: 0,
                    version: datos.version || 'desconocida',
                    capacidades: Array.isArray(datos.capacidades) ? datos.capacidades : [],
                    metadata: datos.metadata || {},
                    estado: 'conectado',
                    errores: [],
                    metricas: {
                        mensajesEnviados: 0,
                        mensajesRecibidos: 1,
                        ultimaActividad: timestamp
                    }
                };
                
                // Mantener datos existentes si los hay
                const estadoAnterior = estadoGlobal.hijosConectados.get(origen) || {};
                estadoGlobal.hijosConectados.set(origen, { ...estadoAnterior, ...estadoHijo });
                
                // Notificar a otros componentes
                broadcastMensaje({
                    tipo: 'sistema:hijo_listo',
                    origen: 'sistema',
                    destino: 'todos',
                    datos: { 
                        componente: origen,
                        version: estadoHijo.version,
                        timestamp,
                        // Solo incluir metadatos p√∫blicos
                        metadata: {
                            capacidades: estadoHijo.capacidades,
                            conectado: true
                        }
                    }
                }, [origen]); // Excluir al remitente
                
                // Sincronizar estado con el nuevo hijo
                sincronizarEstadoConHijo(origen);
                
                // Respuesta de confirmaci√≥n
                return {
                    exito: true,
                    mensaje: 'Registro exitoso',
                    timestamp,
                    estado: {
                        modo: estadoGlobal.modo,
                        gpsActivo: estadoGlobal.gpsActivo,
                        paradaActual: estadoGlobal.paradaActual,
                        tramoActual: estadoGlobal.tramoActual,
                        version: estadoGlobal.version,
                        timestamp
                    },
                    config: {
                        debug: estadoGlobal.config.debug,
                        maxReintentos: estadoGlobal.config.maxReintentos,
                        tiempoEspera: estadoGlobal.config.tiempoEsperaInicial
                    }
                };
                
            } catch (error) {
                console.error(`‚ùå Error al procesar notificaci√≥n de hijo listo (${origen}):`, error);
                
                // Registrar error
                if (origen) {
                    const estadoHijo = estadoGlobal.hijosConectados.get(origen) || {
                        id: origen,
                        errores: [],
                        estado: 'error',
                        ultimoError: {
                            tipo: 'registro',
                            mensaje: error.message,
                            codigo: 'ERROR_REGISTRO',
                            timestamp: new Date().toISOString(),
                            stack: error.stack
                        }
                    };
                    
                    estadoHijo.errores = estadoHijo.errores || [];
                    estadoHijo.errores.push({
                        tipo: 'registro',
                        mensaje: error.message,
                        codigo: 'ERROR_REGISTRO',
                        timestamp: new Date().toISOString(),
                        stack: error.stack,
                        datos: datos || {}
                    });
                    
                    estadoGlobal.hijosConectados.set(origen, estadoHijo);
                }
                
                // Devolver error detallado
                return {
                    exito: false,
                    error: {
                        mensaje: error.message || 'Error desconocido',
                        codigo: 'ERROR_REGISTRO',
                        detalle: error.stack ? error.stack.split('\n')[0] : undefined
                    },
                    timestamp: Date.now(),
                    intentarNuevamente: true,
                    tiempoEspera: 5000 // 5 segundos
                };
            }
        }
        
        /**
         * Sincroniza el estado actual con un hijo espec√≠fico
         * @param {string} hijoId - ID del componente hijo
         */
        function sincronizarEstadoConHijo(hijoId) {
            const mensaje = {
                tipo: TIPOS_MENSAJE.SISTEMA.SINCRONIZAR_ESTADO,
                datos: {
                    modo: estadoGlobal.modo,
                    paradaActual: estadoGlobal.paradaActual,
                    tramoActual: estadoGlobal.tramoActual,
                    gpsActivo: estadoGlobal.gpsActivo,
                    audioReproduciendo: estadoGlobal.audioReproduciendo,
                    retoActivo: estadoGlobal.retoActivo,
                    timestamp: Date.now()
                }
            };
            
            enviarMensajeHijo(hijoId, mensaje.tipo, mensaje.datos)
                .then(() => console.log(`‚úÖ Estado sincronizado con ${hijoId}`))
                .catch(error => console.error(`‚ùå Error al sincronizar estado con ${hijoId}:`, error));
        }
        
        // ================== MAPA ==================
        /**
         * Inicializa el mapa de Leaflet
         * @returns {Promise<L.Map>} Instancia del mapa de Leaflet
         */
        async function inicializarMapa() {
            return new Promise((resolve, reject) => {
                try {
                    if (typeof L === 'undefined') {
                        throw new Error('La biblioteca Leaflet no est√° cargada correctamente');
                    }
                    console.log('üåç Iniciando inicializaci√≥n del mapa...');
                    
                    // Coordenadas por defecto (centro de Valencia)
                    const valenciaCoords = [39.44859, -0.37489];
                    const mapContainer = document.getElementById('mapa');
                    
                    if (!mapContainer) {
                        throw new Error('No se encontr√≥ el contenedor del mapa');
                    }
                    
                    mapContainer.style.display = 'block';
                    
                    // Crear instancia del mapa
                    const mapa = L.map('mapa', {
                        center: valenciaCoords,
                        zoom: 14,
                        zoomControl: false,
                        scrollWheelZoom: true,
                        doubleClickZoom: true,
                        boxZoom: true,
                        rotate: false,
                        touchRotate: false,
                        bearing: 0,
                        preferCanvas: true
                    });
                    
                    // A√±adir capa base de OpenStreetMap
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19,
                        attribution: '¬© OpenStreetMap contributors',
                        detectRetina: true
                    }).addTo(mapa);
                    
                    // A√±adir control de zoom personalizado
                    L.control.zoom({
                        position: 'topright'
                    }).addTo(mapa);
                    
                    // Manejar la carga del mapa
                    mapa.whenReady(() => {
                        console.log('‚úÖ Mapa cargado correctamente');
                        
                        // Forzar un redimensionamiento para asegurar que el mapa se renderice correctamente
                        setTimeout(() => {
                            mapa.invalidateSize({ animate: true });
                            
                            try {
                                // Inicializar coordenadas y crear marcadores
                                if (typeof inicializarCoordenadasParadas === 'function') {
                                    inicializarCoordenadasParadas();
                                }
                                
                                if (typeof crearMarcadoresIniciales === 'function') {
                                    crearMarcadoresIniciales();
                                }
                                
                                resolve(mapa);
                            } catch (error) {
                                console.error('Error durante la inicializaci√≥n del mapa:', error);
                                reject(error);
                            }
                            
                        }, 100);
                    });
                    
                    // Manejar errores del mapa
                    mapa.on('error', (error) => {
                        const errorMsg = 'Error en el mapa: ' + (error.message || 'Error desconocido');
                        console.error('‚ùå', errorMsg, error);
                        
                        if (typeof mostrarErrorEnInterfaz === 'function') {
                            mostrarErrorEnInterfaz(errorMsg);
                        }
                        
                        reject(new Error(errorMsg));
                    });
                    
                } catch (error) {
                    console.error('‚ùå Error al inicializar el mapa:', error);
                    const errorMsg = 'Error al cargar el mapa: ' + (error.message || 'Error desconocido');
                    
                    if (typeof mostrarErrorEnInterfaz === 'function') {
                        mostrarErrorEnInterfaz(errorMsg, () => {
                            try {
                                return inicializarMapa();
                            } catch (retryError) {
                                console.error('Error al reintentar la inicializaci√≥n del mapa:', retryError);
                                return null;
                            }
                        });
                    }
                    
                    reject(new Error(errorMsg));
                }
            });
        }
        
        // ================== INICIALIZACI√ìN ==================
        async function inicializar() {
            try {
                console.log('üöÄ Inicializando sistema padre...');
                
                // Inicializar el estado global
                estadoGlobal = {
                    modo: 'casa',
                    gpsActivo: false,
                    paradaActual: 'P-0',
                    tramoActual: 'TR-1',
                    hijosListos: new Set(),
                    hijosConectados: new Map(),
                    ultimoMensajeRecibido: new Map(),
                    mapa: null,
                    audioReproduciendo: false,
                    retoActivo: null,
                    inicializado: false,
                    marcadoresParadas: new Map(),
                    marcadoresUsuario: new Map(),
                    rutasActivas: new Map(),
                    errores: [],
                    ultimaSincronizacion: null,
                    configuracion: {
                        tiempoEsperaHijos: 10000,
                        intervaloMonitoreo: 30000,
                        maxReintentosConexion: 3
                    }
                };
                
                // 1. Inicializar el mapa
                console.log('üåç Inicializando mapa...');
                estadoGlobal.mapa = await inicializarMapa();
                
                if (!estadoGlobal.mapa) {
                    throw new Error('No se pudo inicializar el mapa');
                }
                
                // Notificar a los hijos que el mapa est√° listo
                broadcastMensaje({
                    tipo: 'sistema:mapa_listo',
                    datos: {
                        mensaje: 'El mapa se ha inicializado correctamente',
                        timestamp: Date.now()
                    }
                });
                
                // 4. Inicializar manejadores de eventos
                console.log('üñ±Ô∏è Inicializando manejadores de eventos...');
                inicializarManejadoresEventos();
                
                // 5. Inicializar la mensajer√≠a
                console.log('üì° Inicializando sistema de mensajer√≠a...');
                await inicializarMensajeria();
                
                // 6. Registrar manejadores de mensajes
                console.log('üì© Registrando manejadores de mensajes...');
                registrarManejadores();
                
                // 7. Inicializar monitoreo de componentes hijos
                console.log('üë• Inicializando monitoreo de componentes hijos...');
                inicializarMonitoreoHijos();
                
                // 8. Inicializar componentes hijos
                console.log('üîÑ Inicializando componentes hijos...');
                await inicializarComponentesHijos();
                
                // 9. Centrar en la primera parada
                const primeraParada = AVENTURA_PARADAS.find(p => p.tipo === 'inicio');
                if (primeraParada) {
                    centrarEnParada(primeraParada.parada_id, 16);
                }
                
                // 10. Marcar como inicializado
                estadoGlobal.inicializado = true;
                estadoGlobal.ultimaSincronizacion = new Date().toISOString();
                
                console.log('‚úÖ Sistema padre inicializado correctamente');
                
                // Notificar a los hijos que el sistema est√° listo
                broadcastMensaje({
                    tipo: TIPOS_MENSAJE.SISTEMA.INICIALIZACION,
                    datos: {
                        estado: 'listo',
                        timestamp: Date.now(),
                        version: '1.0.0'
                    }
                });
                
            } catch (error) {
                console.error('‚ùå Error al inicializar el sistema padre:', error);
                mostrarErrorEnInterfaz(
                    'Error al inicializar la aplicaci√≥n: ' + (error.message || 'Error desconocido'),
                    () => {
                        // Intentar reiniciar la inicializaci√≥n
                        setTimeout(inicializar, 1000);
                    }
                );
            }
        }
        
        /**
         * Inicializa los componentes hijos de forma secuencial con reintentos
         */
        async function inicializarComponentesHijos() {
            console.log('üöÄ Inicializando componentes hijos...');
            
            // Inicializar cada componente hijo con manejo de errores robusto
            for (const hijo of HIJOS_SISTEMA) {
                try {
                    console.log(`üîÑ Inicializando ${hijo.id}...`);
                    
                    // Configurar el estado inicial del hijo
                    estadoGlobal.hijosConectados.set(hijo.id, {
                        conectado: false,
                        ultimoIntento: Date.now(),
                        reintentos: 0,
                        version: 'desconocida',
                        capacidades: [],
                        errores: []
                    });
                    
                    // Intentar inicializar con reintentos
                    await intentarInicializarHijo(hijo);
                    
                } catch (error) {
                    console.error(`‚ùå Error cr√≠tico al inicializar ${hijo.id}:`, error);
                    // Registrar el error pero continuar con los dem√°s componentes
                    const estadoHijo = estadoGlobal.hijosConectados.get(hijo.id) || {};
                    estadoHijo.errores = estadoHijo.errores || [];
                    estadoHijo.errores.push({
                        tipo: 'inicializacion',
                        mensaje: error.message,
                        timestamp: new Date().toISOString()
                    });
                    estadoGlobal.hijosConectados.set(hijo.id, estadoHijo);
                }
            }
            
            console.log('‚úÖ Proceso de inicializaci√≥n de componentes hijos completado');
            
            // Verificar estado de inicializaci√≥n
            const hijosFallidos = Array.from(estadoGlobal.hijosConectados.entries())
                .filter(([_, estado]) => !estado.conectado)
                .map(([id]) => id);
                
            if (hijosFallidos.length > 0) {
                console.warn(`‚ö†Ô∏è Algunos componentes no se inicializaron correctamente: ${hijosFallidos.join(', ')}`);
            }
            
            return {
                exitoso: true,
                total: HIJOS_SISTEMA.length,
                exitosos: HIJOS_SISTEMA.length - hijosFallidos.length,
                fallidos: hijosFallidos.length,
                idsFallidos: hijosFallidos
            };
            
            /**
             * Intenta inicializar un componente hijo con reintentos
             */
            async function intentarInicializarHijo(hijo, intento = 1) {
                const maxReintentos = 3;
                const tiempoEspera = 1000 * intento; // Espera creciente
                
                try {
                    // Enviar mensaje de inicializaci√≥n al hijo
                    await enviarMensajeHijo(hijo.id, 'sistema:inicializacion', {
                        configuracion: {
                            modo: estadoGlobal.modo,
                            version: '1.0.0',
                            timestamp: Date.now(),
                            maxReintentos,
                            tiempoEspera: 5000 // Tiempo de espera para la respuesta
                        }
                    });
                    
                    console.log(`‚úÖ Mensaje de inicializaci√≥n enviado a ${hijo.id}`);
                    
                    // Actualizar estado del hijo
                    const estadoHijo = estadoGlobal.hijosConectados.get(hijo.id);
                    estadoHijo.ultimoIntento = Date.now();
                    estadoHijo.reintentos = intento;
                    estadoGlobal.hijosConectados.set(hijo.id, estadoHijo);
                    
                } catch (error) {
                    if (intento < maxReintentos) {
                        console.warn(`‚ö†Ô∏è Reintentando (${intento}/${maxReintentos}) inicializaci√≥n de ${hijo.id}...`);
                        await new Promise(resolve => setTimeout(resolve, tiempoEspera));
                        return intentarInicializarHijo(hijo, intento + 1);
                    }
                    
                    // Si llegamos aqu√≠, agotamos los reintentos
                    throw new Error(`No se pudo inicializar ${hijo.id} despu√©s de ${maxReintentos} intentos: ${error.message}`);
                }
            }
        }

        // ================== MANEJADORES DE MENSAJES MEJORADOS ==================
        const manejadoresMensajes = {
            // Sistema
            'sistema:listo': manejarHijoListo,
            'sistema:error': manejarErrorDeHijo,
            'sistema:confirmacion': manejarConfirmacion,
            'sistema:ping': manejarPing,
            
            // Datos
            'datos:solicitar_parada': manejarSolicitudDatos,
            'datos:solicitar_estado': manejarSolicitudEstado,
            'datos:actualizar': manejarActualizacionDatos,
            
            // Navegaci√≥n
            'navegacion:cambio_parada': manejarCambioParada,
            'navegacion:llegada_detectada': manejarLlegadaDestino,
            'navegacion:solicitar_destino': manejarSolicitudDestino,
            'navegacion:actualizar_posicion': manejarActualizacionPosicion,
            
            // Audio
            'audio:finalizado': manejarAudioFinalizado,
            'audio:estado': manejarEstadoAudio,
            'audio:error': manejarErrorAudio,
            
            // Retos
            'retos:completado': manejarRetoCompletado,
            'retos:abrir': manejarAbrirReto,
            'retos:estado': manejarEstadoReto,
            
            // GPS
            'gps:estado': manejarEstadoGPS,
            'gps:posicion': manejarPosicionGPS,
            
            // Mensajes espec√≠ficos de componentes
            'hijo5:notificar_punto': manejarNotificacionPunto,
            'hijo5:actualizar_estado': manejarActualizacionEstadoHijo
        };

        /**
         * Registra todos los manejadores de mensajes
         */
        function registrarManejadores() {
            try {
                console.log('üìù Registrando manejadores de mensajes...');
                
                // Registrar todos los manejadores definidos
                Object.entries(manejadoresMensajes).forEach(([tipo, manejador]) => {
                    if (typeof manejador === 'function') {
                        Mensajeria.registrarControlador(tipo, manejador);
                    } else {
                        console.warn(`‚ö†Ô∏è Manejador no encontrado para el tipo: ${tipo}`);
                    }
                });

                console.log(`‚úÖ ${Object.keys(manejadoresMensajes).length} manejadores registrados correctamente`);
                return true;
                
            } catch (error) {
                console.error('‚ùå Error al registrar manejadores:', error);
                throw error; // Relanzar para manejo de errores superior
            }
        }

        // ================== FUNCIONES PRINCIPALES ==================
        
        /**
         * Obtiene los datos de una parada por su ID
         * @param {string} paradaId - ID de la parada
         * @returns {Object|null} Datos de la parada o null si no se encuentra
         */
        function obtenerDatosParada(paradaId) {
            try {
                console.log(`üìç Obteniendo datos para parada: ${paradaId}`);
                
                // Buscar la parada en el array AVENTURA_PARADAS
                const parada = AVENTURA_PARADAS.find(p => p.parada_id === paradaId);
                
                if (!parada) {
                    console.warn(`No se encontr√≥ la parada ${paradaId}`);
                    return null;
                }
                
                // Obtener coordenadas de la parada
                let coordenadas = null;
                if (COORDENADAS_PARADAS && COORDENADAS_PARADAS.get) {
                    coordenadas = COORDENADAS_PARADAS.get(paradaId);
                }
                
                // Construir objeto de datos de la parada
                return {
                    id: paradaId,
                    tipo: parada.tipo || 'parada',
                    nombre: `Parada ${paradaId}`,
                    descripcion: `Descripci√≥n de la parada ${paradaId}`,
                    coordenadas: coordenadas,
                    audio: parada.audio_id ? `audios/${parada.audio_id}.mp3` : null,
                    reto: parada.reto_id ? { id: parada.reto_id, completado: false } : null,
                    propiedadesAdicionales: {
                        visitada: false,
                        timestamp: Date.now()
                    }
                };
                
            } catch (error) {
                console.error(`Error al obtener datos de la parada ${paradaId}:`, error);
                return null;
            }
        }

        /**
         * Inicializa el mapa de Leaflet con todas las configuraciones necesarias
         * @returns {L.Map} Instancia del mapa de Leaflet
         */
        function inicializarMapa() {
            try {
                console.log('üåç Iniciando inicializaci√≥n del mapa...');
                
                // Verificar que Leaflet est√© cargado
                if (typeof L === 'undefined') {
                    throw new Error('La biblioteca Leaflet no est√° cargada correctamente');
                }
                
                // Coordenadas por defecto (centro de Valencia)
                const valenciaCoords = [39.44859, -0.37489];
                const mapContainer = document.getElementById('mapa');
                
                // Verificar que el contenedor del mapa existe
                if (!mapContainer) {
                    throw new Error('No se encontr√≥ el contenedor del mapa');
                }
                
                // Asegurarse de que el contenedor sea visible
                mapContainer.style.display = 'block';
                
                // Crear instancia del mapa con configuraci√≥n avanzada
                const mapa = L.map('mapa', {
                    center: valenciaCoords,
                    zoom: 16,
                    zoomControl: false, // Lo a√±adiremos manualmente despu√©s
                    scrollWheelZoom: true,
                    doubleClickZoom: true,
                    boxZoom: true,
                    rotate: false,
                    touchRotate: false,
                    bearing: 0,
                    preferCanvas: true, // Mejor rendimiento para muchos marcadores
                    attributionControl: false // Lo a√±adiremos manualmente
                });
                
                // A√±adir capa base de OpenStreetMap con configuraci√≥n mejorada
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '¬© OpenStreetMap contributors',
                    detectRetina: true // Mejora la calidad en pantallas Retina
                }).addTo(mapa);
                
                // A√±adir control de zoom personalizado
                L.control.zoom({
                    position: 'topright',
                    zoomInTitle: 'Acercar',
                    zoomOutTitle: 'Alejar'
                }).addTo(mapa);
                
                // A√±adir control de atribuci√≥n
                L.control.attribution({
                    position: 'bottomright',
                    prefix: '<a href="https://leafletjs.com/" title="A JavaScript library for interactive maps">Leaflet</a> | '
                }).addTo(mapa);
                
                // Manejar el evento de carga del mapa
                mapa.whenReady(() => {
                    console.log('‚úÖ Mapa cargado correctamente');
                    
                    // Forzar un redimensionamiento para asegurar que el mapa se renderice correctamente
                    setTimeout(() => {
                        mapa.invalidateSize({ animate: true });
                        
                        // Inicializar coordenadas y crear marcadores
                        inicializarCoordenadasParadas();
                        crearMarcadoresIniciales();
                        
                    }, 100);
                });
                
                // Manejar errores del mapa
                mapa.on('error', (error) => {
                    console.error('‚ùå Error en el mapa:', error);
                    mostrarErrorEnInterfaz('Error en el mapa: ' + (error.message || 'Error desconocido'));
                });
                
                // Manejar redimensionamiento de la ventana
                window.addEventListener('resize', () => {
                    mapa.invalidateSize({ animate: true });
                });
                
                // Almacenar referencia al mapa en el estado global
                estadoGlobal.mapa = mapa;
                return mapa;
                
            } catch (error) {
                console.error('‚ùå Error al inicializar el mapa:', error);
                mostrarErrorEnInterfaz(
                    'Error al cargar el mapa: ' + (error.message || 'Error desconocido'),
                    () => inicializarMapa() // Proporcionar opci√≥n de reintentar
                );
                return null;
            }
        }
        
        /**
         * Crea marcadores para todas las paradas en el mapa
         */
        function crearMarcadoresParadas() {
            if (!estadoGlobal.mapa) {
                console.warn('No se pueden crear marcadores: el mapa no est√° inicializado');
                return;
            }
            
            // Limpiar marcadores existentes
            estadoGlobal.marcadoresParadas.clear();
            
            // Crear un grupo de capas para los marcadores
            const grupoMarcadores = L.layerGroup().addTo(estadoGlobal.mapa);
            
            // Recorrer todas las paradas y crear marcadores
            AVENTURA_PARADAS.forEach(parada => {
                if (parada.tipo !== 'parada' && parada.tipo !== 'inicio') {
                    return; // Solo procesar paradas e inicio, no tramos
                }
                
                const paradaId = parada.parada_id;
                const coords = COORDENADAS_PARADAS.get(paradaId);
                
                if (!coords) {
                    console.warn(`No se encontraron coordenadas para la parada ${paradaId}`);
                    return;
                }
                
                // Crear icono personalizado seg√∫n el tipo de parada
                const icono = L.divIcon({
                    className: `marcador ${parada.tipo === 'inicio' ? 'marcador-inicio' : 'marcador-parada'}`,
                    html: `<div class="marcador-contenido">${paradaId.replace('P-', '')}</div>`,
                    iconSize: [32, 32],
                    iconAnchor: [16, 32],
                    popupAnchor: [0, -32]
                });
                
                // Crear marcador
                const marcador = L.marker(coords, { icon: icono })
                    .addTo(grupoMarcadores)
                    .bindPopup(`<b>${paradaId}</b><br>${parada.tipo === 'inicio' ? 'Punto de inicio' : 'Parada'}`);
                
                // Almacenar referencia al marcador
                estadoGlobal.marcadoresParadas.set(paradaId, marcador);
                
                // Manejar clic en el marcador
                marcador.on('click', () => {
                    console.log(`Marcador de ${paradaId} clickeado`);
                    // Podemos agregar l√≥gica adicional aqu√≠, como centrar el mapa en el marcador
                    estadoGlobal.mapa.setView(coords, 18);
                });
            });
            
            console.log(`‚úÖ ${estadoGlobal.marcadoresParadas.size} marcadores creados`);
        }
        
        /**
         * Maneja las solicitudes de datos de paradas
         */
        function manejarSolicitudDatos(mensaje) {
            try {
                const { tipo, datos, origen } = mensaje;
                console.log(`Solicitud de datos recibida de ${origen}:`, tipo, datos);
                
                if (tipo === TIPOS_MENSAJE.DATOS.SOLICITAR_PARADA) {
                    const { paradaId } = datos;
                    const datosParada = obtenerDatosParada(paradaId);
                    
                    if (datosParada) {
                        return { 
                            exito: true, 
                            datos: datosParada 
                        };
                    } else {
                        return { 
                            exito: false, 
                            error: `No se encontr√≥ la parada ${paradaId}` 
                        };
                    }
                }
                
                return { exito: false, error: 'Tipo de solicitud no reconocido' };
                
            } catch (error) {
                console.error('Error manejando solicitud de datos:', error);
                return { 
                    exito: false, 
                    error: error.message 
                };
            }
        }

        // ================== MANEJO DE MARCADORES ==================
        
        /**
         * Inicializa los marcadores en el mapa
         */
        function inicializarMarcadores() {
            // Aqu√≠ se inicializar√°n los marcadores de las paradas
            console.log('Inicializando marcadores...');
            // Implementaci√≥n pendiente
        }

        // ================== MANEJADORES DE EVENTOS ==================
        
        /**
         * Maneja la notificaci√≥n de que un hijo est√° listo
         * @param {Object} mensaje - Mensaje recibido
         */
        function manejarHijoListo(mensaje) {
            const { origen } = mensaje;
            console.log(`‚úÖ Hijo listo: ${origen}`);
            
            // Registrar al hijo como listo
            estadoGlobal.hijosListos.add(origen);
            
            // Notificar a todos los hijos que un nuevo componente est√° listo
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.SISTEMA.HIJO_LISTO,
                datos: { componente: origen }
            }, [origen]); // Excluir al remitente
            
            // Si es el primer hijo en conectarse, sincronizar estado
            if (estadoGlobal.hijosListos.size === 1) {
                sincronizarEstadoConHijos();
            }
        }

        /**
         * Maneja errores reportados por los hijos
         * @param {Object} mensaje - Mensaje de error
         */
        function manejarErrorDeHijo(mensaje) {
            const { origen, datos } = mensaje;
            console.error(`‚ùå Error reportado por ${origen}:`, datos);
            
            // Registrar el error en el estado global
            if (!estadoGlobal.errores) estadoGlobal.errores = [];
            estadoGlobal.errores.push({
                origen,
                timestamp: new Date().toISOString(),
                error: datos.error || 'Error desconocido'
            });
            
            // Opcional: Notificar a otros componentes sobre el error
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.SISTEMA.ERROR,
                datos: { 
                    origen,
                    mensaje: 'Se ha producido un error en un componente',
                    error: datos.error
                }
            }, [origen]);
        }

        /**
         * Maneja el cambio de parada solicitado por un hijo
         * @param {Object} mensaje - Mensaje de cambio de parada
         */
        function manejarCambioParada(mensaje) {
            const { origen, datos } = mensaje;
            const { paradaId } = datos;
            
            console.log(`üîÑ Cambio de parada solicitado por ${origen}: ${paradaId}`);
            
            // Verificar si la parada existe
            const parada = AVENTURA_PARADAS.find(p => p.parada_id === paradaId || p.padreid === paradaId);
            if (!parada) {
                console.warn(`Parada ${paradaId} no encontrada`);
                return { exito: false, error: 'Parada no encontrada' };
            }
            
            // Actualizar estado global
            estadoGlobal.paradaActual = parada.parada_id || parada.padreid;
            
            // Notificar a todos los hijos sobre el cambio
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.NAVEGACION.CAMBIO_PARADA,
                datos: { 
                    paradaId: estadoGlobal.paradaActual,
                    origen: 'sistema',
                    timestamp: Date.now()
                }
            });
            
            // Si hay un reto asociado, notificarlo
            if (parada.reto_id) {
                broadcastMensaje({
                    tipo: TIPOS_MENSAJE.RETOS.ABRIR,
                    datos: { retoId: parada.reto_id }
                });
            }
            
            return { exito: true };
        }

        /**
         * Maneja la notificaci√≥n de llegada a un destino
         * @param {Object} mensaje - Mensaje de llegada
         */
        function manejarLlegadaDestino(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`üèÅ Llegada a destino reportada por ${origen}:`, datos);
            
            // Actualizar estado
            estadoGlobal.ultimaLlegada = {
                timestamp: Date.now(),
                paradaId: datos.paradaId,
                origen
            };
            
            // Notificar a otros componentes
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.NAVEGACION.LLEGADA_CONFIRMADA,
                datos: {
                    paradaId: datos.paradaId,
                    timestamp: Date.now()
                }
            }, [origen]);
        }

        /**
         * Maneja la solicitud de informaci√≥n de destino
         * @param {Object} mensaje - Mensaje de solicitud
         */
        function manejarSolicitudDestino(mensaje) {
            const { origen } = mensaje;
            console.log(`‚ùì Solicitud de destino desde ${origen}`);
            
            return {
                exito: true,
                datos: {
                    paradaActual: estadoGlobal.paradaActual,
                    modo: estadoGlobal.modo,
                    timestamp: Date.now()
                }
            };
        }

        /**
         * Maneja la notificaci√≥n de finalizaci√≥n de audio
         * @param {Object} mensaje - Mensaje de finalizaci√≥n
         */
        function manejarAudioFinalizado(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`üîä Audio finalizado en ${origen}:`, datos.audioId);
            
            // Actualizar estado de reproducci√≥n
            estadoGlobal.audioReproduciendo = false;
            
            // Notificar a otros componentes
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.AUDIO.FINALIZADO,
                datos: { audioId: datos.audioId }
            }, [origen]);
        }

        /**
         * Maneja actualizaciones de estado de audio
         * @param {Object} mensaje - Mensaje de estado
         */
        function manejarEstadoAudio(mensaje) {
            const { origen, datos } = mensaje;
            estadoGlobal.audioReproduciendo = datos.reproduciendo;
            console.log(`üéµ Estado de audio actualizado por ${origen}:`, 
                datos.reproduciendo ? 'Reproduciendo' : 'Detenido');
        }

        /**
         * Maneja la finalizaci√≥n de un reto
         * @param {Object} mensaje - Mensaje de reto completado
         */
        function manejarRetoCompletado(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`üèÜ Reto completado por ${origen}:`, datos.retoId);
            
            // Actualizar estado de retos completados
            if (!estadoGlobal.retosCompletados) {
                estadoGlobal.retosCompletados = new Set();
            }
            estadoGlobal.retosCompletados.add(datos.retoId);
            
            // Notificar a otros componentes
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.RETOS.COMPLETADO,
                datos: {
                    retoId: datos.retoId,
                    timestamp: Date.now()
                }
            });
        }

        /**
         * Maneja la solicitud de abrir un reto
         * @param {Object} mensaje - Mensaje de apertura de reto
         */
        function manejarAbrirReto(mensaje) {
            const { origen, datos } = mensaje;
            console.log(`üéÆ Abriendo reto solicitado por ${origen}:`, datos.retoId);
            
            // Verificar si el reto est√° disponible
            const paradaActual = AVENTURA_PARADAS.find(p => 
                p.parada_id === estadoGlobal.paradaActual || 
                p.padreid === estadoGlobal.paradaActual
            );
            
            if (!paradaActual || paradaActual.reto_id !== datos.retoId) {
                console.warn(`Intento de abrir reto no v√°lido: ${datos.retoId}`);
                return { exito: false, error: 'Reto no disponible en la parada actual' };
            }
            
            // Notificar a todos los componentes para abrir el reto
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.RETOS.ABRIR,
                datos: { 
                    retoId: datos.retoId,
                    origen: 'sistema',
                    timestamp: Date.now()
                }
            });
            
            return { exito: true };
        }

        /**
         * Maneja actualizaciones de estado del GPS
         * @param {Object} mensaje - Mensaje de estado del GPS
         */
        function manejarEstadoGPS(mensaje) {
            const { origen, datos } = mensaje;
            estadoGlobal.gpsActivo = datos.activo;
            console.log(`üìç Estado GPS actualizado por ${origen}:`, 
                datos.activo ? 'Activo' : 'Inactivo');
            
            // Notificar a otros componentes sobre el cambio de estado del GPS
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.GPS.ESTADO,
                datos: { 
                    activo: datos.activo,
                    precision: datos.precision,
                    timestamp: Date.now()
                }
            }, [origen]);
        }

        /**
         * Transmite un mensaje a todos los hijos excepto a los excluidos
         * @param {Object} mensaje - Mensaje a transmitir
         * @param {Array} [excluir=[]] - Lista de IDs de componentes a excluir
         */
        function broadcastMensaje(mensaje, excluir = []) {
            if (!mensaje.tipo) {
                console.error('Intento de broadcast sin tipo de mensaje');
                return;
            }
            
            HIJOS_SISTEMA.forEach(hijo => {
                if (!excluir.includes(hijo)) {
                    Mensajeria.enviarMensaje(hijo, mensaje.tipo, mensaje.datos || {})
                        .catch(error => {
                            console.error(`Error enviando mensaje a ${hijo}:`, error);
                        });
                }
            });
        }

        /**
         * Sincroniza el estado actual con todos los hijos
         */
        function sincronizarEstadoConHijos() {
            console.log('üîÑ Sincronizando estado con todos los hijos...');
            
            broadcastMensaje({
                tipo: TIPOS_MENSAJE.SISTEMA.SINCRONIZAR_ESTADO,
                datos: {
                    modo: estadoGlobal.modo,
                    paradaActual: estadoGlobal.paradaActual,
                    gpsActivo: estadoGlobal.gpsActivo,
                    audioReproduciendo: estadoGlobal.audioReproduciendo,
                    retosCompletados: Array.from(estadoGlobal.retosCompletados || []),
                    timestamp: Date.now()
                }
            });
        }

        // ================== INICIALIZACI√ìN DE LA APLICACI√ìN ==================
        
        // Mostrar indicador de carga
        const loadingEl = document.createElement('div');
        loadingEl.className = 'loading';
        loadingEl.textContent = 'Inicializando aplicaci√≥n...';
        document.body.appendChild(loadingEl);

        // Funci√≥n para manejar errores de inicializaci√≥n
        function manejarErrorInicializacion(error) {
            console.error('Error de inicializaci√≥n:', error);
            loadingEl.textContent = `Error: ${error.message || 'Error desconocido'}`;
            loadingEl.style.backgroundColor = '#f44336';
            
            // A√±adir bot√≥n de reintento
            const reintentarBtn = document.createElement('button');
            reintentarBtn.textContent = 'Reintentar';
            reintentarBtn.style.marginTop = '10px';
            reintentarBtn.style.padding = '5px 10px';
            reintentarBtn.onclick = () => {
                loadingEl.textContent = 'Reintentando...';
                setTimeout(() => inicializar().catch(manejarErrorInicializacion), 1000);
            };
            loadingEl.appendChild(document.createElement('br'));
            loadingEl.appendChild(reintentarBtn);
        }

        // Iniciar la aplicaci√≥n cuando el DOM est√© listo
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ Iniciando aplicaci√≥n...');
            
            try {
                await inicializar();
                console.log('‚úÖ Aplicaci√≥n iniciada correctamente');
            } catch (error) {
                console.error('‚ùå Error al iniciar la aplicaci√≥n:', error);
                
                if (typeof mostrarErrorEnInterfaz === 'function') {
                    mostrarErrorEnInterfaz(
                        'Error al iniciar la aplicaci√≥n: ' + (error.message || 'Error desconocido'),
                        () => location.reload()
                    );
                }
            }
        });

    </script>
</body>
</html>
