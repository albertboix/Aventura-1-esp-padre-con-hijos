<!DOCTYPE html>
<html lang="es">
<head>
    <script type="module">
      // ================== DECLARACIONES DE CONSTANTES ==================
      const IFRAME_ID = 'hijo4';
      
      // Configuración de reintentos para mensajes importantes
      const CONFIG_REINTENTOS = {
        intentosMaximos: 3,
        tiempoEspera: 1000,
        factor: 2
      };
      
      // Estado global de la aplicación
      const estadoApp = {
        modo: 'aventura',
        retoActual: null,
        controlesHabilitados: true,
        retoMostrado: false,
        ultimoError: null
      };

      // ================== DECLARACIONES DE FUNCIONES ==================

      // ================== FUNCIONES AUXILIARES ==================

      /**
       * Habilita o deshabilita los controles de la interfaz
       * @param {boolean} habilitar - true para habilitar, false para deshabilitar
       * @param {string} [modo='aventura'] - Modo actual ('casa' o 'aventura')
       * @param {string} [motivo='desconocido'] - Razón del cambio de estado
       */
      function manejarEstadoControles(habilitar, modo = 'aventura', motivo = 'desconocido') {
        console.log(`[${IFRAME_ID}] ${habilitar ? 'Habilitando' : 'Deshabilitando'} controles en modo ${modo}. Motivo: ${motivo}`);
        
        estadoApp.controlesHabilitados = habilitar;
        const controles = document.querySelectorAll('.control-reto');
        const overlay = document.getElementById('overlay-deshabilitado');
        const motivoElement = document.getElementById('motivo-deshabilitado');
        
        // Actualizar estado de los controles
        controles.forEach(control => {
          control.disabled = !habilitar;
          control.style.opacity = habilitar ? '1' : '0.5';
          control.style.pointerEvents = habilitar ? 'auto' : 'none';
        });
        
        // Actualizar overlay de deshabilitado
        if (overlay) {
          if (habilitar) {
            overlay.classList.remove('mostrar');
          } else if (motivoElement) {
            motivoElement.textContent = obtenerMensajeMotivo(motivo);
            overlay.classList.add('mostrar');
          }
        }
        
        console.log(`[${IFRAME_ID}] Controles ${habilitar ? 'habilitados' : 'deshabilitados'}`);
        return habilitar;
      }
      
      // Funciones de conveniencia para compatibilidad
      // Nota: Estas funciones están definidas más abajo en el código
      
      function obtenerMensajeMotivo(motivo) {
        const mensajes = {
          'modo_casa': 'Los retos están deshabilitados en modo casa',
          'modo_aventura': 'Esperando a que comience la aventura',
          'reto_en_progreso': 'Esperando a que se complete el reto actual',
          'desconocido': 'Los controles están temporalmente deshabilitados'
        };
        return mensajes[motivo] || mensajes['desconocido'];
      }
      
      // ================== SISTEMA DE MENSAJERÍA ==================

      /**
       * Envía un mensaje al iframe padre usando el sistema de mensajería centralizado
       * @param {string} tipo - Tipo de mensaje (ej: 'sistema_estado', 'puzzle_mostrado', etc.)
       * @param {Object} [datos={}] - Datos adicionales del mensaje
       * @param {Object} [opciones] - Opciones adicionales
       * @param {number} [opciones.reintentos=3] - Número de reintentos en caso de fallo
       * @param {boolean} [opciones.esencial=true] - Si es true, se reintentará en caso de fallo
       * @returns {Promise<Object>} Promesa que se resuelve con la respuesta del padre
       */
      async function enviarMensajeAlPadre(tipo, datos = {}, { reintentos = 3, esencial = true } = {}) {
        if (!window.Mensajeria) {
          const error = new Error('Mensajería no disponible');
          console.error(`[${IFRAME_ID}] ${error.message}`, { tipo, datos });
          if (esencial) throw error;
          return Promise.resolve();
        }
        
        const mensaje = {
          tipo: `reto_${tipo}`.replace(/^reto_reto_/, 'reto_'), // Evitar duplicados
          datos: {
            ...datos,
            timestamp: new Date().toISOString(),
            origen: IFRAME_ID,
            retoId: estadoApp.retoActual?.id
          }
        };
        
        console.log(`[${IFRAME_ID}] Enviando mensaje al padre:`, mensaje);
        
        try {
          const respuesta = await window.Mensajeria.enviarMensajeConReintenos(
            'padre',
            mensaje.tipo,
            mensaje.datos,
            { intentosMaximos: reintentos, tiempoEspera: 1000 }
          );
          
          console.log(`[${IFRAME_ID}] Respuesta del padre recibida:`, respuesta);
          return respuesta;
          
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al enviar mensaje al padre:`, error, { tipo, datos });
          if (esencial) throw error;
          return null;
        }
      }
      
      /**
       * Notifica un error al iframe padre
       * @param {string} tipo - Tipo de error
       * @param {Object} [detalles={}] - Detalles adicionales del error
       * @param {Error} [error] - Objeto de error opcional
       * @returns {Promise<void>}
       */
      async function notificarError(tipo, detalles = {}, error = null) {
        const errorInfo = {
          tipo,
          ...detalles,
          mensaje: error?.message || detalles.mensaje || 'Error desconocido',
          stack: error?.stack,
          timestamp: new Date().toISOString()
        };
        
        console.error(`[${IFRAME_ID}] Notificando error:`, errorInfo);
        
        try {
          return await enviarMensajeAlPadre('error', errorInfo, { esencial: false });
        } catch (e) {
          console.error(`[${IFRAME_ID}] Error al notificar error:`, e);
          console.error(`[${IFRAME_ID}] Error original:`, errorInfo);
          return null;
        }
      }
      
      // Alias para compatibilidad
      const notificarEstado = enviarMensajeAlPadre;

      // ================== CONFIGURACIÓN DE EVENTOS ==================

/**
 * Configura los manejadores de eventos del DOM
 */
function configurarManejadoresEventos() {
  // Configurar botón de enviar
  const btnEnviar = document.getElementById('btnEnviar');
  if (btnEnviar) {
    btnEnviar.addEventListener('click', verificar);
  }
  
  // Configurar botón de mostrar respuesta
  const btnMostrarRespuesta = document.getElementById('btnMostrarRespuesta');
  if (btnMostrarRespuesta) {
    btnMostrarRespuesta.addEventListener('click', () => {
      const reto = retosAventura1Es.find(r => r.id === estadoApp.retoActual?.id);
      if (reto) {
        const respuesta = Array.isArray(reto.correctas) 
          ? reto.correctas.join(', ') 
          : String(reto.correctas);
        
        const divRespuesta = document.getElementById('respuestaCorrectaTexto');
        if (divRespuesta) {
          divRespuesta.textContent = `Respuesta correcta: ${respuesta}`;
          divRespuesta.style.display = 'block';
        }
      }
    });
  }
  
  // Configurar botón de continuar
  const btnContinueReto = document.getElementById('btnContinueReto');
  if (btnContinueReto) {
    btnContinueReto.addEventListener('click', () => {
      enviarMensajeAlPadre('continuar', { retoId: estadoApp.retoActual?.id });
    });
  }
}

      // ================== INICIALIZACIÓN ==================

      /**
       * Maneja la inicialización del iframe
       * @param {Object} mensaje - Mensaje de inicialización
       * @returns {Promise<Object>} Respuesta de inicialización
       */
      async function manejarInicializacion(mensaje) {
        const ID_TRANSACCION = `init-${Date.now()}`;
        const log = (nivel, mensaje, datos = {}) => {
          console[nivel](`[${IFRAME_ID}] [${ID_TRANSACCION}] ${mensaje}`, datos);
        };
        
        log('info', 'Manejando inicialización', { 
          origen: mensaje?.origen,
          version: '1.0.0',
          timestamp: new Date().toISOString()
        });
        
        try {
          // 1. Validar mensaje de inicialización
          if (!mensaje?.datos) {
            throw new Error('Mensaje de inicialización sin datos');
          }
          
          // 2. Aplicar configuración inicial
          const { 
            modo = 'aventura', 
            controlesHabilitados = false,
            configuracion = {}
          } = mensaje.datos;
          
          log('debug', 'Configuración recibida', { 
            modo, 
            controlesHabilitados,
            configuracion
          });
          
          // 3. Validar modo
          if (!['aventura', 'casa'].includes(modo)) {
            throw new Error(`Modo no válido: ${modo}. Debe ser 'aventura' o 'casa'`);
          }
          
          // 4. Actualizar estado de la aplicación
          estadoApp.modo = modo;
          estadoApp.controlesHabilitados = !!controlesHabilitados;
          estadoApp.ultimaActualizacion = new Date().toISOString();
          estadoApp.configuracion = {
            ...estadoApp.configuracion,
            ...configuracion,
            version: '1.0.0',
            timestamp: estadoApp.ultimaActualizacion
          };
          
          // 5. Aplicar configuración a la interfaz
          await manejarEstadoControles(estadoApp.controlesHabilitados, modo, 'inicializacion');
          
          // 6. Confirmar inicialización
          const respuesta = {
            estado: 'ok',
            mensaje: 'Sistema de retos inicializado correctamente',
            timestamp: estadoApp.ultimaActualizacion,
            configuracion: {
              controlesHabilitados: estadoApp.controlesHabilitados,
              modo: estadoApp.modo,
              retoActual: estadoApp.retoActual?.id || null,
              version: '1.0.0'
            },
            soporte: [
              'mostrar_reto', 
              'ocultar_reto', 
              'cambiar_modo',
              'habilitar_controles',
              'deshabilitar_controles'
            ]
          };
          
          log('info', 'Sistema de retos inicializado correctamente', { configuracion: respuesta.configuracion });
          return respuesta;
          
        } catch (error) {
          const mensajeError = `Error durante la inicialización: ${error.message}`;
          log('error', mensajeError, { error: error.stack });
          
          // Mostrar error al usuario
          mostrarErrorInicializacion(error);
          
          // Notificar al padre del error
          try {
            await enviarMensajeAlPadre('error_inicializacion', {
              mensaje: error.message,
              stack: error.stack,
              timestamp: new Date().toISOString()
            }, { 
              reintentos: 2,
              tiempoEspera: 500,
              esencial: false 
            });
          } catch (e) {
            log('error', 'No se pudo notificar el error al padre', { error: e });
          }
          
          // Relanzar el error para que pueda ser manejado por el llamador
          throw error;
        }
      }
      
      /**
       * Configura los manejadores de mensajes
       * @returns {Promise<void>}
       */
      async function configurarManejadoresMensajes() {
        if (!window.Mensajeria) {
          throw new Error('El sistema de mensajería no está disponible');
        }
        
        // Obtener referencias a constantes del módulo de mensajería
        const { TIPOS_MENSAJE, LOG_LEVELS } = window.Mensajeria;
        
        try {
          // 1. Manejador de inicialización
          window.Mensajeria.registrarControlador(
            window.Mensajeria.TIPOS_MENSAJE.INICIALIZACION, 
            manejarInicializacion
          );
          
          // 2. Manejador de cambio de modo
          window.Mensajeria.registrarControlador(
            window.Mensajeria.TIPOS_MENSAJE.CAMBIO_MODO, 
            manejarCambioModo
          );
          
          // 3. Manejador de comandos de retos
          window.Mensajeria.registrarControlador(
            window.Mensajeria.TIPOS_MENSAJE.RETO, 
            manejarComandoReto
          );
          
          // 4. Manejador de confirmaciones
          window.Mensajeria.registrarControlador(
            'confirmacion', 
            manejarConfirmacion
          );
          
          // 5. Manejador de solicitudes de estado
          window.Mensajeria.registrarControlador(
            'solicitar_estado', 
            manejarSolicitudEstado
          );
          
          // 6. Manejador de habilitación/deshabilitación de controles
          window.Mensajeria.registrarControlador(
            'habilitar_controles', 
            manejarHabilitarControles
          );
          
          window.Mensajeria.registrarControlador(
            'deshabilitar_controles', 
            manejarDeshabilitarControles
          );
          
          console.log(`[${IFRAME_ID}] Manejadores de mensajes registrados`);
          
          // Notificar al padre que el iframe está listo
          return notificarEstado('inicializado');
          
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al configurar manejadores de mensajes:`, error);
          // Notificar al padre del error
          if (window.Mensajeria) {
            try {
              await window.Mensajeria.enviarMensaje('padre', 'error', {
                tipo: 'error_configuracion',
                mensaje: error.message,
                stack: error.stack,
                timestamp: Date.now()
              });
            } catch (e) {
              console.error(`[${IFRAME_ID}] No se pudo notificar el error al padre:`, e);
            }
          }
          throw error; // Relanzar para manejo posterior
        }
      }

      // ================== MANEJADORES DE MENSAJES ==================

      /**
       * Maneja la inicialización del iframe
       * @param {Object} mensaje - Mensaje de inicialización
       */
      async function manejarInicializacion(mensaje) {
        console.log(`[${IFRAME_ID}] Inicialización recibida:`, mensaje);
        
        try {
          // Inicializar el estado de la aplicación
          estadoApp.modo = mensaje.datos?.modo || 'aventura';
          
          // Configurar la interfaz según el modo
          await manejarCambioModo({
            datos: { 
              modo: estadoApp.modo,
              motivo: 'inicializacion'
            }
          });
          
          // Notificar al padre que la inicialización fue exitosa
          await notificarEstado('inicializacion_completada', {
            modo: estadoApp.modo,
            controlesHabilitados: estadoApp.controlesHabilitados
          });
          
          console.log(`[${IFRAME_ID}] Inicialización completada en modo ${estadoApp.modo}`);
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error en manejarInicializacion:`, error);
          await notificarError('inicializacion', {
            error: error.message,
            stack: error.stack
          });
          throw error;
        }
      }

      /**
       * Maneja el cambio de modo (aventura/casa)
       * @param {Object} mensaje - Mensaje con los datos del cambio de modo
       * @returns {Promise<void>}
       */
      async function manejarCambioModo(mensaje) {
        const { modo = 'aventura', motivo = 'desconocido' } = mensaje.datos || {};
        console.log(`[${IFRAME_ID}] Cambio de modo solicitado:`, { modo, motivo });
        
        // Validar parámetros
        if (!['aventura', 'casa'].includes(modo)) {
          const error = new Error(`Modo no válido: ${modo}`);
          console.error(`[${IFRAME_ID}] ${error.message}`);
          throw error;
        }
        
        try {
          // 1. Actualizar el estado local
          estadoApp.modo = modo;
          estadoApp.ultimoCambioModo = new Date().toISOString();
          
          // 2. Obtener referencias a elementos del DOM
          const contenedorReto = document.getElementById('contenedor-reto');
          const overlay = document.getElementById('overlay-deshabilitado');
          
          // 3. Aplicar cambios según el modo
          if (modo === 'aventura') {
            // 3.1. Modo aventura: mostrar el reto y ocultar el overlay
            if (contenedorReto) contenedorReto.style.display = 'block';
            if (overlay) overlay.style.display = 'none';
            
            // 3.2. Habilitar controles específicos de la aventura
            await manejarEstadoControles(true, 'aventura', 'cambio_modo');
            
          } else {
            // 3.1. Modo casa: ocultar el reto y mostrar el overlay
            if (contenedorReto) contenedorReto.style.display = 'none';
            if (overlay) {
              overlay.style.display = 'flex';
              const mensajeElemento = overlay.querySelector('.mensaje-deshabilitado');
              if (mensajeElemento) {
                mensajeElemento.textContent = obtenerMensajeModo('casa', motivo);
              }
            }
            
            // 3.2. Deshabilitar controles
            await manejarEstadoControles(false, 'casa', motivo);
          }
          
          // 4. Notificar al padre que el modo ha cambiado correctamente
          await enviarMensajeAlPadre('modo_cambiado', { 
            modo,
            exito: true,
            motivo,
            timestamp: new Date().toISOString()
          });
          
          console.log(`[${IFRAME_ID}] Modo cambiado a '${modo}' correctamente`);
          
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al cambiar el modo:`, error);
          
          // Notificar al padre del error
          await notificarError('error_cambio_modo', {
            modo,
            motivo,
            mensaje: error.message,
            stack: error.stack
          });
          
          // Relanzar el error para que pueda ser manejado por el llamador
          throw error;
        }
      }

      /**
       * Maneja el estado de los controles (habilitar/deshabilitar)
       * @param {boolean} habilitar - true para habilitar, false para deshabilitar
       * @param {string} modo - Modo actual ('casa' o 'aventura')
       * @param {string} motivo - Razón del cambio de estado
       * @returns {Promise<void>}
       */
      async function manejarEstadoControles(habilitar, modo, motivo = 'desconocido') {
        console.log(`[${IFRAME_ID}] ${habilitar ? 'Habilitando' : 'Deshabilitando'} controles:`, { modo, motivo });
        
        // Validar parámetros
        if (typeof habilitar !== 'boolean') {
          const error = new Error('El parámetro "habilitar" debe ser un booleano');
          console.error(`[${IFRAME_ID}] ${error.message}`, { habilitar, modo, motivo });
          throw error;
        }
        
        if (!['casa', 'aventura'].includes(modo)) {
          const error = new Error('Modo no válido. Debe ser "casa" o "aventura"');
          console.error(`[${IFRAME_ID}] ${error.message}`, { modo });
          throw error;
        }
        
        // Si no hay cambio de estado, no hacer nada
        if (estadoApp.controlesHabilitados === habilitar) {
          console.log(`[${IFRAME_ID}] Los controles ya están ${habilitar ? 'habilitados' : 'deshabilitados'}`);
          return;
        }
        
        try {
          // 1. Actualizar el estado de los controles
          estadoApp.controlesHabilitados = habilitar;
          estadoApp.ultimoCambioControles = new Date().toISOString();
          
          // 2. Obtener todos los controles que deben ser afectados
          const selectores = [
            '#btnEnviar',
            '#btnMostrarRespuesta',
            '#btnContinueReto',
            'input[type="radio"]',
            'input[type="checkbox"]',
            'button:not(.excluir-control)',
            'select',
            'textarea',
            '.control-interactivo' // Clase adicional para elementos personalizados
          ];
          
          const controles = Array.from(document.querySelectorAll(selectores.join(',')));
          
          // 3. Aplicar el estado a cada control
          controles.forEach(control => {
            if (control && control !== document.body) {
              // Solo actualizar si el estado actual es diferente
              if (control.disabled === habilitar) {
                control.disabled = !habilitar;
                
                // Aplicar estilos según el estado
                control.classList.toggle('control-habilitado', habilitar);
                control.classList.toggle('control-deshabilitado', !habilitar);
                
                // Actualizar atributos ARIA para accesibilidad
                control.setAttribute('aria-disabled', String(!habilitar));
                
                // Actualizar título para indicar el estado
                if (!habilitar && !control.hasAttribute('data-titulo-original')) {
                  control.setAttribute('data-titulo-original', control.title || '');
                  control.title = `Deshabilitado: ${obtenerMensajeModo(modo, motivo)}`;
                } else if (habilitar && control.hasAttribute('data-titulo-original')) {
                  control.title = control.getAttribute('data-titulo-original');
                  control.removeAttribute('data-titulo-original');
                }
              }
            }
          });
          
          // 4. Actualizar el overlay de deshabilitado si existe
          const overlay = document.getElementById('overlay-deshabilitado');
          if (overlay) {
            // Solo actualizar si el estado es diferente
            const mostrarOverlay = !habilitar && modo === 'casa';
            if (overlay.style.display !== (mostrarOverlay ? 'flex' : 'none')) {
              overlay.style.display = mostrarOverlay ? 'flex' : 'none';
              
              if (mostrarOverlay) {
                const mensajeElemento = overlay.querySelector('.mensaje-deshabilitado');
                if (mensajeElemento) {
                  mensajeElemento.textContent = obtenerMensajeModo(modo, motivo);
                }
              }
            }
          }
          
          // 5. Notificar al padre del cambio de estado de los controles
          await enviarMensajeAlPadre('estado_controles_actualizado', {
            habilitados: habilitar,
            modo,
            motivo,
            timestamp: estadoApp.ultimoCambioControles,
            totalControles: controles.length
          });
          
          console.log(`[${IFRAME_ID}] ${controles.length} controles ${habilitar ? 'habilitados' : 'deshabilitados'} correctamente`);
          
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al ${habilitar ? 'habilitar' : 'deshabilitar'} controles:`, error);
          
          // Revertir el estado en caso de error
          estadoApp.controlesHabilitados = !habilitar;
          
          // Notificar al padre del error
          await notificarError('error_estado_controles', {
            habilitar,
            modo,
            motivo,
            mensaje: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
          });
          
          throw error;
        }
      }

      /**
       * Maneja los comandos de retos
       * @param {Object} mensaje - Mensaje con el comando de reto
       * @returns {Promise<void>}
       */
      async function manejarComandoReto(mensaje) {
        const { comando, parametros = {} } = mensaje.datos || {};
        const idTransaccion = mensaje.idTransaccion || `reto_${Date.now()}`;
        
        console.log(`[${IFRAME_ID}] Comando de reto recibido:`, { 
          comando, 
          idTransaccion,
          parametros 
        });
        
        // Validar el comando
        if (!comando) {
          const error = new Error('No se especificó ningún comando');
          console.error(`[${IFRAME_ID}] ${error.message}`, { mensaje });
          throw error;
        }
        
        // Verificar si el comando está soportado
        const comandosSoportados = [
          'mostrar', 'ocultar', 'reiniciar', 
          'verificar', 'mostrar_respuesta', 'cambiar_modo'
        ];
        
        if (!comandosSoportados.includes(comando)) {
          const error = new Error(`Comando no soportado: ${comando}`);
          console.error(`[${IFRAME_ID}] ${error.message}`, { 
            comando, 
            comandosSoportados 
          });
          throw error;
        }
        
        try {
          let resultado = null;
          
          // Ejecutar el comando correspondiente
          switch (comando) {
            case 'mostrar':
              resultado = await mostrarReto(parametros);
              break;
              
            case 'ocultar':
              resultado = await ocultarReto(parametros);
              break;
              
            case 'reiniciar':
              resultado = await reiniciarReto(parametros);
              break;
              
            case 'verificar':
              resultado = await verificarRespuesta(parametros);
              break;
              
            case 'mostrar_respuesta':
              resultado = await mostrarRespuestaCorrecta(parametros);
              break;
              
            case 'cambiar_modo':
              // El cambio de modo ya tiene su propio manejador, pero lo soportamos aquí por compatibilidad
              return manejarCambioModo({
                ...mensaje,
                datos: { ...parametros, desdeComando: true }
              });
              
            // No se necesita default porque ya validamos los comandos soportados
          }
          
          // Notificar al padre que el comando se ejecutó correctamente
          await enviarMensajeAlPadre('comando_reto_ejecutado', {
            comando,
            idTransaccion,
            exito: true,
            resultado,
            parametros,
            timestamp: new Date().toISOString()
          });
          
          console.log(`[${IFRAME_ID}] Comando '${comando}' ejecutado correctamente`, { 
            idTransaccion,
            resultado 
          });
          
          return resultado;
          
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al ejecutar el comando '${comando}':`, error);
          
          // Notificar al padre del error
          await notificarError('error_comando_reto', {
            comando,
            idTransaccion,
            parametros,
            mensaje: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
          });
          
          // Relanzar el error para que pueda ser manejado por el llamador
          throw error;
        }
      }
      
      /**
       * Muestra un reto específico
       * @param {Object} parametros - Parámetros del reto a mostrar
       * @returns {Promise<Object>} Información del reto mostrado
       */
      async function mostrarReto(parametros = {}) {
        const { retoId } = parametros;
        const idTransaccion = `mostrar_reto_${Date.now()}`;
        
        console.log(`[${IFRAME_ID}] Mostrando reto:`, { retoId, idTransaccion });
        
        // Validar parámetros
        if (!retoId) {
          const error = new Error('No se especificó el ID del reto');
          console.error(`[${IFRAME_ID}] ${error.message}`, { parametros });
          throw error;
        }
        
        // Buscar el reto
        const retoIndex = retosAventura1Es.findIndex(r => r.id === retoId);
        if (retoIndex === -1) {
          const error = new Error(`No se encontró el reto con ID: ${retoId}`);
          console.error(`[${IFRAME_ID}] ${error.message}`, { retoId });
          throw error;
        }
        
        const reto = retosAventura1Es[retoIndex];
        
        try {
          // 1. Renderizar el reto
          await renderizarReto(retoIndex);
          
          // 2. Actualizar el estado
          estadoApp.retoActual = {
            id: retoId,
            indice: retoIndex,
            timestamp: new Date().toISOString(),
            estado: 'mostrado'
          };
          
          estadoApp.retoMostrado = true;
          
          // 3. Preparar respuesta
          const respuesta = {
            retoId,
            indice: retoIndex,
            tipo: reto.tipo,
            totalRetos: retosAventura1Es.length,
            timestamp: estadoApp.retoActual.timestamp,
            idTransaccion
          };
          
          // 4. Notificar al padre
          await enviarMensajeAlPadre('reto_mostrado', respuesta);
          
          console.log(`[${IFRAME_ID}] Reto mostrado correctamente`, { 
            retoId, 
            idTransaccion 
          });
          
          return respuesta;
          
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al mostrar el reto ${retoId}:`, error);
          
          // Notificar al padre del error
          await notificarError('error_mostrar_reto', {
            retoId,
            idTransaccion,
            mensaje: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
          });
          
          throw error;
        }
      }
      
      /**
       * Oculta el reto actual si hay uno mostrado
       * @param {Object} parametros - Parámetros adicionales
       * @returns {Promise<Object>} Información del reto ocultado
       */
      async function ocultarReto(parametros = {}) {
        const { motivo = 'usuario' } = parametros;
        const idTransaccion = `ocultar_reto_${Date.now()}`;
        
        console.log(`[${IFRAME_ID}] Ocultando reto:`, { 
          retoActual: estadoApp.retoActual, 
          motivo,
          idTransaccion 
        });
        
        // Verificar si hay un reto mostrado
        if (!estadoApp.retoActual) {
          console.warn(`[${IFRAME_ID}] No hay ningún reto para ocultar`);
          return { 
            exito: true, 
            mensaje: 'No hay ningún reto para ocultar',
            idTransaccion
          };
        }
        
        const retoAnterior = { ...estadoApp.retoActual };
        const retoIndex = retosAventura1Es.findIndex(r => r.id === retoAnterior.id);
        
        try {
          // 1. Ocultar el contenido del reto
          const retoContenidoDiv = document.getElementById('reto-contenido');
          if (retoContenidoDiv) {
            retoContenidoDiv.innerHTML = '';
          }
          
          // 2. Actualizar el estado
          estadoApp.retoActual = null;
          estadoApp.retoMostrado = false;
          
          // 3. Preparar respuesta
          const respuesta = {
            retoId: retoAnterior.id,
            indice: retoIndex,
            motivo,
            timestamp: new Date().toISOString(),
            idTransaccion
          };
          
          // 4. Notificar al padre
          await enviarMensajeAlPadre('reto_ocultado', respuesta);
          
          console.log(`[${IFRAME_ID}] Reto ocultado correctamente`, { 
            retoId: retoAnterior.id,
            idTransaccion 
          });
          
          return respuesta;
          
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al ocultar el reto:`, error);
          
          // Revertir el estado en caso de error
          estadoApp.retoActual = retoAnterior;
          estadoApp.retoMostrado = true;
          
          // Notificar al padre del error
          await notificarError('error_ocultar_reto', {
            retoId: retoAnterior?.id,
            idTransaccion,
            mensaje: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
          });
          
          throw error;
        }
      }
      
      /**
       * Reinicia el reto actual, limpiando las respuestas del usuario
       * @param {Object} parametros - Parámetros adicionales
       * @returns {Promise<Object>} Información del reto reiniciado
       */
      async function reiniciarReto(parametros = {}) {
        const { motivo = 'usuario' } = parametros;
        const idTransaccion = `reiniciar_reto_${Date.now()}`;
        
        console.log(`[${IFRAME_ID}] Reiniciando reto:`, { 
          retoActual: estadoApp.retoActual, 
          motivo,
          idTransaccion 
        });
        
        // Verificar si hay un reto actual
        if (!estadoApp.retoActual) {
          const error = new Error('No hay ningún reto para reiniciar');
          console.warn(`[${IFRAME_ID}] ${error.message}`);
          throw error;
        }
        
        const retoId = estadoApp.retoActual.id;
        const retoIndex = retosAventura1Es.findIndex(r => r.id === retoId);
        
        if (retoIndex === -1) {
          const error = new Error(`No se encontró el reto con ID: ${retoId}`);
          console.error(`[${IFRAME_ID}] ${error.message}`);
          throw error;
        }
        
        try {
          // 1. Guardar el estado anterior para poder revertir en caso de error
          const estadoAnterior = { ...estadoApp };
          
          // 2. Limpiar las respuestas del usuario
          const retoContenidoDiv = document.getElementById('reto-contenido');
          if (retoContenidoDiv) {
            // Limpiar solo los campos de entrada, no todo el contenido
            const inputs = retoContenidoDiv.querySelectorAll('input, textarea, select');
            inputs.forEach(input => {
              if (input.type === 'checkbox' || input.type === 'radio') {
                input.checked = false;
              } else {
                input.value = '';
              }
            });
            
            // Limpiar mensajes de retroalimentación
            const feedbackElements = retoContenidoDiv.querySelectorAll('.feedback, .retroalimentacion');
            feedbackElements.forEach(el => el.remove());
          }
          
          // 3. Actualizar el estado
          estadoApp.respuestaUsuario = null;
          estadoApp.respuestaVerificada = false;
          
          // 4. Preparar respuesta
          const respuesta = {
            retoId,
            indice: retoIndex,
            motivo,
            timestamp: new Date().toISOString(),
            idTransaccion
          };
          
          // 5. Notificar al padre
          await enviarMensajeAlPadre('reto_reiniciado', respuesta);
          
          console.log(`[${IFRAME_ID}] Reto reiniciado correctamente`, { 
            retoId,
            idTransaccion 
          });
          
          return respuesta;
          
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al reiniciar el reto:`, error);
          
          // Notificar al padre del error
          await notificarError('error_reiniciar_reto', {
            retoId,
            idTransaccion,
            mensaje: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
          });
          
          throw error;
        }
      }

          /**
       * Maneja las confirmaciones de mensajes
       * @param {Object} mensaje - Mensaje de confirmación
       */
      function manejarConfirmacion(mensaje) {
        const { mensajeId, estado, detalles = {} } = mensaje.datos || {};
        console.log(`[${IFRAME_ID}] Confirmación recibida:`, { mensajeId, estado, detalles });
        
        // Aquí podrías implementar lógica adicional basada en las confirmaciones
        // como actualizar el estado de operaciones pendientes, etc.
      }
      
      /**
       * Maneja las solicitudes de estado
       * @param {Object} mensaje - Mensaje de solicitud de estado
       */
      async function manejarSolicitudEstado(mensaje) {
        console.log(`[${IFRAME_ID}] Solicitud de estado recibida:`, mensaje);
        
        try {
          const estadoActual = {
            ...estadoApp,
            // Incluir información adicional del estado actual
            timestamp: new Date().toISOString(),
            retoActual: estadoApp.retoActual ? {
              id: estadoApp.retoActual,
              indice: retosAventura1Es.findIndex(r => r.id === estadoApp.retoActual)
            } : null
          };
          
          await notificarEstado('estado_actual', estadoActual);
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al procesar solicitud de estado:`, error);
          await notificarError('solicitud_estado', {
            error: error.message,
            stack: error.stack
          });
        }
      }
      /**
       * Maneja la habilitación de controles
       * @param {Object} mensaje - Mensaje de habilitación
       */
      // Función para manejar la habilitación de controles
      async function manejarHabilitarControles(mensaje) {
        console.log(`[${IFRAME_ID}] Solicitando habilitar controles`, mensaje);
        
        try {
          // Validar mensaje
          if (!mensaje || typeof mensaje !== 'object') {
            throw new Error('Mensaje inválido');
          }
          
          const { modo = 'aventura', motivo = 'sin_especificar' } = mensaje.datos || {};
          
          // Actualizar estado local
          estadoApp.controlesHabilitados = true;
          estadoApp.modo = modo;
          
          // Actualizar interfaz
          document.body.classList.remove('controles-deshabilitados');
          
          // Notificar al padre
          await enviarMensajeAlPadre('sistema:controles_habilitados', { 
            modo,
            motivo,
            timestamp: Date.now(),
            origen: IFRAME_ID
          });
          
          console.log(`[${IFRAME_ID}] Controles habilitados (modo: ${modo}, motivo: ${motivo})`);
          return true;
          
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al habilitar controles:`, error);
          await notificarError('error_habilitar_controles', {
            error: error.message,
            stack: error.stack,
            modo: mensaje?.datos?.modo || 'desconocido',
            motivo: mensaje?.datos?.motivo || 'error_desconocido',
            timestamp: new Date().toISOString()
          });
          throw error;
        }
      }
      
      // Manejar mensaje de controles habilitados
      function manejarControlesHabilitados(mensaje) {
        console.log(`[${IFRAME_ID}] Recibido mensaje de controles habilitados:`, mensaje);
        const { modo = 'aventura', motivo = 'sin_especificar' } = mensaje.datos || {};
        
        // Actualizar estado local
        estadoApp.controlesHabilitados = true;
        estadoApp.modo = modo;
        
        // Actualizar interfaz
        document.body.classList.remove('controles-deshabilitados');
        
        console.log(`[${IFRAME_ID}] Controles habilitados (modo: ${modo}, motivo: ${motivo})`);
        return true;
      }
      
      // Manejar mensaje de controles deshabilitados
      function manejarControlesDeshabilitados(mensaje) {
        console.log(`[${IFRAME_ID}] Recibido mensaje de controles deshabilitados:`, mensaje);
        const { motivo = 'sin_especificar' } = mensaje.datos || {};
        
        // Actualizar estado local
        estadoApp.controlesHabilitados = false;
        
        // Actualizar interfaz
        document.body.classList.add('controles-deshabilitados');
        
        console.log(`[${IFRAME_ID}] Controles deshabilitados (motivo: ${motivo})`);
        return true;
      }
      
      /**
       * Maneja la deshabilitación de controles
       * @param {Object} mensaje - Mensaje de deshabilitación
       */
      async function manejarDeshabilitarControles(mensaje) {
        const { motivo = 'desconocido' } = mensaje.datos || {};
        console.log(`[${IFRAME_ID}] Deshabilitando controles:`, { motivo });
        
        try {
          disableControls(motivo);
          estadoApp.controlesHabilitados = false;
          
          await notificarEstado('controles_deshabilitados', { motivo });
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al deshabilitar controles:`, error);
          await notificarError('deshabilitar_controles', {
            motivo,
            error: error.message,
            stack: error.stack
          });
          throw error;
        }
      }
      
      /**
       * Notifica un cambio de estado al iframe padre
       * @param {string} tipo - Tipo de notificación
       * @param {Object} [datos={}] - Datos adicionales
       * @returns {Promise} Promesa que se resuelve cuando se envía la notificación
       */
      async function notificarEstado(tipo, datos = {}) {
        if (!window.Mensajeria) {
          console.warn(`[${IFRAME_ID}] Mensajería no disponible para notificar estado:`, { tipo, datos });
          return Promise.resolve();
        }
        
        const mensaje = {
          tipo,
          datos: {
            ...datos,
            timestamp: new Date().toISOString(),
            origen: IFRAME_ID
          }
        };
        
        console.log(`[${IFRAME_ID}] Notificando estado:`, mensaje);
        
        try {
          return await Mensajeria.enviarMensajeConReintenos(
            'padre',
            'estado_reto',
            mensaje.datos,
            CONFIG_REINTENTOS
          );
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al notificar estado:`, error);
          throw error;
        }
      }
      
      /**
       * Notifica un error al iframe padre
       * @param {string} tipo - Tipo de error
       * @param {Object} [detalles={}] - Detalles adicionales del error
       * @returns {Promise} Promesa que se resuelve cuando se envía la notificación de error
       */
      async function notificarError(tipo, detalles = {}) {
        if (!window.Mensajeria) {
          console.error(`[${IFRAME_ID}] Mensajería no disponible para notificar error:`, { tipo, detalles });
          return Promise.resolve();
        }
        
        console.error(`[${IFRAME_ID}] Notificando error:`, { tipo, detalles });
        
        try {
          await notificarEstado('error', {
            tipo,
            ...detalles,
            timestamp: new Date().toISOString(),
            origen: IFRAME_ID
          });
        } catch (error) {
          console.error(`[${IFRAME_ID}] Error al notificar error:`, error);
          throw error;
        }
      }

      // Notificar al padre que está listo
      try {
        await Mensajeria.enviarMensajeConReintenos(
          'padre',
          Mensajeria.TIPOS_MENSAJE.INICIALIZACION,
          { estado: 'listo', timestamp: Date.now() }
        );
      } catch (e) {
        console.error('Error al notificar estado listo al padre:', e);
        throw e;
      }
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reto Interactivo Aventura 1 Español (Hijo 4)</title>
<style>
    /* --- ESTILOS DEL IFRAME DE RETOS --- */
    /* Para que la ventana de retos ocupe todo el área del iframe menos 1px en cada borde,
       ajusta el padding y el tamaño del contenedor principal. Modifica el valor de --borde-reto
       para cambiar fácilmente el margen respecto al borde del iframe. */
    :root {
        --borde-reto: 1px; /* Margen respecto a cada borde del iframe */
    }
    body {
        font-family: "Book Antiqua", "Palatino Linotype", "Palatino", Georgia, serif;
        margin: 0;
        background: #fff;
        color: #222;
        font-size: 16px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: center;
        min-height: 100vh;
        box-sizing: border-box;
        padding: var(--borde-reto);
        width: calc(100vw - 2 * var(--borde-reto));
        height: calc(100vh - 2 * var(--borde-reto));
    }
    
    /* Estado deshabilitado para toda la interfaz */
    body.disabled {
        pointer-events: none;
        opacity: 0.6;
        user-select: none;
    }
    
    /* Overlay de estado deshabilitado */
    .disabled-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(128, 128, 128, 0.3);
        z-index: 9999;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 1.5em;
        color: #666;
        text-align: center;
    }
    
    body.disabled .disabled-overlay {
        display: flex;
    }
    
    #reto-contenido, #button-container, #respuestaCorrectaTexto, #fuegos {
        /* Asegura que los elementos internos no sobresalgan */
        box-sizing: border-box;
        width: 100%;
    }
    h3 {
        margin-top: 0;
        margin-bottom: 0.8em;
        font-size: 1.5em;
        text-align: center;
        width: 100%;
    }
    .opciones-container {
        width: 100%;
        max-width: 600px;
        text-align: left;
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
    .respuesta {
        margin: 0.4em 0;
        font-size: 1.3em;
        display: flex;
        align-items: center;
    }
    .respuesta input[type="radio"],
    .respuesta input[type="checkbox"] {
        margin-right: 0.7em;
        transform: scale(1.3);
        cursor: pointer;
    }
    .respuesta input[type="text"] {
        flex-grow: 1;
        font-size: 1.3em;
        padding: 0.3em 0.5em;
        border-radius: 4px;
        border: 1px solid #999;
        width: calc(100% - 1.4em);
    }
    #button-container {
        display: flex;
        flex-wrap: wrap;
        gap: 1em;
        margin-top: 1.5em;
        justify-content: center;
        width: 100%;
        min-height: 40px;
    }
    button.btn {
        padding: 0.6em 1.2em;
        font-size: 1.1em;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        background-color: #0077cc;
        color: white;
        user-select: none;
        transition: background-color 0.3s ease;
    }
    button.btn:hover {
        background-color: #005699;
    }
    button.btn:disabled {
        background-color: #999;
        cursor: not-allowed;
    }
    #btnMostrarRespuesta {
        background-color: #28a745;
        display: none;
    }
    #btnMostrarRespuesta:hover {
        background-color: #1e7e34;
    }
    #respuestaCorrectaTexto {
        margin-top: 1em;
        font-weight: bold;
        text-align: center;
        width: 100%;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 0.8em 1em;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        font-size: 1.2em;
        color: #222;
        z-index: 20;
        display: none;
        box-sizing: border-box;
    }
    #fuegos {
        pointer-events: none;
        position: absolute;
        top: 0; left: 0;
        width: 100%;
        height: 100%;
        z-index: 10;
        overflow: hidden;
        display: none;
    }
    @media (max-width: 600px) {
        h3 { font-size: 1.3em; }
        .respuesta { font-size: 1.1em; }
        button.btn { font-size: 1em; padding: 0.5em 1em; }
        #respuestaCorrectaTexto { font-size: 1.1em; }
    }
</style>
</head>
<body>
    <!-- Script para importar el módulo de mensajería -->
    <script type="module" src="./js/mensajeria.js"></script>
    
    <!-- Overlay para estado deshabilitado -->
    <div class="disabled-overlay">
        <div>
            <div>🔒 Retos Deshabilitados</div>
            <div style="font-size: 0.8em; margin-top: 10px;">Active el modo casa para acceder a los retos</div>
        </div>
    </div>
    
    <!-- El contenido de la ventana de retos ocupa todo el área del iframe menos 1px en cada borde. Cambia --borde-reto arriba para ajustar el margen. -->
    <div id="reto-contenido"></div>
    <div id="button-container">
        <button id="btnEnviar" class="btn">Enviar</button>
        <button id="btnMostrarRespuesta" class="btn">Mostrar Respuesta</button>
    </div>
    <div id="respuestaCorrectaTexto"></div>
    <div id="fuegos"></div>
    <!-- Botón flotante para continuar tras acertar el reto -->
    <button id="btnContinueReto" class="btn" style="display:none;position:fixed;bottom:30px;right:30px;z-index:3000;background:#ff9800;font-size:1.2em;padding:1em 2em;box-shadow:0 2px 8px rgba(0,0,0,0.2);">Continúe su reto</button>
<script>
// ================== VARIABLES DE CONTROL DE MODO ==================

let modoActual = 'aventura'; // 'aventura' o 'casa'
let controlesHabilitados = false;
let retosDisabled = true; // Empezar con retos deshabilitados (modo aventura)

// ================== FUNCIONES DE CONTROL DE MODO ==================

/**
 * Habilita los controles según el modo especificado
 * @param {string} modo - 'casa' o 'aventura'
 */
function enableControls(modo = 'casa') {
    modoActual = modo;
    controlesHabilitados = true;
    retosDisabled = false;
    
    // Actualizar la interfaz
    document.body.classList.remove('disabled');
    
    // Notificar al padre que los controles están habilitados
    enviarMensajeAlPadre('control', {
        tipo: 'controles_habilitados',
        modo: modo
    }).catch(error => {
        console.error('Error al notificar controles habilitados:', error);
    });
    
    console.log(`✅ HIJO 4: Controles habilitados - Modo: ${modo}`);
}

/**
 * Deshabilita los controles con un motivo específico
 * @param {string} motivo - Razón de la deshabilitación
 */
function disableControls(motivo = 'desconocido') {
    controlesHabilitados = false;
    retosDisabled = true;
    
    // Actualizar la interfaz
    document.body.classList.add('disabled');
    
    // Notificar al padre que los controles están deshabilitados
    enviarMensajeAlPadre('control', {
        tipo: 'controles_deshabilitados',
        motivo: motivo
    }).catch(error => {
        console.error('Error al notificar controles deshabilitados:', error);
    });
    
    console.log(`🚫 HIJO 4: Controles deshabilitados - ${motivo}`);
}

/**
 * Maneja el cambio de modo (casa/aventura)
 * @param {string} modo - 'casa' o 'aventura'
 * @param {boolean} habilitar - Si es true, habilita los controles
 */
function manejarCambioModo(modo, habilitar = false) {
    console.log(`🔄 HIJO 4: Cambiando a modo ${modo}, habilitar: ${habilitar}`);
    
    // Actualizar el modo actual
    const modoAnterior = modoActual;
    modoActual = modo;
    
    // Manejar la habilitación/deshabilitación de controles
    if (modo === 'casa') {
        // En modo casa, siempre habilitar los controles
        enableControls('casa');
    } else if (habilitar) {
        // Si se solicita habilitar los controles en otro modo
        enableControls(modo);
    } else {
        // Solo deshabilitar controles si estamos en modo aventura y no se solicita habilitar
        disableControls('modo_aventura');
    }
    
    // Notificar al padre del cambio de modo
    if (window.mensajeria) {
        mensajeria.enviarMensaje(mensajeria.TIPOS_MENSAJE.SISTEMA.CONFIGURACION, {
            tipo: 'cambio_modo',
            modo: modo,
            habilitado: habilitar || modo === 'casa', // Siempre true para modo casa
            origen: 'hijo4-retos',
            detalles: {
                modoAnterior: modoAnterior,
                controlesHabilitados: controlesHabilitados
            }
        });
    }
    
    console.log(`✅ HIJO 4: Modo cambiado a ${modo}, controles ${controlesHabilitados ? 'habilitados' : 'deshabilitados'}`);
}

// ================== VARIABLES GLOBALES ==================

// Índice del reto actual
let currentRetoIndex = -1;

// ================== ARRAY DE RETOS DE LA AVENTURA 1 ==================
// Cada objeto representa un reto. El campo 'tipo' puede ser 'opcion', 'opcion-multiple', 'texto' o 'puzzle'.
// El campo 'correctas' contiene la(s) respuesta(s) correcta(s).
const retosAventura1Es = [
  {
    reto: 1,
    id: "R-1",
    tipo: "opcion",
    pregunta: "1. ¿Cuántas Aventuras pueden hacerse con Valencia be Guides?",
    opciones: ["4", "5", "6", "7"],
    correctas: ["7"],
    multiple: false
  },
  {
    reto: 2,
    id: "R-2",
    tipo: "opcion",
    pregunta: "2. ¿Sabría decirme cómo se llaman estas Torres?",
    opciones: ["Torres de Quart", "Torres de Serranos", "Torre del Miguelete", "Torre de Santa catalina"],
    correctas: ["Torres de Serranos"],
    multiple: false
  },
  {
    reto: 3,
    id: "R-3",
    tipo: "opcion",
    pregunta: "3. ¿En la cumbre de las torres ondea la bandera de Valencia: sus colores se componen de rojo, amarillo y… ?",
    opciones: ["Violeta", "Verde", "Azul"],
    correctas: ["Azul"],
    multiple: false
  },
  {
    reto: 4,
    id: "R-4",
    tipo: "texto",
    pregunta: "4. ¿Sabría decirme el nombre de la calle?",
    correctas: ["Calle Muro de Santa Ana"]
  },
  {
    reto: 5,
    id: "R-5",
    tipo: "opcion",
    pregunta: "5. ¿Qué porta San Lorenzo en la mano?",
    opciones: ["Una Paloma", "Una cuchara", "Una parrilla"],
    correctas: ["Una parrilla"],
    multiple: false
  },
  {
    reto: 6,
    id: "R-6",
    tipo: "opcion",
    pregunta: "6. ¿Con qué mano sujeta Neptuno la cornucopia?",
    opciones: ["Izquierda", "Derecha"],
    correctas: ["Derecha"],
    multiple: false
  },
  {
    reto: 7,
    id: "R-7",
    tipo: "texto",
    pregunta: "7. ¿Cuántas figuras rodean la fuente?",
    correctas: ["8"]
  },
  {
    reto: 8,
    id: "PZ-8",
    tipo: "puzzle",
    pregunta: "8. Plaza de la Virgen",
    src: "P8_puzzle_plaza_virgen.html"
  },
  {
    reto: 9,
    id: "R-9",
    tipo: "opcion",
    pregunta: "9. ¿Qué figura esculpida puede verse en el marco del cuadro?",
    opciones: ["Un Dragón", "Un Murciélago", "Una Corona"],
    correctas: ["Una Corona"],
    multiple: false
  },
  {
    reto: 10,
    id: "R-10",
    tipo: "opcion-multiple",
    pregunta: "10. ¿Qué puede verse dentro?",
    opciones: ["Un Altar", "Una bandera", "Una espada"],
    correctas: ["Un Altar", "Una bandera"],
    multiple: true
  },
  {
    reto: 11,
    id: "R-11",
    tipo: "texto",
    pregunta: "11. Sobre ésta hay una placa conmemorativa. ¿En qué año fue expuesta dicha placa?",
    correctas: ["1952"]
  },
  {
    reto: 12,
    id: "R-12",
    tipo: "texto",
    pregunta: "12. ¿En qué año se edificó esta finca? ¡Pista! Mire en la parte superior de la fachada.",
    correctas: ["1906"]
  },
  {
    reto: 13,
    id: "R-13",
    tipo: "opcion",
    pregunta: "13. ¿Qué puede verse dentro?",
    opciones: ["Una Plaza de Toros", "Unos baños romanos", "Una estación de metro"],
    correctas: ["Unos baños romanos"],
    multiple: false
  },
  {
    reto: 14,
    id: "R-14",
    tipo: "opcion",
    pregunta: "14. ¿Sabría determinar qué geometría tiene?",
    opciones: ["hexagonal", "Octogonal", "Cuadrangular"],
    correctas: ["hexagonal"],
    multiple: false
  },
  {
    reto: 15,
    id: "R-15",
    tipo: "texto",
    pregunta: "15. ¿Cuántos Arcos componen la puerta?",
    correctas: ["6"]
  },
  {
    reto: 16,
    id: "R-16",
    tipo: "opcion",
    pregunta: "16. ¿Recuerda qué animal corona el escudo municipal?",
    opciones: ["Un Dragón", "Un Murciélago", "Un Caballo"],
    correctas: ["Un Murciélago"],
    multiple: false
  },
  {
    reto: 17,
    id: "R-17",
    tipo: "opcion",
    pregunta: "17. ¡Preste atención a la fachada de la primera torre! ¿Qué Fruta Cítrica natural de Valencia decora la fachada?",
    opciones: ["Limones", "Pomelos", "Naranjas"],
    correctas: ["Naranjas"],
    multiple: false
  },
  {
    reto: 18,
    id: "PZ-18",
    tipo: "puzzle",
    pregunta: "18. Plaza de Toros y Estación del Norte",
    src: "P18_puzzle_plaza_de_Toros_y_estacion_norte.html"
  },
  {
    reto: 19,
    id: "R-19",
    tipo: "texto",
    pregunta: "19. ¿Sabría decirme qué comercio alberga dicho edificio?",
    correctas: ["?"]
  },
  {
    reto: 20,
    id: "R-20",
    tipo: "opcion-multiple",
    pregunta: "20. Sobre la entrada principal, en un arco de medio punto, figuras alegóricas representan a los cinco continentes. ¿Qué porta la figura central en sus manos?",
    opciones: ["Una Corona", "Una Espada", "Una Antorcha"],
    correctas: ["Una Antorcha", "Una Espada"],
    multiple: true
  },
  {
    reto: 21,
    id: "R-21",
    tipo: "opcion",
    pregunta: "21. ¿Qué porta la figura en la mano?",
    opciones: ["Una balanza", "Un libro", "Una pluma"],
    correctas: ["Una balanza"],
    multiple: false
  },
  {
    reto: 22,
    id: "R-22",
    tipo: "texto",
    pregunta: "22. ¿Cuantas plantas tiene el edificio?",
    correctas: ["10"]
  },
  {
    reto: 23,
    id: "R-23",
    tipo: "opcion",
    pregunta: "23. Busque la vidriera con los colores de la Señera valenciana en la fachada del edificio. ¿Sabría determinar qué forma tiene?",
    opciones: ["Cuadrangular", "Redonda", "Triangular"],
    correctas: ["Redonda"],
    multiple: false
  },
  {
    reto: 24,
    id: "R-24",
    tipo: "opcion-multiple",
    pregunta: "24. ¿Qué sostiene la virgen en sus manos?",
    opciones: ["Un Rosario", "Un niño", "Una corona"],
    correctas: ["Un Rosario", "Un niño"],
    multiple: true
  },
  {
    reto: 25,
    id: "R-25",
    tipo: "opcion",
    pregunta: "25. ¿Qué le entrega el ángel al niño?",
    opciones: ["Una paloma", "Un orbe", "Alimentos"],
    correctas: ["Un orbe"],
    multiple: false
  },
  {
    reto: 26,
    id: "PZ-26",
    tipo: "puzzle",
    pregunta: "26. Lonja de la Seda",
    src: "P26_puzzle_lonja.html"
  },
  {
    reto: 27,
    id: "R-27",
    tipo: "opcion-multiple",
    pregunta: "27. El barquero que rema a contracorriente.",
    opciones: ["Un hombre con rostro triste manejando un pequeño bote de madera escapa a contracorriente de un monstruo."],
    correctas: ["Un hombre con rostro triste manejando un pequeño bote de madera escapa a contracorriente de un monstruo."],
    multiple: true
  },
  {
    reto: 28,
    id: "R-28",
    tipo: "opcion-multiple",
    pregunta: "28. Un árbol muerto: símbolo del Pecado, se ve entre las dos hojas de la puerta y cumple la función de parteluz.",
    opciones: ["Observe en la copa del árbol como 4 hombres desnudos se azotan entre si."],
    correctas: ["Observe en la copa del árbol como 4 hombres desnudos se azotan entre si."],
    multiple: true
  },
  {
    reto: 29,
    id: "R-29",
    tipo: "opcion-multiple",
    pregunta: "29. A la derecha, un ángel que muestra su pene y...",
    opciones: ["se dispone a introducirlo en un jarrón que sostiene con la otra mano. Algo extraño e inusual ¿no le parece?"],
    correctas: ["se dispone a introducirlo en un jarrón que sostiene con la otra mano. Algo extraño e inusual ¿no le parece?"],
    multiple: true
  },
  {
    reto: 30,
    id: "R-30",
    tipo: "opcion-multiple",
    pregunta: "30. En el centro El barbudo y el león:",
    opciones: ["Original y contradictoria escena en la cual el manso es precisamente el león y no el anciano barbudo."],
    correctas: ["Original y contradictoria escena en la cual el manso es precisamente el león y no el anciano barbudo."],
    multiple: true
  },
  {
    reto: 31,
    id: "R-31",
    tipo: "opcion-multiple",
    pregunta: "31. ¡Aquí va un reto extra! ¡Busque al fornicador de la lonja!",
    opciones: ["En una de sus ventanas, hallará a un hombre tallado, no se le advierte su cabeza, pero sí sus genitales, Y muy claramente."],
    correctas: ["En una de sus ventanas, hallará a un hombre tallado, no se le advierte su cabeza, pero sí sus genitales, Y muy claramente."],
    multiple: true
  },
  {
    reto: 32,
    id: "R-32",
    tipo: "opcion",
    pregunta: "32. ¿Qué sostiene el niño en sus manos?",
    opciones: ["Una paloma", "Una Concha", "Alimentos"],
    correctas: ["Una Concha"],
    multiple: false
  }
];

// ================== REFERENCIAS A ELEMENTOS DEL DOM ==================

// Referencias a elementos del DOM
const retoContenidoDiv = document.getElementById("reto-contenido");
const btnEnviar = document.getElementById("btnEnviar");
const btnMostrarRespuesta = document.getElementById("btnMostrarRespuesta");
const divRespuestaCorrecta = document.getElementById("respuestaCorrectaTexto");
const fuegosDiv = document.getElementById("fuegos");
const btnContinueReto = document.getElementById("btnContinueReto");

// Constantes de la aplicación
const DURACION_TOTAL_MS = 3000;

// ================== FUNCIONES DE MENSAJERÍA PADRE-HIJO ==================

/**
 * Envía un mensaje al padre usando el sistema de mensajería centralizado
 * @param {string} tipo - Tipo de mensaje (ej: 'sistema_estado', 'puzzle_mostrado', etc.)
 * @param {Object} [datos={}] - Datos del mensaje
 * @param {Object} [opciones={}] - Opciones de envío
 * @param {number} [opciones.reintentos=3] - Número de reintentos
 * @param {number} [opciones.tiempoEspera=1000] - Tiempo de espera entre reintentos en ms
 * @param {boolean} [opciones.esencial=true] - Si es true, se reintentará incluso en modo silencioso
 * @returns {Promise<Object>} Promesa que se resuelve con la respuesta del padre
 */
async function enviarMensajeAlPadre(tipo, datos = {}, opciones = {}) {
    const ID_TRANSACCION = `msg-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    const log = (nivel, mensaje, datos = {}) => {
        console[nivel](`[${IFRAME_ID}] [${ID_TRANSACCION}] ${mensaje}`, datos);
    };
    
    const config = {
        reintentos: 3,
        tiempoEspera: 1000,
        esencial: true,
        ...opciones
    };
    
    log('debug', `Enviando mensaje al padre (${tipo})`, { 
        tipo, 
        datos,
        config 
    });
    
    try {
        // Verificar que el sistema de mensajería esté disponible
        if (!window.Mensajeria || typeof window.Mensajeria.enviarMensajeConReintenos !== 'function') {
            const error = new Error('El sistema de mensajería no está disponible');
            log('error', 'No se puede enviar mensaje', { error: error.message });
            throw error;
        }
        
        // Crear el mensaje con metadatos
        const mensaje = {
            ...datos,
            origen: IFRAME_ID,
            tipo,
            timestamp: new Date().toISOString(),
            idTransaccion: ID_TRANSACCION
        };
        
        // Enviar el mensaje usando el sistema de mensajería centralizado
        const respuesta = await window.Mensajeria.enviarMensajeConReintenos(
            'padre',  // Destino
            tipo,     // Tipo de mensaje
            mensaje,  // Datos del mensaje
            {
                maxRetries: config.reintentos,
                retryDelay: config.tiempoEspera,
                timeout: config.tiempoEspera * 2,
                esperarConfirmacion: true,
                esEsencial: config.esencial
            }
        );
        
        log('debug', 'Respuesta recibida del padre', { respuesta });
        return respuesta;
        
    } catch (error) {
        const errorInfo = {
            mensaje: error.message,
            stack: error.stack,
            tipo: error.name || 'Error',
            codigo: error.code || 'ERROR_DESCONOCIDO',
            timestamp: new Date().toISOString(),
            idTransaccion: ID_TRANSACCION
        };
        
        log('error', 'Error al enviar mensaje al padre', errorInfo);
        
        // Notificar al padre del error si es posible
        try {
            await window.Mensajeria?.enviarMensajeConReintenos(
                'padre',
                'error_comunicacion',
                {
                    ...errorInfo,
                    origen: IFRAME_ID,
                    tipoMensajeOriginal: tipo,
                    datosOriginales: datos
                },
                { reintentos: 1, tiempoEspera: 500, esencial: false }
            );
        } catch (e) {
            log('warn', 'No se pudo notificar el error al padre', { error: e });
        }
        
        // Relanzar el error para que pueda ser manejado por el llamador
        throw error;
    }
}

// ================== MANEJO DE ERRORES ==================

/**
 * Muestra un mensaje de error al usuario cuando hay un problema de inicialización
 * @param {Error} error - El error que ocurrió durante la inicialización
 */
function mostrarErrorInicializacion(error) {
    try {
        // Crear elemento de error si no existe
        let errorDiv = document.getElementById('error-inicializacion');
        
        if (!errorDiv) {
            errorDiv = document.createElement('div');
            errorDiv.id = 'error-inicializacion';
            errorDiv.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background-color: #ffebee;
                color: #b71c1c;
                padding: 15px;
                text-align: center;
                font-family: Arial, sans-serif;
                font-size: 14px;
                border-bottom: 2px solid #ef9a9a;
                z-index: 9999;
            `;
            
            document.body.appendChild(errorDiv);
        }
        
        // Mensaje de error amigable
        const mensajeError = `
            <div style="font-weight: bold; margin-bottom: 8px;">
                ⚠️ Error al cargar los retos interactivos
            </div>
            <div style="margin-bottom: 8px;">
                Por favor, recarga la página. Si el problema persiste, contacta con soporte.
            </div>
            ${process.env.NODE_ENV === 'development' ? 
                `<div style="font-size: 12px; color: #7f0000; margin-top: 5px; text-align: left;">
                    ${error.message || 'Error desconocido'}
                </div>` 
                : ''
            }
        `;
        
        errorDiv.innerHTML = mensajeError;
        
        // Deshabilitar todos los controles
        const controles = document.querySelectorAll('button, input, select, textarea');
        controles.forEach(control => {
            control.disabled = true;
            control.style.opacity = '0.5';
            control.style.cursor = 'not-allowed';
        });
        
    } catch (e) {
        console.error('Error al mostrar mensaje de error:', e);
    }
}

// ================== EFECTOS VISUALES ==================

// --- EFECTO: Fuegos artificiales al acertar ---
function fuegosArtificiales() {
    const NUM_CHISPAS_POR_FUEGO = 30;
    const NUM_EXPLOSIONES = 15;
    fuegosDiv.innerHTML = "";
    fuegosDiv.style.display = "block";
    for (let e = 0; e < NUM_EXPLOSIONES; e++) {
        const delayExplosion = (DURACION_TOTAL_MS / NUM_EXPLOSIONES) * e;
        setTimeout(() => {
            const startX = Math.random() * fuegosDiv.offsetWidth;
            const startY = Math.random() * fuegosDiv.offsetHeight;
            for (let i = 0; i < NUM_CHISPAS_POR_FUEGO; i++) {
                let chispa = document.createElement("div");
                chispa.style.position = "absolute";
                chispa.style.borderRadius = "50%";
                chispa.style.width = "12px";
                chispa.style.height = "12px";
                chispa.style.background = `hsl(${Math.random() * 360}, 100%, 70%)`;
                chispa.style.opacity = "1";
                chispa.style.left = `${startX}px`;
                chispa.style.top = `${startY}px`;
                chispa.style.zIndex = "10";
                fuegosDiv.appendChild(chispa);
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 80 + 40;
                const endX = startX + distance * Math.cos(angle);
                const endY = startY + distance * Math.sin(angle);
                const chispaDuration = DURACION_TOTAL_MS / NUM_EXPLOSIONES * 1.5;
                chispa.style.transition = `all ${chispaDuration}ms ease-out`;
                setTimeout(() => {
                    chispa.style.left = `${endX}px`;
                    chispa.style.top = `${endY}px`;
                    chispa.style.opacity = "0";
                    chispa.style.transform = "scale(0.5)";
                }, 10);
                setTimeout(() => {
                    if (chispa.parentNode) {
                        chispa.parentNode.removeChild(chispa);
                    }
                }, delayExplosion + chispaDuration + 50);
            }
        }, delayExplosion);
    }
    setTimeout(() => {
        fuegosDiv.style.display = "none";
    }, DURACION_TOTAL_MS + 100);
}

// --- EFECTO: Vibración al fallar ---
function vibrar() {
    if (navigator.vibrate) navigator.vibrate(300);
}

// ================== GESTIÓN DE RETOS ==================

// --- RENDERIZAR EL RETO SEGÚN EL ÍNDICE QUE ENVÍA EL PADRE ---
function renderizarReto(retoIndex) {
    // No renderizar si los retos están deshabilitados
    if (retosDisabled) {
        console.log('🚫 HIJO 4: No se puede renderizar reto - retos deshabilitados');
        enviarAlPadre({ type: "reto-hijo-error", message: "Retos deshabilitados", index: retoIndex });
        return;
    }
    
    currentRetoIndex = retoIndex;
    const reto = retosAventura1Es[currentRetoIndex];
    if (!reto) {
        console.error("Reto no encontrado para el índice:", retoIndex);
        enviarAlPadre({ type: "reto-hijo-error", message: "Reto no encontrado", index: retoIndex });
        return;
    }
    retoContenidoDiv.innerHTML = '';
    btnEnviar.style.display = "inline-block";
    btnEnviar.disabled = false;
    btnMostrarRespuesta.style.display = "none";
    btnContinueReto.style.display = "none";
    divRespuestaCorrecta.style.display = "none";
    divRespuestaCorrecta.textContent = "";
    fuegosDiv.innerHTML = "";
    fuegosDiv.style.display = "none";
    let preguntaElem = document.createElement("h3");
    preguntaElem.textContent = reto.pregunta;
    retoContenidoDiv.appendChild(preguntaElem);
    if (reto.tipo === "opcion" || reto.tipo === "opcion-multiple") {
        const opcionesContainer = document.createElement("div");
        opcionesContainer.className = "opciones-container";
        const inputType = reto.multiple ? "checkbox" : "radio";
        reto.opciones.forEach((opcion, i) => {
            const divOpcion = document.createElement("div");
            divOpcion.className = "respuesta";
            const input = document.createElement("input");
            input.type = inputType;
            input.name = "op";
            input.value = opcion;
            input.id = "opcion" + i;
            divOpcion.appendChild(input);
            const label = document.createElement("label");
            label.htmlFor = input.id;
            label.textContent = opcion;
            divOpcion.appendChild(label);
            opcionesContainer.appendChild(divOpcion);
        });
        retoContenidoDiv.appendChild(opcionesContainer);
    } else if (reto.tipo === "texto") {
        const inputTexto = document.createElement("input");
        inputTexto.type = "text";
        inputTexto.id = "respuestaTexto";
        inputTexto.autocomplete = "off";
        inputTexto.spellcheck = false;
        inputTexto.setAttribute("inputmode", "text");
        inputTexto.placeholder = "Escriba su respuesta aquí...";
        retoContenidoDiv.appendChild(inputTexto);
        setTimeout(() => inputTexto.focus(), 200);
    }
    // No notificamos al padre aún, esperamos a que el usuario haga clic en Continuar
    console.log(`🧩 HIJO 4: Reto ${retoIndex + 1} renderizado`);
}

// --- VERIFICAR LA RESPUESTA DEL USUARIO ---
async function verificar() {
    const idTransaccion = `verificar_respuesta_${Date.now()}`;
    let retoActual, respuestaUsuario;
    
    try {
        // Validar que hay un reto actual
        retoActual = retosAventura1Es[currentRetoIndex];
        if (!retoActual) {
            throw new Error('No hay un reto actual para verificar');
        }
        
        console.log(`[${IFRAME_ID}] Verificando respuesta para reto:`, { 
            retoId: retoActual.id, 
            idTransaccion 
        });

        // Obtener la respuesta del usuario
        const opciones = document.querySelectorAll('input[type="radio"]:checked, input[type="checkbox"]:checked');
        const inputTexto = document.getElementById("respuestaTexto");
        respuestaUsuario = [];

        if (opciones.length > 0) {
            opciones.forEach((opcion) => {
                respuestaUsuario.push(opcion.value);
            });
        } else if (inputTexto && inputTexto.value.trim() !== '') {
            respuestaUsuario.push(inputTexto.value.trim());
        } else {
            mostrarMensaje("Por favor, selecciona una opción o escribe tu respuesta.", "error");
            return;
        }

        // Verificar si la respuesta es correcta (comparación insensible a mayúsculas/minúsculas)
        const esCorrecta = retoActual.correctas.some((correcta) =>
            respuestaUsuario.some((respuesta) => respuesta.toLowerCase() === correcta.toLowerCase())
        );

        // Actualizar el estado
        estadoApp.ultimaRespuesta = {
            retoId: retoActual.id,
            respuesta: respuestaUsuario,
            esCorrecta,
            timestamp: new Date().toISOString(),
            idTransaccion
        };

        // Mostrar retroalimentación
        if (esCorrecta) {
            await manejarRespuestaCorrecta(retoActual, idTransaccion);
        } else {
            await manejarRespuestaIncorrecta(retoActual, idTransaccion);
        }
        
    } catch (error) {
        console.error(`[${IFRAME_ID}] Error al verificar la respuesta:`, error);
        
        // Notificar al padre del error
        await notificarError('error_verificar_respuesta', {
            retoId: retoActual?.id,
            respuestaUsuario,
            idTransaccion,
            mensaje: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
        });
        
        // Mostrar mensaje de error al usuario
        mostrarMensaje("Ha ocurrido un error al verificar tu respuesta. Por favor, inténtalo de nuevo.", "error");
    }
}

/**
 * Maneja una respuesta correcta del usuario
 * @param {Object} retoActual - El reto actual
 * @param {string} idTransaccion - ID de transacción para seguimiento
 */
async function manejarRespuestaCorrecta(retoActual, idTransaccion) {
    // Mostrar retroalimentación visual
    mostrarMensaje("¡Respuesta correcta!", "exito");
    fuegosArtificiales();
    
    // Deshabilitar controles
    const btnEnviar = document.getElementById("btnEnviar");
    if (btnEnviar) btnEnviar.disabled = true;
    
    // Habilitar el botón de continuar
    const btnContinuar = document.getElementById("btnContinueReto");
    if (btnContinuar) {
        btnContinuar.disabled = false;
        
        // Configurar manejador de eventos para continuar
        const manejarContinuar = async () => {
            console.log(`[${IFRAME_ID}] Continuando después del reto ${retoActual.id}`);
            
            try {
                // Notificar al padre que el usuario quiere continuar
                await enviarMensajeAlPadre('reto_finalizado', {
                    retoId: retoActual.id,
                    exito: true,
                    continuar: true,
                    idTransaccion
                });
                
                // Limpiar la interfaz
                const retoContenidoDiv = document.getElementById("reto-contenido");
                if (retoContenidoDiv) {
                    retoContenidoDiv.innerHTML = '';
                }
                
                // Deshabilitar el botón de nuevo
                btnContinuar.disabled = true;
                
                // Limpiar el manejador de eventos para evitar duplicados
                btnContinuar.removeEventListener('click', manejarContinuar);
                
            } catch (error) {
                console.error(`[${IFRAME_ID}] Error al continuar después del reto:`, error);
                mostrarMensaje("Error al continuar. Por favor, inténtalo de nuevo.", "error");
            }
        };
        
        // Asignar el manejador de eventos
        btnContinuar.addEventListener('click', manejarContinuar);
        btnContinuar.focus();
    }
    
    // Notificar al padre que el reto se completó exitosamente
    await enviarMensajeAlPadre('reto_completado', {
        retoId: retoActual.id,
        tipo: retoActual.tipo,
        exito: true,
        esPuzzle: false,
        puntos: retoActual.puntos || 10,
        idTransaccion,
        timestamp: new Date().toISOString()
    });
    
    console.log(`[${IFRAME_ID}] Reto completado correctamente:`, { 
        retoId: retoActual.id,
        idTransaccion 
    });
}

/**
 * Maneja una respuesta incorrecta del usuario
 * @param {Object} retoActual - El reto actual
 * @param {string} idTransaccion - ID de transacción para seguimiento
 */
async function manejarRespuestaIncorrecta(retoActual, idTransaccion) {
    // Efecto de vibración para retroalimentación
    vibrar();
    
    // Habilitar controles para reintentar
    const btnEnviar = document.getElementById("btnEnviar");
    if (btnEnviar) btnEnviar.disabled = false;
    
    // Mostrar botón para ver la respuesta
    const btnMostrarRespuesta = document.getElementById("btnMostrarRespuesta");
    if (btnMostrarRespuesta) {
        btnMostrarRespuesta.style.display = "inline-block";
    }
    
    // Notificar al padre del fallo
    await notificarEstado('reto_fallido', {
        retoId: retoActual.id,
        idTransaccion,
        timestamp: new Date().toISOString()
    });
    
    console.log(`[${IFRAME_ID}] Respuesta incorrecta para el reto:`, { 
        retoId: retoActual.id,
        idTransaccion 
    });
}

// ================== EVENT LISTENERS ==================

// --- REFERENCIAS A ELEMENTOS DEL DOM ---
const elementosUI = {
    // Obtiene los elementos del DOM de forma perezosa
    get btnEnviar() { return document.getElementById("btnEnviar"); },
    get btnContinueReto() { return document.getElementById("btnContinueReto"); },
    get divRespuestaCorrecta() { return document.getElementById("respuesta-correcta"); },
    get retoContenido() { return document.getElementById("reto-contenido"); },
    get btnMostrarRespuesta() { return document.getElementById("btnMostrarRespuesta"); },
    get iframe() { return window.frameElement; },
    
    // Métodos de utilidad
    limpiarContenido() {
        if (this.retoContenido) this.retoContenido.innerHTML = '';
        if (this.divRespuestaCorrecta) {
            this.divRespuestaCorrecta.textContent = '';
            this.divRespuestaCorrecta.style.display = 'none';
        }
    },
    
    configurarBotonContinuar(manejador) {
        if (!this.btnContinueReto) return;
        
        // Clonar el botón para eliminar manejadores anteriores
        const nuevoBoton = this.btnContinueReto.cloneNode(true);
        this.btnContinueReto.parentNode.replaceChild(nuevoBoton, this.btnContinueReto);
        
        // Configurar el nuevo manejador
        nuevoBoton.style.display = 'inline-block';
        nuevoBoton.addEventListener('click', manejador, { once: true });
    },
    
    ocultarInterfaz() {
        if (this.iframe) {
            this.iframe.style.display = 'none';
        }
    }
};

// --- FUNCIONES DE UTILIDAD ---

/**
 * Limpia la interfaz del reto
 */
function limpiarInterfaz() {
    elementosUI.limpiarContenido();
    
    if (elementosUI.btnEnviar) {
        elementosUI.btnEnviar.disabled = false;
    }
    
    if (elementosUI.btnContinueReto) {
        elementosUI.btnContinueReto.style.display = 'none';
    }
}

/**
 * Notifica al padre que un reto ha finalizado
 * @param {Object} reto - El reto actual
 * @param {string} idTransaccion - ID de transacción para seguimiento
 * @param {boolean} exito - Indica si el reto se completó con éxito
 * @param {boolean} respuestaMostrada - Indica si se mostró la respuesta
 * @returns {Promise<void>}
 */
async function notificarRetoFinalizado(reto, idTransaccion, exito, respuestaMostrada = false) {
    return enviarMensajeAlPadre('reto_finalizado', {
        retoId: reto.id,
        exito,
        respuestaMostrada,
        continuar: true,
        idTransaccion,
        timestamp: new Date().toISOString()
    });
}

/**
 * Muestra un mensaje de error al usuario y lo registra
 * @param {Error|string} error - El error ocurrido o mensaje de error
 * @param {string} contexto - Contexto donde ocurrió el error
 * @param {Object} [datosAdicionales={}] - Datos adicionales para el log
 * @returns {Promise<Error>} El error procesado
 */
async function manejarError(error, contexto, datosAdicionales = {}) {
    // Manejar tanto objetos Error como strings
    const errorObj = typeof error === 'string' ? new Error(error) : error;
    const { retoId, idTransaccion } = datosAdicionales;
    const mensajeError = `[${IFRAME_ID}] Error en ${contexto}: ${errorObj.message}`;
    
    console.error(mensajeError, errorObj);
    
    if (idTransaccion) {
        try {
            await notificarError(`error_${contexto}`.toLowerCase(), {
                retoId,
                idTransaccion,
                mensaje: errorObj.message,
                stack: errorObj.stack,
                ...datosAdicionales,
                timestamp: new Date().toISOString()
            });
        } catch (notifyError) {
            console.error(`[${IFRAME_ID}] Error al notificar error al padre:`, notifyError);
        }
    }
    
    mostrarMensaje(`Ha ocurrido un error al ${contexto}. Por favor, inténtalo de nuevo.`, "error");
    return errorObj;
}

/**
 * Muestra la respuesta correcta al usuario y notifica al padre
 * @param {Object} reto - El reto actual
 * @param {string} idTransaccion - ID de transacción para seguimiento
 */
async function mostrarRespuestaCorrecta(reto, idTransaccion) {
    if (!reto) {
        return manejarError(new Error('reto no definido'), 'mostrar respuesta', { idTransaccion });
    }

    try {
        // Mostrar la respuesta correcta según el tipo de reto
        if (elementosUI.divRespuestaCorrecta) {
            elementosUI.divRespuestaCorrecta.textContent = 
                (reto.tipo === "opcion" || reto.tipo === "opcion-multiple")
                    ? `Respuesta correcta: ${reto.correctas.join(", ")}`
                    : "Puede continuar con la aventura.";
            elementosUI.divRespuestaCorrecta.style.display = "block";
        }

        // Deshabilitar el botón de enviar
        if (elementosUI.btnEnviar) {
            elementosUI.btnEnviar.disabled = true;
        }

        // Configurar el botón de continuar
        const manejarContinuar = async () => {
            try {
                await notificarRetoFinalizado(reto, idTransaccion, false, true);
                limpiarInterfaz();
            } catch (error) {
                await manejarError(error, 'continuar después de mostrar respuesta', { 
                    retoId: reto.id, 
                    idTransaccion 
                });
            }
        };
        
        elementosUI.configurarBotonContinuar(manejarContinuar);
        
        // Notificar al padre que se mostró la respuesta
        await notificarEstado('respuesta_mostrada', {
            retoId: reto.id,
            respuestaCorrecta: reto.correctas,
            idTransaccion,
            timestamp: new Date().toISOString()
        });
        
        console.log(`[${IFRAME_ID}] Respuesta mostrada para el reto:`, { 
            retoId: reto.id,
            idTransaccion 
        });
        
    } catch (error) {
        await manejarError(error, 'mostrar respuesta', { retoId: reto?.id, idTransaccion });
    }
}

// --- MOSTRAR RESPUESTA CORRECTA AL USUARIO ---
btnMostrarRespuesta.addEventListener("click", async () => {
    if (currentRetoIndex === -1 || !estadoApp.controlesHabilitados) {
        console.warn(`[${IFRAME_ID}] No se puede mostrar la respuesta: reto no disponible o controles deshabilitados`);
        return;
    }
    
    const reto = retosAventura1Es[currentRetoIndex];
    const idTransaccion = `mostrar_respuesta_${Date.now()}`;
    
    console.log(`[${IFRAME_ID}] Mostrando respuesta para reto:`, { 
        retoId: reto?.id, 
        idTransaccion 
    });
    
    await mostrarRespuestaCorrecta(reto, idTransaccion);
});

/**
 * Maneja la acción de continuar después de completar un reto
 * @param {Object} reto - El reto actual
 * @param {string} idTransaccion - ID de transacción para seguimiento
 * @param {boolean} [exito=false] - Indica si el reto se completó con éxito
 */
async function manejarContinuarReto(reto, idTransaccion, exito = false) {
    if (!reto) {
        return manejarError(new Error('reto no definido'), 'continuar reto', { idTransaccion, exito });
    }

    try {
        // Ocultar el botón de continuar
        if (elementosUI.btnContinueReto) {
            elementosUI.btnContinueReto.style.display = "none";
        }

        // Notificar al padre que el reto se ha completado
        await notificarRetoFinalizado(reto, idTransaccion, exito, false);

        // Limpiar la interfaz
        limpiarInterfaz();

        // Ocultar el iframe después de un breve retraso
        setTimeout(() => elementosUI.ocultarInterfaz(), 100);

        console.log(`[${IFRAME_ID}] Continuando después del reto:`, { 
            retoId: reto.id,
            exito,
            idTransaccion 
        });

    } catch (error) {
        await manejarError(error, 'continuar reto', { 
            retoId: reto?.id, 
            idTransaccion, 
            exito 
        });
    }
}

// --- BOTÓN CONTINUAR RETO ---
btnContinueReto.addEventListener("click", async () => {
    if (currentRetoIndex === -1 || !estadoApp.controlesHabilitados) {
        console.warn(`[${IFRAME_ID}] No se puede continuar: reto no disponible o controles deshabilitados`);
        return;
    }
    
    const reto = retosAventura1Es[currentRetoIndex];
    const idTransaccion = `continuar_reto_${Date.now()}`;
    
    console.log(`[${IFRAME_ID}] Continuando reto:`, { 
        retoId: reto?.id, 
        idTransaccion 
    });
    
    await manejarContinuarReto(reto, idTransaccion, true);
});

// --- EVENTOS DE BOTONES ---
btnEnviar.addEventListener("click", verificar);

// ================== MANEJADORES DE MENSAJES ==================

// --- CONFIGURAR MANEJADORES DE MENSAJES ---
function configurarManejadoresMensajes() {
    if (!window.Mensajeria || typeof window.Mensajeria.registrarControlador !== 'function') {
        console.error('❌ No se pueden configurar manejadores: Mensajeria no está disponible');
        return;
    }
    
    // Manejar cambio de modo
    window.Mensajeria.registrarControlador(
        window.Mensajeria.TIPOS_MENSAJE.CAMBIO_MODO,
        (mensaje) => {
            const { modo, habilitar } = mensaje.datos || {};
            console.log(`🔄 HIJO 4: Recibido cambio de modo: ${modo}, habilitar: ${habilitar}`);
            manejarCambioModo(mensaje);
        }
    );
    
    // Manejar controles
    window.Mensajeria.registrarControlador(
        'habilitar_controles',
        (mensaje) => {
            const { modo } = mensaje.datos || {};
            console.log('🔓 HIJO 4: Habilitando controles');
            enableControls(modo || 'casa');
        }
    );

    window.Mensajeria.registrarControlador(
        'deshabilitar_controles',
        (mensaje) => {
            const { motivo } = mensaje.datos || {};
            console.log('🔒 HIJO 4: Deshabilitando controles');
            disableControls(motivo || 'desconocido');
        }
    );
    
    // Manejar solicitud de mostrar reto
    window.Mensajeria.registrarControlador(
        window.Mensajeria.TIPOS_MENSAJE.RETO,
        (mensaje) => {
            const { accion, parametros } = mensaje.datos || {};
            if (accion === 'mostrar' && typeof parametros?.index === 'number') {
                console.log(`🎯 HIJO 4: Mostrando reto ${parametros.index}`);
                // Almacenar el ID del reto actual
                window.retoActual = {
                    id: retosAventura1Es[parametros.index].id,
                    index: parametros.index
                };
                renderizarReto(parametros.index);
            }
        }
    );
    
    // Manejar solicitud de mostrar puzzle
    window.Mensajeria.registrarControlador(
        'PUZZLE.MOSTRAR',
        (mensaje) => {
            const { puzzleId, retoId } = mensaje.datos || {};
            if (puzzleId) {
                console.log(`🧩 HIJO 4: Mostrando puzzle ${puzzleId} del reto ${retoId}`);
                // Almacenar el ID del puzzle actual
                window.puzzleActual = { id: puzzleId, retoId };
                
                // Notificar que el puzzle se mostró
                enviarMensajeAlPadre('puzzle_mostrado', { puzzleId, retoId });
            }
        }
    );
    
    // Manejar notificación de puzzle completado
    window.Mensajeria.registrarControlador(
        'PUZZLE.COMPLETADO',
        (mensaje) => {
            const { puzzleId } = mensaje.datos || {};
            console.log(`✅ HIJO 4: Puzzle ${puzzleId} completado`);
            
            // Notificar al padre que el puzzle se completó
            enviarMensajeAlPadre('puzzle_finalizado', {
                puzzleId,
                exito: true,
                retoId: window.retoActual?.id
            });
            
            // Limpiar referencia al puzzle actual
            delete window.puzzleActual;
        }
    );
}

// ================== INICIALIZACIÓN ==================

// --- INICIALIZAR MENSAJERÍA Y NOTIFICAR AL PADRE ---
window.addEventListener("DOMContentLoaded", async () => {
    try {
        // Inicializar variables para rastrear el reto/puzzle actual
        window.retoActual = null;
        window.puzzleActual = null;
        
        // Verificar que Mensajeria esté disponible
        if (typeof window.Mensajeria === 'undefined') {
            console.error('❌ No se pudo cargar el módulo de mensajería');
            throw new Error('El módulo de mensajería no está disponible');
        }
        
        // Inicializar mensajería con configuración
        try {
            await window.Mensajeria.inicializarMensajeria({
                iframeId: 'hijo4',
                logLevel: 1, // 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR, 4=NONE
                debug: true,
                dominioPermitido: '*',
                maxRetries: 3,
                retryDelay: 1000
            });
            
            console.log('✅ HIJO 4: Mensajería inicializada correctamente');
        } catch (error) {
            console.error('❌ HIJO 4: Error al inicializar la mensajería:', error);
            throw error; // Relanzar para ser manejado por el catch externo
        }
        
        // Configurar manejadores de mensajes
        configurarManejadoresMensajes();
        console.log('✅ HIJO 4: Manejadores de mensajes configurados');
        
        // Empezar con retos deshabilitados (modo aventura por defecto)
        manejarCambioModo('aventura', false);
        
        // Notificar al padre que el hijo está listo
        try {
            await enviarMensajeAlPadre('sistema_estado', {
                tipo: 'inicializacion_completa',
                estado: 'listo',
                modo: 'aventura',
                controlesHabilitados: false,
                timestamp: Date.now()
            });
            console.log('✅ HIJO 4: Notificación de inicialización enviada al padre');
        } catch (error) {
            console.warn('⚠️ HIJO 4: No se pudo notificar al padre:', error);
            // Continuar a pesar del error de notificación
        }
        
        console.log(`✅ HIJO 4: Inicialización completada - Modo: aventura, Controles: Deshabilitados`);
    } catch (error) {
        console.error('❌ HIJO 4: Error crítico durante la inicialización:', error);
        
        // Asegurarse de que los retos estén deshabilitados en caso de error
        disableControls('error_inicializacion');
        
        // Notificar el error al padre si es posible
        if (window.Mensajeria?.enviarMensajeConReintenos) {
            try {
                await window.Mensajeria.enviarMensajeConReintenos(
                    'padre',
                    'sistema_error',
                    {
                        tipo: 'error_inicializacion',
                        mensaje: error.message,
                        stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,
                        timestamp: Date.now()
                    },
                    { maxRetries: 2, retryDelay: 500 }
                );
            } catch (e) {
                console.error('❌ HIJO 4: No se pudo notificar el error al padre:', e);
            }
        }
        
        // Mostrar mensaje de error al usuario
        mostrarErrorInicializacion(error);
    }
});
</script>
</body>
</html>
